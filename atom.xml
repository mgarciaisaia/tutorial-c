<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[C para Operativos]]></title>
  <link href="http://mgarciaisaia.github.io/tutorial-c/atom.xml" rel="self"/>
  <link href="http://mgarciaisaia.github.io/tutorial-c/"/>
  <updated>2013-12-31T02:34:17-03:00</updated>
  <id>http://mgarciaisaia.github.io/tutorial-c/</id>
  <author>
    <name><![CDATA[mgarciaisaia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Me dí cuenta que me tiraste la señal]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/"/>
    <updated>2013-12-31T00:27:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal</id>
    <content type="html"><![CDATA[<p>Uno de los mecanismos de <abbr title="Inter-Process Communication - Comunicación entre procesos">IPC</abbr> que nos provee Linux es el envío de señales. Es un modo de comunicación MUY minimalista: un proceso le envía una determinada señal a otro, y este último simplemente recibe el código asociado a la señal recibida.</p>

<p>Y nada más. No hay parámetros, no hay información del emisor, nada. Sólo un código.</p>

<p>Y, aún así, es un método más que útil: para terminar un proceso en la terminal (cuando apretamos <code>CTRL+C</code>), para cerrar un programa que se colgó (desde algún administrador de tareas), para pausar la ejecución de un proceso o para cerrar un programa clickeando la <code>x</code> de cierre en su ventana &ndash; en todos estos casos estamos mandando una señal a un proceso.</p>

<p>Las señales tienen asociadas distintas acciones por defecto, que se ejecutarán cuando el proceso reciba cada señal. Por ejemplo, al recibir <code>SIGTERM</code> o <code>SIGKILL</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, el proceso finalizará con un código de salida no-exitoso, mientras que la señal <code>SIGUSR1</code> será ignorada (el proceso no hará nada al recibirla).</p>

<p>Lo interesante de las señales es que los procesos pueden especificar sus propias acciones a ejecutar cuando la señal es recibida, en lugar de ejecutar la acción por defecto. Dado que las señales se envían a los procesos<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, alguno de sus hilos se interrumpirá para pasar a ejecutar una función que nosotros determinemos cuando la señal llegue, tal como si en la línea de código que está ejecutándose al momento de recibir la señal invocara a la función determinada. Al concluir la ejecución de la función, el programa retornará al punto en que estaba antes del arribo de la señal, y todo seguirá su curso normalmente.</p>

<p>Por ser un mecanismo de IPC (es decir, involucra a más de un proceso), no hay otra opción: para que esto funcione, de algún modo <strong>debe</strong> intervenir el sistema operativo. Linux utiliza tres máscaras (bitmaps) para cada proceso, indicando qué señales deberán ignorarse, cuáles están bloqueadas (se encolan hasta ser desbloqueadas) y cuáles serán capturadas para ser atendidas por el proceso en lugar de aplicarles la acción por defecto.</p>

<p>Entonces, si el proceso tiene un manejador de señal definido, al recibir la señal el proceso bloqueará la recepción de esa señal, ejecutará la función correspondiente y, al finalizar, desbloqueará la señal. De este modo, se evita interrumpir la ejecución del manejador de la señal, para evitar conflictos con por sincronización (si el manejador lockea un mutex y se interrumpe con una nueva ejecución de si mismo antes de liberarlo, estaríamos en presencia de un auto-deadlock <code>:)</code>).</p>

<p>El problema que inspiró este post viene con el uso de <code>exec*</code>. <code>execve</code> es una llamada al sistema que reemplaza la imagen de un proceso por una nueva, pasando a ejecutar un nuevo programa. La familia de funciones <code>exec*</code> son wrappers de esa syscall.</p>

<p>Lo importante de todo esto son dos cosas: una <code>execve</code> exitosa no retorna, y reemplazar la imagen de un proceso no implica cambiar los atributos del mismo. De <code>man 2 execve</code>:</p>

<pre><code>All process attributes are preserved during an execve(), except the following:
</code></pre>

<p>Y, adiviná qué: las máscaras de las señales no son parte de las excepciones. Entonces, repasemos: llega la señal, se bloquean la señal recibida, y se ejecuta el handler de la señal. Si ese handler hiciera un <code>execve</code> exitoso, la función no retorna: empieza a ejecutar el nuevo proceso. Pero, si el handler no retorna, nunca se desbloquea la señal, por lo que el nuevo proceso no recibirá más la señal especificada, porque serán encoladas eternamente. Bang.</p>

<p>La solución a esto es desbloquear la señal a mano antes de llamar a <code>execve</code>. En C, desde dentro del handler, podríamos lograrlo usando este fragmento de código:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>
</span><span class='line'><span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
</span><span class='line'><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
</span><span class='line'><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>sigemptyset</code> inicializa un set de señales vacío, y luego marcamos la señal que nos interese (en este caso, <code>SIGINT</code>) en ese set. Por último, la función <code>sigprocmask</code> es la que se encargará, con estos parámetros, de desbloquear el set de señales marcados (sólo <code>SIGINT</code>). Luego de esto, sí, podremos ejecutar <code>execve</code> sin problemas.</p>

<p><strong>Créditos</strong>: mucha información de este post surgió a partir de <a href="http://stackoverflow.com/a/1024778">esta respuesta en StackOverflow</a>.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Se pueden listar todas las señales ejecutando <code>kill -l</code><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>En Linux, que tiene <abbr title="Kernel Level Thread - Hilos de Kernel">KLTs</abbr>, uno puede enviar la señal especificando un <abbr title="Thread ID - Identificador de Hilo">TID</abbr> en lugar de un <abbr title="Process ID - Identificador de Proceso">PID</abbr>, por lo que puede mandarle la señal a un hilo en particular. Poniéndonos más técnicos, el PID coincide con el TID del hilo principal (<code>main()</code>), por lo que al enviarle la señal al proceso en realidad se la estamos enviando al hilo principal. Pero la idea genérica de &ldquo;las señales se envían a procesos&rdquo; es más feliz.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[inotify]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/30/inotify/"/>
    <updated>2013-12-30T02:09:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/30/inotify</id>
    <content type="html"><![CDATA[<blockquote><p>**Disclaimer**: nunca implementé inotify, por lo que este post puede ser incompleto, incorrecto, o cualquier otro &#8220;in&#8221; que se te ocurra. Su espíritu es simplemente poder referenciar acá cada vez que surja un inconveniente con la herramienta, para no repetir lo que escribo siempre, y para cada vez dar una mejor respuesta. Todo aporte será más que bienvenido.</p></blockquote>


<p>El mundo real apesta. Existe el hambre, la capa de ozono se debilita, y el software obra de maneras misteriosas.</p>

<p><code>inotify</code> es una API de Linux que nos permite monitorear cambios en un archivo o directorio. En criollo, es un <em>duende</em> al que le pedimos que levante la mano cuando ocurre algún evento que a nosotros nos interese, como la creación de un archivo en un directorio, la eliminación de un archivo o una escritura.<!--more--></p>

<p>Como es funcionalidad que provee el kernel, claramente está bien implementada: nada de tener al duende haciendo <code>ls</code> cada medio segundo para que avise al encontrar diferencias entre los últimos dos <code>ls</code>, sino que existe un modelo de eventos, y nosotros podemos especificar aquellos que nos interesa que se nos notifiquen (de ahí el 90% del nombre, je).</p>

<p>El otro 10% es la i. <code>inotify</code> es funcionalidad que provee el kernel, por lo que trabaja al nivel al que el kernel conoce a los archivos, el File Control Block: los inodos. Al atender las diferentes llamadas al sistema (syscalls), el kernel dispara también las notificaciones correspondientes.</p>

<p>Los eventos por los que podemos ser notificados están explicados en el man:</p>

<pre><code>IN_ACCESS         File was accessed (read) (*).
IN_ATTRIB         Metadata changed, e.g., permissions, timestamps, extended attributes,
                    link count (since Linux 2.6.25), UID, GID, etc. (*).
IN_CLOSE_WRITE    File opened for writing was closed (*).
IN_CLOSE_NOWRITE  File not opened for writing was closed (*).
IN_CREATE         File/directory created in watched directory (*).
IN_DELETE         File/directory deleted from watched directory (*).
IN_DELETE_SELF    Watched file/directory was itself deleted.
IN_MODIFY         File was modified (*).
IN_MOVE_SELF      Watched file/directory was itself moved.
IN_MOVED_FROM     File moved out of watched directory (*).
IN_MOVED_TO       File moved into watched directory (*).
IN_OPEN           File was opened (*).
</code></pre>

<p>El problema ocurre con el mundo real. Dado que en ningún lugar está definido el contrato de cómo un programa tiene que implementar sus funcionalidades (por comunes que sean, como la actualización de un archivo), cada aplicación en particular puede implementar un conjunto de llamadas al sistema distinto para hacerlo. Si a esto sumamos la antiguedad y diversidad de orígenes de los editores de texto que se usan en Linux (algunos datan de los 70, pensados para usar en mainframes, mientras que otros son más recientes y apuntan a optimizar acceso a disco, o uso de memoria, o tiempo de respuesta), el panorama es realmente complejo: algunos editores de texto simplemente actualizarán los bloques de datos que hayan cambiado, mientras que otros optarán por enfoques más extraños.</p>

<p>Un caso conocido es el de <code>nano</code>. Al grabar un archivo pequeño (archivos menores a 1 bloque &ndash; 4kb), <code>nano</code> optará por vaciar el archivo (truncarlo a 0 bytes) y luego grabar su contenido, por lo que <code>inotify</code> disparará dos eventos: <code>IN_MODIFIY</code> (&ldquo;el archivo fue vaciado&rdquo;), y luego otro <code>IN_MODIFY</code> (&ldquo;se escribió el contenido del archivo&rdquo;).</p>

<p><code>vim</code>, por otro lado, mantiene un archivo de backup mientras vamos trabajando, para ahorrarnos algún dolor de cabeza si se nos llegara a apagar mal la máquina. Ahora, como ya mantiene ese archivo de backup, a <code>vim</code> le es más facil, cuando le pedimos grabar un archivo, reemplazar el archivo que existía por el backup actualizado, y listo. El resultado de esto es un set de llamadas al sistema bastante distinto al de <code>nano</code>: primero elimina el archivo original, y luego renombra el backup para que ocupe la ruta en que se encontraba el original. El problema con esto no sólo es que no hay eventos <code>IN_MODIFY</code>, sino que, como dijimos, <code>inotify</code> conoce inodos: el archivo del backup, por más que pase a llamarse igual que el original, es un inodo distinto, por lo que <code>inotify</code> dejará de detectar eventos sobre el archivo que se encuentra en el path que habíamos especificado.</p>

<p>&ldquo;Solucionar&rdquo; estos problemas requiere tener en cuenta el comportamiento de cada editor y reaccionar de manera acorde cuando se detectan los eventos.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bajando el nivel]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/10/21/bajando-el-nivel/"/>
    <updated>2013-10-21T01:19:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/10/21/bajando-el-nivel</id>
    <content type="html"><![CDATA[<p>&ldquo;Che, me acabás de decir que el 0 sigue existiendo por más que <em>lo pise</em> con otro valor. ¿El 0 es un objeto al que la VM le mantiene referencias y por eso no se lo lleva el Garbage Collector?&rdquo;<!--more--></p>

<p>What!? No way, papá. Por un cuatrimestre, las palabras &ldquo;objeto&rdquo; y &ldquo;Garbage Collector&rdquo; dejalas en la oficina, y VM = VirtualBox :)</p>

<p>En C no hay objetos.</p>

<p>Perdón si fui duro, pero es necesario: en C no hay objetos. Y no hay GC.</p>

<p>&ldquo;Entonces, ¿qué es el 0?&rdquo;</p>

<p>El 0 es una constante. Si recordás, en Arquitectura (bazinga) vimos que los números se representan en binario en la PC. Las variables de C son meras referencias a algún bloque de memroia, siendo el tipo de la variable el que anuncia qué tamaño tiene esa referencia.</p>

<p>Digamos, esto es una memoria de 30 bytes<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (éramos tan pobres):</p>

<p><img src="http://mgarciaisaia.github.io/tutorial-c/assets/memoria-libre.png" alt="Una RAM de 30 bytes" /></p>

<p>Esa es toda la memoria de esta computadora hipotética. Si en mi programa declaro una variable <code>int exit_status;</code>, podríamos pensarlo como que C hará algo así:</p>

<p><img src="http://mgarciaisaia.github.io/tutorial-c/assets/memoria-reservada.png" alt="La RAM con una variable" /></p>

<p>En algún lugar de la memoria (en este caso, a partir del byte 13), C reservó<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> unos bytes para nuestra variable ¿Cuántos bytes reservó? Eso depende del tipo de dato que le declaramos a la variable. Por definición, el tipo <code>int</code> equivale al <a href="http://es.wikipedia.org/wiki/Palabra_(inform%C3%A1tica)">tamaño de palabra del procesador</a>. Esto significa que en máquinas de 32 bits (como esta computadora hipotética, o las VMs de la cátedra, o la enorme mayoría de los Windows XP y Vista), un <code>int</code> va a ocupar 4 bytes (32 bits).</p>

<p>Entonces, al hacer algo como <code>exit_status = 0;</code> (y sabiendo que <code>exit_status</code> es una variable entera de 4 bytes), el compilador sabe que tiene que hacer que los 4 bytes que están a partir del byte en que empieza <code>exit_status</code> valgan un 0. En Arquitectura aprendimos que los enteros con signo se representan usando el <a href="http://es.wikipedia.org/wiki/Complemento_a_dos">complemento a 2</a>, por lo que el 0 en 32 bits es simplemente <a href="http://es.wikipedia.org/wiki/Sistema_hexadecimal"><code>0x0000 0000</code></a> (4 bytes en 0).</p>

<p>Entonces, ¿dónde está ese 0? <a href="http://es.wikipedia.org/wiki/Hard_code">Hardcodeado</a> en el binario. Compilar un programa es pedirle al compilador (<code>gcc</code> en nuestro caso) que traduzca todo ese C hermoso que escribimos en las instrucciones de Assembler que nuestro procesador tiene que ejecutar para que el código funcione con nuestro sistema operativo. De todas esas, alguna va a ser algo como <code>mov eax, 0x00000000</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>: <strong>ese</strong> es tu 0.</p>

<p>&ldquo;¿Y a mí cuál?&rdquo;</p>

<p>Meh, no mucho. Sólo quería dejar en claro cómo funciona esto: C es una mini abstracción de la programación en Assembler, por lo que no está tan lejos. No tenés que ser un capo de Assembler para programar C<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> (no necesitás saber Assembler, siquiera), pero tenés que tener un claro entendimiento de cómo funciona la computadora a bajo nivel para entender qué es lo que está haciendo tu código.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>La memoria de una PC tiene muchísimo más tamaño, pero dejame hacerla dibujable.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>C es un lenguaje. Decir &ldquo;C hizo tal cosa&rdquo; es medio vago: probablemente sea algo que hizo el compilador, o el sistema operativo, o alguna biblioteca más o menos estándar. Cuando decimos &ldquo;C hizo tal cosa&rdquo; es porque: a) no nos interesa mucho quién lo hizo (importa que lo hizo <em>otra persona</em>, y que es más o menos lo mismo para cualquier programa en C), o b) no sabemos quién lo hizo (y nos da fiaca averiguarlo, de momento).<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>No se Assembler, creo que el parámetro no va en la misma línea que el <code>mov</code>, pero anda por ahí cerca.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Lo aclaré en la anterior: no se Assembler.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variables]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/20/variables/"/>
    <updated>2013-08-20T01:21:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/20/variables</id>
    <content type="html"><![CDATA[<p>Bien. Escribimos, compilamos y corrimos nuestro primer programa. Pero es como bastante aburrido, ¿no? Vamos a ponerle onda: declaremos una variable (¡iupi! (¿?))</p>

<figure class='code'><figcaption><span>ok.c (v2) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Guau. Me la jugué :) Anoche no dormí porque me quedé debuggeando un error en este programa.<!--more--></p>

<p>¿Qué cambió? Bueno, entre las llaves hay dos instrucciones ahora. En principio, donde antes decía <code>return 0;</code>, ahora dice <code>return exit_status;</code>.</p>

<p>&ldquo;Así que seguramente <code>exit_status</code> sea una variable mágica de C, como <code>$?</code> en bash&rdquo; Pendorcho. <code>exit_status</code> es una variable, sí. Osea, es un identificador de un <em>cacho&#8217;e memoria</em>. Puedo guardar <em>cosas</em> ahí, y luego leerlas. Pero antes necesito declararla, para decir: a) que existe; y b) qué tipo de cosas va a manejar esa variable. Y eso es lo que hicimos antes: <code>int exit_status = 0;</code>.</p>

<p>Para declarar una variable, especificamos su tipo de dato, seguido por su nombre. En nuestro caso, <code>int exit_status</code> crea una variable de tipo <code>int</code> llamada <code>exit_status</code>. Declaraciones válidas son <code>int hola;</code> o <code>int hola, chau;</code>, por ejemplo: la primera declara una variable <code>hola</code> de tipo <code>int</code>, mientras que la segunda crea <code>hola</code> y <code>chau</code>, dos variables de tipo <code>int</code>, ambas totalmente independientes entre sí.</p>

<p>Pero con declarar la variable no alcanza: si queremos devolverla o leerla, primero tenemos que darle un valor (&ldquo;inicializarla&rdquo;, para los amigos). En C, las asignaciones son del estilo <code>variable = expresion;</code>, donde, en nuestro caso original, <code>expresion</code> es un triste <code>0</code> constante. Y ahí tenemos nuestra primera línea: <code>int exit_status = 0;</code>.</p>

<p>&ldquo;Che, y, entonces, si no es una variable mágica de C, ¿por qué se llama <code>exit_status</code> y no, por ejemplo, <code>a</code>, <code>bleh</code> o <code>code</code>?&rdquo; Bueno, porque nosotros <strong>sí</strong> fuimos a la clase de nombres bonitos y representativos :) Y si esa variable representa nuestro estado de salida, así la llamaremos<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Podríamos haberla llamado <code>a</code>, <code>bleh</code>, <code>code</code> o <code>__a256723b</code>, pero preferimos reservarnos los nombres horribles para las PPT :)</p>

<p>Buen, a ver qué hace este programa:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>Compilamos y ejecutamos, y vemos que sigue sin mostrar nada. Hacemos el <code>echo</code> y vemos nuestro hermoso 0.</p>

<p>&ldquo;Che, para mí que éste nos está chamuyando y el 0 está hardcodeado por ahí&rdquo;</p>

<p>OK, cambiémoslo:</p>

<figure class='code'><figcaption><span>ok.c (v2.1) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y probemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>&ldquo;¡Ajá! ¡Te dije que nos mentía!&rdquo;</p>

<p>¡Momento, cerebrito! No recompilaste, chámpion ;&ndash;)</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p><em>¡Touché!</em></p>

<p>&ldquo;OK, ganaste. Ahora, si necesito recompilarpara cambiar el valor de una variable, muy variable no me parece. Y podría cambiar el 0 por un 1 en la primer versión de <code>ok.c</code>, y no tengo que andar haciendo tanta parafernalia. ¿Por qué se llaman <em>variables</em>?&rdquo;</p>

<p>Buen, sí, justamente, porque podés cambiarles el valor durante una misma ejecución del programa. Así como inicializamos <code>exit_status</code> en 0 o en 1, podríamos después de esa incialización <em>asignarle</em> un nuevo valor. Desde que se ejecute esa instrucción en adelante, cada vez que se lea el contenido de la variable obtendremos el nuevo valor, como si nunca hubiera tenido un valor distinto:</p>

<figure class='code'><figcaption><span>ok.c (v2.2) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p><code>=</code> es el operador de asignación. El resultado de evaluar lo que esté a su derecha (ya veremos alternativas, pero por ahora quedémonos con que los números evalúan a sí mismos) se almacena en el espacio de memoria referido a la izquierda.
Y, ¿qué pasó con el 0? Se perdió. El 0 sigue existiendo y valiendo 0, como siempre. Sólo que el contenido de la variable <code>exit_status</code> se sobreescribe con <code>1</code>: la asignación es <em>destructiva</em>.</p>

<p>Sigamos jugando con esto:</p>

<figure class='code'><figcaption><span>ok.c (v2.3) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">exit_status</span> <span class="o">=</span> <span class="n">a_number</span><span class="p">;</span>
</span><span class='line'>  <span class="n">a_number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p>&ldquo;¡Eh! ¡¿Qué onda?! Si <code>exit_status</code> es igual a <code>a_number</code>, y a <code>a_number</code> le asigno <code>3</code>, ¿por qué el estado de salida es <code>1</code>?&rdquo;</p>

<p>Bueno, porque te olvidaste lo que dije de la asignación: en lo que está a la izquierda del <code>=</code> guardo el resultado de evaluar lo que está a <em>la otra izquierda</em> del mismo (comunmente conocida como &ldquo;derecha&rdquo;). Y nada más que eso: las variables no se ligan, ni quedan relacionadas, ni nada. Las variables se evalúan a su contenido del momento en que se ejecuta la instrucción, por lo que al hacer <code>exit_status = a_number;</code> estamos diciendo &ldquo;en <code>exit_status</code> guardame lo que <code>a_number</code> valga en ese momento&rdquo;. Como <code>a_number</code> venía valiendo 1, <code>exit_status</code> pasa a valer 1 también. Que después modifiquemos <code>a_number</code> es otra canción, y no tiene ninguna relación con esa asignación que ya se hizo: lo hecho, hecho está, y si al evaluar la variable ésta valía 1, los posibles valores que tenga después no importan, porque ya se realizó la asignación.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Hay miles de debates sobre escribir código en inglés vs español. No prometo ser constante durante la guía, pero tiendo a codificar en inglés. Comercialmente hablando, ~todos deseamos que nos compre Google, tercerizar el desarrollo a India, o pedir ayuda con los problemas en <a href="http://stackoverflow.com/">StackOverflow</a>. Pero, si escribir en inglés hará que no entiendas lo que representa cada cosa (cargándote la clase de nombres descriptivos), dale con el español. El piso mínimo que deberías tener es que todo el equipo (sea del TP, o de un trabajo <em>de posta</em>) use la misma convención. Y atenti con el tema de caracteres acentuados y eso, que a ¡¡50!! años de inventarse <a href="http://es.wikipedia.org/wiki/ASCII">el código ASCII</a> seguimos encontrándonos caracteres mochos por ahí, y, en el peor de los casos, puede hacernos fallar la compilción por problemas de encoding. Nadie quiere eso.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arrancando]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/19/arrancando/"/>
    <updated>2013-08-19T21:59:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/19/arrancando</id>
    <content type="html"><![CDATA[<p>Vamos a hacer un programa en C, por lo que empezamos con una función:</p>

<figure class='code'><figcaption><span>ok.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este es (aproximadamente) el programa más chico que podamos hacer en C. <code>main()</code> es la función que se ejecuta al ejecutar un programa C. En este caso, el prototipo de la función es <code>int main(void)</code>: nuestro programa no recibirá parámetros (<code>void</code>), y devolverá a quién lo ejecute un entero signado (<code>int</code>).<!--more--></p>

<p>Nuestro programa tiene una única instrucción: devolver (<code>return</code>) 0, un código de salida que, por convención, indica que el programa ejecutó correctamente.
Compilemos nuestro programa:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>ok.c ok
</span></code></pre></td></tr></table></div></figure>


<p><code>gcc</code> es el compilador más usado de C. Parte de la GNU Compiler Collection, <code>gcc</code> es el compilador específico de C (el proyecto se llamaba GNU C Compiler, pero cambiaron el nombre por soportar también C++, Java y tantos otros lenguajes). Como casi todo comando en Linux, Unix y derivados, podemos leer su manual haciendo <code>man gcc</code>.</p>

<p><code>gcc</code> recibe como parámetro (entre tantos otros) el archivo fuente a compilar (<code>ok.c</code>), y el parámetro <code>-o NOMBRE</code> indica qué nombre queremos darle al binario resultante (<code>ok</code>). De no indicarlo, <code>gcc</code> elije uno <em>hermoso</em>: <code>a.out</code>.</p>

<p>Ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>Hay un 0, así que debemos estar <em>no-tan-mal</em>, como mínimo. ¿Qué pasó acá?</p>

<p>En UNIX, la forma de ejecutar un programa es escribiendo como orden la ruta completa al mismo y, luego, separados por espacios, todos sus parámetros. Por ejemplo:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/bin/ps --version
</span><span class='line'>procps-ng version 3.3.3
</span></code></pre></td></tr></table></div></figure>


<p>Ejecutamos el programa <code>/bin/ps</code> con el parámetro <code>--version</code>. <code>ps</code> nos contesta la versión que tenemos instalada. En nuestro caso anterior, ejecutamos <code>./ok</code>. <code>.</code> y <code>..</code> son dos enlaces especiales que hay en todo directorio: <code>.</code> enlaza al directorio actual (el propio directorio que contiene a <code>.</code>), y <code>..</code> enlaza al directorio padre del actual (osea, al directorio que contiene al directorio que contiene a <code>..</code>). Entonces, al escribir <code>.</code> ya estamos referenciando toda la ruta al directorio actual. Si estamos ubicados en <code>/home/utnso</code>, <code>.</code> y <code>/home/utnso</code> se refieren al mismo directorio. Agregándole <code>/ok</code> queda <code>./ok</code>, que equivale a <code>/home/utnso/ok</code>, la ruta completa a nuestro programa. Hell yeah, ruta completa => ¡ejecutamos el programa!</p>

<p>&ldquo;Che, pero&hellip; ¡No me mostró nada! ¿Dónde está mi 0?&rdquo;</p>

<p>Bueno, sí, es cierto. No muestra nada porque no le pedimos que muestre nada: nuestro programa sólo devuelve un 0, y nuestra consola sólo ejecuta las instrucciones que le damos. Entonces, pidámosle que muestre el resultado: <code>echo $?</code>.</p>

<p>&ldquo;¡Que te recontra!&rdquo; Bueno, sí. [El amigo Bourne] (<a href="http://en.wikipedia.org/wiki/Stephen_R._Bourne">http://en.wikipedia.org/wiki/Stephen_R._Bourne</a>) había faltado a la clase de nombres descriptivos. <code>echo</code> es un comando de las consolas que imprime en pantalla<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> lo que sea que le pasemos por parámetro. Por ejemplo, <code>echo Hola mundo</code> imprime <code>Hola mundo</code>. <code>bash</code> (el lenguaje que interpreta nuestra consola) posee variables, y para dereferenciarlas (leerlas) hay que anteponerle un <code>$</code> al nombre de la variable. Por ejemplo (<code>#</code> es el caracter de comentario):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ nombre</span> <span class="o">=</span> <span class="s2">&quot;Mundo&quot;</span> <span class="c"># asigno &quot;Mundo&quot; a la variable nombre, creandola si no existe</span>
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$nombre</span> <span class="c"># imprimo el contenido de la variable llamada nombre</span>
</span><span class='line'>Mundo
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;Hola $nombre&quot;</span>
</span><span class='line'>Hola Mundo
</span></code></pre></td></tr></table></div></figure>


<p>En particular, nosotros le habíamos pedido mostrar una variable: <code>$?</code>. <code>?</code> es una variable manejada automáticamente por Bash. Cada vez que ejecuta una instrucción, Bash almacena en <code>?</code> el código de salida del programa ejecutado. Por eso, al pedirle que imprima la variable <code>?</code> (<code>echo $?</code>), Bash nos mostró el 0 que nuestro programa había devuelto.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>En realidad, imprime en la salida estándar, ya lo veremos más adelante. Por ahora, creeme que es la pantalla.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
