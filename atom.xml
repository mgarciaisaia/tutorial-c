<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[C para Operativos]]></title>
  <link href="http://mgarciaisaia.github.io/tutorial-c/atom.xml" rel="self"/>
  <link href="http://mgarciaisaia.github.io/tutorial-c/"/>
  <updated>2015-02-07T14:11:58-03:00</updated>
  <id>http://mgarciaisaia.github.io/tutorial-c/</id>
  <author>
    <name><![CDATA[mgarciaisaia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Between a rock and a hard link]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/07/between-a-rock-and-a-hard-link/"/>
    <updated>2015-02-07T11:47:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/07/between-a-rock-and-a-hard-link</id>
    <content type="html"><![CDATA[<blockquote><p>¿Qué es un hard link? ¿Qué es un soft link? ¿Qué diferencia hay entre ellos?</p></blockquote>


<p>Me parece que la clave para entender los enlaces en los filesystems basados en inodos<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> es entender <em>qué es un archivo</em>.<!--more--></p>

<h2>Archivos y directorios</h2>

<p>Un archivo está compuesto por dos partes: su contenido (<em>los bloques de datos</em>) y su metadata (<em>el inodo</em>).</p>

<p>Cuando creo un archivo llamado <code>miarchivo.txt</code> cuyo único contenido es <code>hola</code> (con, por ejemplo, el comando <code>echo hola &gt; miarchivo.txt</code>), en mi FS se reserva un bloque de datos en el que se escriben los 5 bytes <code>hola\n</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, y además se reserva un inodo que se marca como ocupado, en el que se especifica que el contenido del archivo mide 5 bytes, y se establece en el primer puntero del inodo que el primer bloque de datos es el que acabamos de reservar. Se ponen más datos, obviamente, pero por ahora no nos importan.</p>

<p>Y con eso tenemos un archivo, pero nos falta algo importante: referenciarlo. Ese archivo <strong>no tiene nombre</strong>. <em>El inodo no guarda el nombre del archivo</em>. Y yo nunca le pido al sistema operativo que me abra el archivo del inodo 5236: yo le pido rutas. Y una ruta está formada por una lista de directorios, y el nombre del archivo al final.</p>

<p>El nombre existe en el directorio.</p>

<p>Un directorio es un archivo cuyo contenido es una tabla. Cada entrada de esa tabla (las <em>entradas de directorios</em>) relaciona un nombre de archivo con un número de inodo. Al querer abrir un archivo (digamos, <code>miarchivo.txt</code>), el FS busca en esa tabla la entrada con ese nombre, y mira cuál es el número de inodo que le corresponde (digamos, <code>402</code>), y hace todas las operaciones usando ese inodo. Siguiendo el ejemplo, si quisieramos leer todo el archivo <code>miarchivo.txt</code> (<code>cat miarchivo.txt</code>), el FS encuentra la entrada de directorio de ese archivo, lee que le corresponde el inodo 402, abre el inodo 402, mira que mide 5 bytes, busca cuál es el primer bloque de datos, lee los primeros 5 bytes de ese bloque de datos y se los devuelve a <code>cat</code>, que se encarga de imprimirlos por pantalla.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cat miarchivo.txt
</span><span class='line'>hola
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Hard links</h2>

<p>Ahora, ¿qué me impide tener otra entrada de directorio que apunte al inodo 402? En el inodo no hay ninguna referencia del estilo <code>directorioPadre</code> ni nada por el estilo. Tranquilamente podría crear una nueva entrada en ese directorio (o en otro, es indistinto<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>) que apunte al mismo inodo. Asumamos que creamos una entrada para el nombre <code>passwords.txt</code>, que también apunta al inodo 402.</p>

<p>¿Qué va a ocurrir cuando quiera leer el archivo <code>passwords.txt</code> haciendo <code>cat passwords.txt</code>? Esto:</p>

<blockquote><p>el FS encuentra la entrada de directorio de ese archivo, lee que le corresponde el inodo 402, abre el inodo 402, mira que mide 5 bytes, busca cuál es el primer bloque de datos, lee los primeros 5 bytes de ese bloque de datos y se los devuelve a `cat`, que se encarga de imprimirlos por pantalla.</p></blockquote>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cat passwords.txt
</span><span class='line'>hola
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Exactamente lo mismo que hace un rato, porque, a partir de que encontró que el inodo es el 402, el resto va todo igual: el inodo es lo que representa a nuestro archivo en el FS.</p>

<p>Y si quisiera agregarle contenido a <code>miarchivo.txt</code>, ¿qué pasaría? Ejecuto <code>echo clave123 &gt;&gt; miarchivo.txt</code>, y entonces el FS busca la entrada correspondiente a <code>miarchivo.txt</code>, encuentra que corresponde al inodo 402, va al inodo 402, ve que mide 5 bytes y que si le agrega los 9 bytes correspondientes a <code>clave123\n</code> sigue entrando en el primer bloque de datos, entonces abre el primer bloque de datos, y a partir del sexto byte escribe ese contenido. Por último, anota en el inodo que el archivo ahora pesa 14 bytes, cierra el archivo, y todos felices. Si ahora hacemos <code>cat miarchivo.txt</code>, encuentra la entrada de directorio<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>, abre el inodo 402, abre el bloque de datos, lee los 14 bytes, se los devuelve a <code>cat</code>, y <code>cat</code> los imprime por pantalla.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cat miarchivo.txt
</span><span class='line'>hola
</span><span class='line'>clave123
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>¿Y si ahora leo el contenido de <code>passwords.txt</code>? Bueno, <em>leo la entrada de directorio de <code>passwords.txt</code>, veo que es el inodo 402, abro el inodo, veo que mide 14 bytes, abro el primer bloque de datos, leo los 14 bytes, y se los devuelvo a <code>cat</code> para que los imprima en pantalla</em>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cat passwords.txt
</span><span class='line'>hola
</span><span class='line'>clave123
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Las dos entradas de directorio referencian al mismo archivo</strong>. Lo que <em>escribo en un archivo se ve reflejado en el otro</em>, pero porque <strong>es mentira que sean dos archivos</strong>: <em>son el mismo</em>. Son <em>dos referencias al mismo objeto</em>.</p>

<p>Ahora bien, podemos mirar por la consola que esos dos archivos referencian al mismo inodo. La clave está en el switch <code>-i</code> del comando <code>ls</code>, que acá vamos a usar junto con el <code>-1</code> para ver un archivo por línea:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -i1
</span><span class='line'>402 miarchivo.txt
</span><span class='line'>402 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ambas entradas referencian al inodo 402.</p>

<p><strong>Ese es el concepto de hard link</strong>: varias entradas de directorio referenciando al mismo inodo. <em>Varias referencias al mismo archivo</em>.</p>

<p>Pero es interesante que, a partir del momento en que se crea el hard link, ya no existe <em>el archivo</em> y <em>el hard link</em>: el archivo es el inodo, y todas las referencias a inodos son hardlinks. O sea, técnicamente hablando, <em>todas las entradas de directorios son hard links</em>, pero coloquialmente hablando nos referimos a hard links en el momento en que hay más de una entrada refiriendo a ese inodo. Pero es importante tener siempre presente que, a partir de que se crea el hard link (es decir, que se crea la segunda entrada apuntando al mismo inodo), ya no hay diferencia entre la referencia original y la nueva: podríamos borrar <code>miarchivo.txt</code>, y <code>passwords.txt</code> seguiría existiendo y apuntando al mismo contenido. Podríamos crear un tercer hard link, borrar los dos anteriores, y el inodo seguiría siendo el mismo, con el mismo contenido.</p>

<p>Y, ya que estamos, ¿qué pasa si borro un hard link? ¿Cómo se cuándo liberar el inodo y los bloques de datos? Para eliminar un archivo, siempre uso el mismo comando: <code>rm</code>. Y no tengo que especificarle yo si es el último hard link o no, o si liberar o no el inodo: es el FS el que decide eso.</p>

<p>Para eso, el FS usa una técnica llamada <a href="http://en.wikipedia.org/wiki/Reference_counting">reference counting</a><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> (conteo de referencias). El inodo tiene un campo en el que se cuenta la cantidad de referencias que hay hacia él en el file system. Al crear un archivo, ese contador arranca en 1 (porque hay una única entrada de directorio que lo apunta), cuando se crea un hard link se aumenta en 1, y cuando se elimina una entrada (<em>se elimina un hard link</em>) se decrementa en 1. Si ese contador llega a 0, el FS libera el inodo y los bloques de datos asociados. De este modo, en el caso de <code>miarchivo.txt</code>, el inodo 402 arrancó con el contador de links en 1, y cuando creamos el hard link <code>passwords.txt</code> pasó a 2. Si ahora borramos alguno de los dos (es indistinto cuál, digamos que hacemos <code>rm miarchivo.txt</code>), se borra la entrada de directorio correspondiente y se decrementa en uno el contador de links del inodo 402, pasando a 1. Si borramos el link que quedaba (<code>rm passwords.txt</code>), el contador de links del inodo 402 pasa a 0, y ahí el FS libera ese inodo y el bloque de datos asociado.</p>

<p>Podemos ver la cantidad de hard links usando <code>ls -l</code> (o combinarlo con <code>-i</code> para ver también el número de inodo):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 2
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Esos <code>2</code> que vemos entre los permisos y el owner del archivo es el contador de hard links. Creemos un archivo cualquiera para ver que tiene un único link:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>touch vacio
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 3
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'>406 -rw-r--r--+ 1 mgarcia staff 14 Feb 7 13:27 vacio
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Borremos tanto a <code>vacio</code> como a <code>miarchivo.txt</code> para ver que no les mentí<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rm miarchivo.txt vacio
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 1
</span><span class='line'>402 -rw-r--r--+ 1 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si borrara <code>passwords.txt</code>, recién ahí se liberaría el inodo 402.</p>

<p>Por último, un detalle de los hard links: toda la relación que existe entre la entrada de directorio y el inodo es el número de inodo. Debido a esto, los hard links sólo pueden realizarse <em>intra-filesystem</em>, es decir, el archivo destino y el directorio que contiene al nuevo link <strong>deben</strong> estar dentro del mismo file system<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>. Porque si no, ¿al inodo 402 de qué file system se refiere la entrada? ¿Qué garantías tengo de que el otro filesystem también maneje inodos? Por ese motivo, los hard links son intra-FS.</p>

<p>Y, algo que nos faltaba: ¿con qué creamos el hard link? Con el comando <code>ln</code>:</p>

<figure class='code'><figcaption><span>Esto es lo que ejecuté (hace un rato) para crear passwords.txt </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 1
</span><span class='line'>402 -rw-r--r--+ 1 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'><span class="nv">$ </span>ln miarchivo.txt passwords.txt
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 2
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Soft links</h2>

<p>Ahora bien, ¿ya está? Si quiero hacer un enlace a otro FS, ¿<a href="https://youtu.be/Pj1Hgw75V1w">estoy en el horno</a>? Nops: para eso hicieron los soft links :)</p>

<p>Un softlink<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> es un <strong>archivo nuevo</strong> que referencia a otra ruta. Creemos uno:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 2
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="nv">$ </span>ln -s miarchivo.txt blandito
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 3
</span><span class='line'>415 lrwxr-xr-x  1 mgarcia staff 14 Feb 7 13:46 blandito -&gt; miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Por lo pronto, para crear un soft link le pasamos el parámetro <code>-s</code> a <code>ln</code>. Por otro lado, vemos que se creó una nueva entrada de directorio llamada <code>blandito</code><sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>, <strong>que tiene su propio inodo</strong>. Es decir, es un archivo completamente separado de los otros. De hecho, tiene sus propios atributos: la <code>l</code> que vemos al principio es la que indica que ese archivo es un softlink. También vemos que el contador de links está en 1, porque, claro, este inodo (el 415) está referenciado únicamente por la entrada de directorio <code>blandito</code>.</p>

<p>Y, si es un inodo aparte, ¿cómo referencia al otro archivo? Bueno, el FS sabe que los archivos con el atributo de enlace (la <code>l</code> esa que vimos en los permisos) son softlinks, y entonces sabe que tiene que tratarlos de manera especial: cuando le pidan leerlo (<code>cat blandito</code>), no va a hacer lo que hacía siempre (abrir el inodo referenciado &ndash; 415 &ndash;, leer su contenido y pasárselo a <code>cat</code>). Por ser un softlink, el contenido que está guardado en el bloque de datos no es el contenido del archivo, si no <strong>la ruta del archivo al que enlaza</strong>. Entonces, al hacer <code>cat blandito</code> el FS abre el inodo 415, ve que es un softlink, lee el bloque de datos, ve que está guardada la ruta <code>miarchivo.txt</code>, y entonces, ahora sí, busca la entrada <code>miarchivo.txt</code>, abre el inodo correspondiente (el viejo y conocido 402), lee el bloque de datos, etc.</p>

<p>¿Se ve la diferencia? <strong>El contenido del softlink dice cuál es el path del archivo al que uno realmente quiere acceder.</strong> Esto es lo que le permite ser cross-FS: el link se puede hacer a, no se, <code>/mount/DVD/autorun.inf</code>, que sea otro FS, y no hay ningún problema: el identificador ya no es el número de inodo, y por eso puede ir a otros FS.</p>

<p>Del <code>ls</code> que hicimos después de crear el softlink tenemos que notar otro detalle: el link count del inodo 402 sigue en 2, <strong>no aumentó a 3</strong>. Esto significa que <strong>el archivo <em>apuntado</em> no se entera de que hay un softlink que lo enlaza</strong>.</p>

<p>El hecho de que el enlace esté hecho a nivel <em>ruta</em> (y no <em>inodo</em>) implica que puedo tener lo que se conoce como <em>enlaces rotos</em>: links que apuntan a archivos que no  existen [más]. Por ejemplo, ¿qué pasa si eliminamos <code>miarchivo.txt</code>? <code>blandito</code> sigue referenciando a un archivo llamado <code>miarchivo.txt</code>, pero ese archivo ya no existe, así que cualquier operación sobre el link va a fallar. No importa que siga existiendo <code>passwords.txt</code>, que sigue apuntando al inodo 402: el link funciona a nivel de paths. Lo mismo ocurre si renombro el archivo <code>miarchivo.txt</code>, o si pongo un archivo distinto llamado <code>miarchivo.txt</code>: el enlace apunta a <em>lo que sea que haya</em> en la ruta <code>miarchivo.txt</code>.</p>

<p>Existe un comando (más <em>low level</em><sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup> que <code>ls -l</code>) para leer el <em>destino</em> de un softlink: <code>readlink</code>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>readlink blandito
</span><span class='line'>miarchivo.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rompamos el enlace:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>mv miarchivo.txt archivo.txt
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 3
</span><span class='line'>415 lrwxr-xr-x  1 mgarcia staff 14 Feb 7 13:46 blandito -&gt; miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 archivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="nv">$ </span>cat blandito
</span><span class='line'>cat: blandito: No such file or directory
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s it :)</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Existen los enlaces en FAT, pero funcionan a otro nivel, me disgustan, me caen mal, y voy a ignorarlos rotundamente :)<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Por defecto, <code>echo</code> imprime un salto de línea, y por eso el <code>\n</code> al final del contenido. Se puede evitar el <code>\n</code> final haciendo <code>echo -n</code>.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Sólo importa que sea dentro del mismo filesystem, ya veremos por qué.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>A esta altura ya te habrás imaginado que tiene bastante sentido aplicar algúna técnica de caché para las entradas de directorios, porque <em>se usan bastante seguido</em>, je :)<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Como dice el artículo de Wikipedia, la misma idea de reference counting se usa mucho en los garbage collectors de muchos lenguajes de programación de objetos.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>Que no les mentí <em>tanto</em>. Estoy inventando un poco esos outputs de los comandos, porque no los estoy corriendo realmente en la consola. Hago pruebas y lo fabrico, pero debería ser consistente.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>Sí, en el sistema operativo se pueden (y de hecho, se suelen) montar más de un sistema de archivos. Cuando metés un CD en la máquina, estás montando otro FS. Cuando tenés más de una partición disponible, estás montando más de un sistema de archivos. Incluso cuando tenés una partición de swap, estás montando otro sistema de archivos.<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>&ldquo;softlink&rdquo;, &ldquo;soft link&rdquo;, &ldquo;enlace dinámico&rdquo;, &ldquo;enlace <em>suave</em>&rdquo;, <em>you name it</em><a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p>Lo de <code>-&gt; miarchivo.txt</code> es información que agrega <code>ls</code> para ser <em>más usable</em>, pero esa información <strong>no está guardada en la entrada de directorio</strong>.<a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
<li id="fn:10">
<p>En general, trato de usar los comandos de UNIX más <em>cercanos</em> a las llamadas al sistema. <code>ls</code> hace <em>muchas</em> cosas, no existe una llamada al sistema <code>ls</code>, pero sí existe una llamada al sistema <a href="http://linux.die.net/man/2/readlink">readlink</a> (o quizá no se llame así, pero cumple esa tarea específica).<a href="#fnref:10" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[int vs int32_t]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/int-vs-int32-t/"/>
    <updated>2014-12-26T20:05:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/int-vs-int32-t</id>
    <content type="html"><![CDATA[<p><em>Este post es un laburo en conjunto que hicimos con <a href="http://github.com/micaelaoriolo">Micaela Oriolo</a>. Kudos para ella :)</em></p>

<blockquote><p>No entiendo qué pito tocan los uint32. ¿Cuándo hay que usarlos sí o sí?</p></blockquote>


<p>En la vida real, todo puede explotar. Entre las miles de causas del típico “en casa compila”, se encuentra el uso (o no uso, mejor dicho) de los tipos de datos que especifican su tamaño. En este caso, vamos a hablar del tipo de dato <code>int</code>.<!--more--></p>

<p>La definición que el estándar de C da sobre el <code>int</code> es muy vaga:</p>

<blockquote><p>A ‘plain’ int object has the natural size suggested by the architecture of the execution environment (large enough to contain any value in the range INT_MIN to INT_MAX as defined in the header <limits.h></p><footer><strong>ISO/IEC 9899:TC3</strong> <cite><a href='http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf'>6.2.5 - Types, P33</a></cite></footer></blockquote>


<p>Lo que nos importa ahora de esta definición es que dice que el <code>int</code> tiene el tamaño sugerido por la arquitectura del entorno de ejecución. Esto significa que, en arquitecturas de 32 bits, el <code>int</code> suele medir 32 bits, mientras que en arquitecturas de 64 bits el <code>int</code> puede medir 32 o 64 bits.</p>

<p>A simple vista, esto puede parecer molesto, pero tiene sus razones, una de las cuales es que el hecho de que los datos estén <em>alineados a la palabra del procesador</em> hace que las operaciones a nivel CPU sean más ágiles.</p>

<p>Si en tu programa declarás todas las variables como <code>int32_t</code> y alguien compila ese programa para correr en un procesador de, por ejemplo, 16 bits, ese procesador no va a estar muy feliz, porque cada operación que haga con esos <code>int32_t</code> implica 2 lecturas, incluso si lo único que querías hacer con esa variable es un for de 1 a 10.</p>

<p><em>Entonces, ¿qué hago? ¿cuándo uso <code>int</code> y cuándo <code>int32_t</code>?</em></p>

<p>Si lo que querés guardar en tu variable es un número, entonces no va a haber ningún problema porque, justamente, por eso de que el dato está alineado, va a andar bien y rápido. Pero, hay veces en las que necesitás tener garantía del tamaño. Por ejemplo, cuando se trata de direcciones de memoria, pero también cuando querés serializar datos para mandarlos de una computadora a la otra. Si serializás el <code>int</code> copiando <code>sizeof(int)</code> bytes y mandándolos, no sabés cuánto es <code>sizeof(int)</code> en la otra máquina. Si no coinciden, ¡pum!.</p>

<p>Para <em>estos casos</em> aparecen los tipos de datos que especifican su tamaño. Podemos distinguir dos enfoques distintos:</p>

<ul>
<li>Los tipos de datos <em>nativos</em> tienen un nombre muy declarativo, que te dice “yo soy un carácter, yo soy un número chiquito, yo soy un número normal, yo soy un número grande”</li>
<li>Los tipos de datos que especifican su tamaño, están muy ligados a la implementación: “yo mido 16 bits, yo mido 32, yo mido 64”.</li>
</ul>


<p><em>Todo muy lindo, pero&hellip; ¿cuál es la relación entre todo esto y el intervalo de números que soporta cada tipo de dato?</em></p>

<p>Bueno, siempre depende del tamaño del tipo de dato. Sin importar cómo esté declarada la variable, si mide 32 bits se va a bancar 2<sup>32</sup> números distintos. De ahí que a veces puede pasar que el <code>long int</code> mida lo mismo que el <code>int</code>, y entonces el <code>long int</code> puede soportar el mismo intervalo que el <code>int</code>&hellip; lo cual no es muy feliz, pero <em>es lo que hay</em>.</p>

<p>Una buena práctica de programación es asegurar la portabilidad de tu programa, es decir, que sea lo más independiente de la arquitectura posible, para que pueda correrse en muchas máquinas distintas. Entonces, no sería una mala idea poner en práctica el criterio y empezar a decidir cuándo sería conveniente usar <code>int</code> o cuándo es mejor <code>int32_t</code> (a.k.a. “Acá pongo <code>int32_t</code> porque sí.”)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiladores Y Errores]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/compiladores-y-errores/"/>
    <updated>2014-12-26T19:17:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/compiladores-y-errores</id>
    <content type="html"><![CDATA[<p>Hace un tiempo me llegó la siguiente consulta por mail:</p>

<blockquote><p>Cuando trato de correr un proceso por consola me tira un mensaje &#8220;violacion de segmento&#8221; (&#8216;core&#8217; generado). Como mi proceso compilaba correctamente, no me tira errores, me resultaba extraño que me tire en tiempo de ejecución ese error.</p><p>Mi pregunta es, ¿puede ser que los errores del segmentation fault no me los alerte en tiempo de compilacion?</p></blockquote>


<!--more-->


<p>¡Claro que el programa puede fallar incluso cuando no tiene problemas de compilación! El software fallaría mucho menos si lo único que necesitáramos es que el compilador reporte cero errores. Pero hay montones de cosas que afectan la ejecución de un programa, y que exceden por completo las capacidades del compilador, y por eso el compilador <strong>no puede</strong> reportarlas.</p>

<p>Un error del compilador significa que el código es sintácticamente inválido, al punto de que el compilador no puede traducir tu texto a código de máquina. Pero entre código válido y código funcional hay un tremendo salto, y entre código válido y código sin errores, puff.</p>

<p>Pero además de &ldquo;detectar código mal formado&rdquo;, el compilador tiene los warnings, que son avisos de cosas que probablemente estés haciendo mal. Un programa con warnings compila y puede ejecutarse, pero existe una gran probabilidad de que haya errores lógicos que hagan que funcione de modo inesperado.</p>

<p>Y hasta ahí puede llegar el compilador. Pero hay montones de errores que el compilador no puede detectar, por lo que no es una gran garantía la compilación.</p>

<p>Por esto es que hace años que se viene laburando un montón en crear cosas como los tests, las buenas prácticas, los patrones de diseño, la delegación y encapsulamiento como medios para reutilizar código, la abstracción, etc.
TL;DR: es muuuuuuuy difícil garantizar la ausencia de errores en el software, al punto de que es inviable para cualquier programa más o menos útil.</p>

<p>Así que hay que aprender a bailar con eso.</p>

<p>Segmentation fault, en particular, es un error en tiempo de ejecución, que indica un acceso inválido a memoria.</p>

<p>Lo mejor que podés hacer cuando tenés un problema de memoria en tu código es usar <a href="http://valgrind.org/docs/manual/quick-start.html"><code>valgrind</code></a>. Es una herramienta con la que ejecutar tu programa, y que lleva una especie de <em>contabilidad</em> de cómo estas usando la memoria. Cuando tu programa usa erróneamente la memoria (sea un error evitable o uno abortivo), <code>valgrind</code> te informa en qué línea de código intentaste acceder a qué parte de la memoria, y si puede te dice cerca de qué zonas de memoria válidas fue tu acceso (para, por ejemplo, darte cuenta de que estás tratando de escribir un byte de más porque te faltó reservar el espacio para el <code>\0</code> de un string, ponele).</p>

<p>Buscá en <a href="http://utn.so/">el blog de la materia</a> que en la parte de <a href="http://www.utn.so/recursos/">recursos</a> hay <a href="http://faq.utn.so/valgrind">un documento que ayuda a entender los reportes de valgrind</a>. El 90% de los problemas los podés atacar con eso.</p>

<p>Además, hay <a href="https://www.youtube.com/watch?v=-CI4MexyU3I">un vídeo en que explico cómo poder inspeccionar con eclipse un proceso que falló</a>, para poder ver el estado de las variables al momento del fallo. Eso ayuda bastante a ver por qué te ocurrió el problema que reporta valgrind cuando no son tan evidentes las causas.</p>

<p>En cuanto a los pseudo ejemplos de código que me pasas, no te olvides que hay una enorme diferencia entre <code>t_estructura</code> y <code>t_estructura *</code>. Una cosa es la estructura (un conjunto de bytes con los datos que estás modelando) y otra es el puntero (unos pocos bytes con la dirección de memoria en que uno espera encontrar la estructura con los datos del modelo).</p>

<p>No te olvides, tampoco, del scope de las variables en tu programa. Las variables locales, almacenadas en el stack (tal como en el TP), sólo viven hasta que finaliza la ejecución de la función en que son declaradas. Si tu función que crea la estructura lo hace en una variable local, al retornar de esa función la memoria en que se almacenó la estructura deja de estar reservada, y puede ser sobreescrita. Entonces puede que tu programa pinche por eso, también.</p>

<p>Y por esto usamos <code>malloc()</code>: reservamos memoria en el heap, que nosotros decidiremos cuándo liberar, pudiendo &ldquo;sobrevivir&rdquo; a la función que la reservó.</p>

<p>Como &ldquo;moraleja&rdquo; número 2 del mail, recorda lo que dijimos en las charlas sobre usar las herramientas adecuadamente.</p>

<p>No le escapes a <code>malloc()</code>. Hay motivos para que exista, y yo te prometo que es desproporcionadamente más fácil aprender a usar <code>malloc</code> y gestionar bien la memoria que aprobar un TP de Operativos sin aprenderlo (asumiendo que eso sea posible). Aprovecha, además, que el TP este tiene bastante que ver con la gestión de memoria, y debería aportar en ese sentido.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un tutorial rápido para implementar y debuggear malloc, free, calloc y realloc]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/"/>
    <updated>2014-12-26T00:29:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc</id>
    <content type="html"><![CDATA[<p><em>Este post es mi traducción del post <a href="http://danluu.com/malloc-tutorial/">A Quick Tutorial on Implementing and Debugging Malloc, Free, Calloc, and Realloc</a> de <a href="https://twitter.com/danluu">Dan Luu</a>. Cualquier error o sugerencia sobre la traducción es bienvenida, y si querés que haga de intermediario para sugerirle cambios de contenido a él, también vale.</em></p>

<p>¡Implementemos nuestro propio <a href="http://man7.org/linux/man-pages/man3/malloc.3.html"><code>malloc</code></a> y veamos cómo funciona con programas pre-existentes!</p>

<p>Este tutorial asume que sabés qué es un puntero, y que <code>*ptr</code> dereferencia un puntero, y que <code>ptr-&gt;foo</code> significa <code>(*ptr).foo</code>, que <code>malloc</code> se usa para <a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/">reservar (<em>allocar</em>) espacio dinámicamente</a>, y que te es familiar el concepto de lista enlazada. Si decidís seguir este tutorial sin tener un claro conocimiento de C, contame qué partes convendría explicar un poco más. Si querés mirar todo el código de una, está disponible <a href="https://github.com/danluu/malloc-tutorial/blob/master/malloc.c">acá</a>.<!--more--></p>

<p>Presentaciones aparte, la firma de <code>malloc</code> es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Recibe un número de bytes y devuelve un puntero a un bloque de memoria de ese tamaño.</p>

<p>Hay varias formas de implementar esto. Nosotros vamos a elegir arbitrariamente utilizar la llamada al sistema <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html"><code>sbrk</code></a>. El sistema operativo reserva espacios de stack (<em>pila</em>) y heap (<em>montículo</em>) para los procesos, y <code>sbrk</code> nos permite manipular el heap. <code>sbrk(0)</code> devuelve un puntero al tope del heap. <code>sbrk(foo)</code> incrementa el tamaño del heap en <code>foo</code> bytes y devuelve un puntero al tope previo.</p>

<p><img src="http://danluu.com/images/malloc-tutorial/heap.png" alt="Diagrama del esquema de memoria de Linux, cortesía de Gustavo Duarte" /></p>

<p>Si queremos implementar un <code>malloc</code> realmente simple, podemos hacer algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;assert.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// sbrk failed.</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">request</span><span class="p">);</span> <span class="c1">// Not thread safe.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cuando un programa le pide espacio a <code>malloc</code>, éste se lo pide a <code>sbrk</code> para incrementar el tamaño del heap, y devuelve un puntero al inicio de la nueva región en el heap. Esta implementación falla en un tecnisismo, dado que <code>malloc(0)</code> debería devolver <code>NULL</code> u otro puntero que se le pueda pasar a <code>free</code> sin romper todo, pero básicamente funciona.</p>

<p>Pero, hablando de <code>free</code>&hellip; ¿Cómo funciona? Su prototipo es</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cuando le pasan a <code>free</code> un puntero que había sido devuelto por <code>malloc</code> debe liberar ese espacio. Pero si nos dan un puntero a algo reservado por nuestro <code>malloc</code>, no tenemos idea de cuál es el tamaño de ese bloque. ¿Dónde almacenamos eso? Si tuviéramos un <code>malloc</code> funcionando, podríamos <code>malloc</code>ear algo de espacio y guardarlo ahí, pero vamos a meternos en muchos problemas si necesitamos llamar a <code>malloc</code> para reservar espacio cada vez que llamamos a <code>malloc</code> para reservar espacio :)</p>

<p>Un truco común para evitar este problema es guardar meta-información sobre la región de memoria en el espacio previo al puntero que devolvemos. Supongamos que el tope del heap actual está en <code>0x1000</code> y pedimos <code>0x400</code> bytes. Nuestro <code>malloc</code> actual va a pedir <code>0x400</code> bytes a <code>sbrk</code> y devolver un puntero a <code>0x1000</code>. Si, en cambio, guardáramos, digamos, <code>0x10</code> bytes para almacenar información sobre el propio bloque, nuestro <code>malloc</code> pediría <code>0x410</code> bytes a <code>sbrk</code> y devolvería un puntero a <code>0x1010</code>, escondiendo nuestro bloque de <code>0x10</code> bytes de meta-información del código que está llamando a <code>malloc</code>.</p>

<p>Eso nos permite liberar un bloque, pero&hellip; ¿y ahora? Esa región de heap que nos da el SO tiene que ser contigua, entonces no podemos devolverle al SO un pedacito de memoria que esté en el medio. Incluso si quisiéramos copiar todos los datos que están después de la región liberada hacia adelante para rellenar el hueco, cosa de poder liberar el pedazo final del heap, no tenemos forma de actualizar todos los punteros que haya hacia esa zona de memoria a lo largo de todo nuestro programa.</p>

<p>En cambio, podemos marcar que esos bloques fueron liberados sin devolvérselos al SO, y en invocaciones futuras de <code>malloc</code> podríamos reusar esos bloques. Pero para hacer eso necesitamos poder acceder a la meta-información de cada bloque. Hay varias formas de hacerlo, nosotros vamos a elegir arbitrariamente hacerlo con una lista simplemente enlazada por cuestión de simplicidad.</p>

<p>Entonces, para cada bloque, queremos tener algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span> <span class="c1">// For debugging only. TODO: remove this in non-debug mode.</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define META_SIZE sizeof(struct block_meta)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Necesitamos saber el tamaño del bloque, si está o no libre, y cuál es el bloque siguiente. Hay también un número mágico ahí (el campo <code>magic</code>) para ayudarnos a debuggear, pero no es realmente necesario. Le vamos a asignar valores arbitrarios que nos van a permitir saber qué parte del código fue la última en modificar esa estructura.</p>

<p>También necesitamos un inicio para nuestra lista enlazada:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">global_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para nuestro <code>malloc</code>, queremos reusar el espacio libre si fuera posible, _alloc_ando espacio sólo cuando no podemos reusar el que ya tenemos. Dado que tenemos esta estructura de lista enlazada, buscar un bloque libre y devolverlo es casi trivial. Cuando tenemos un pedido de algún tamaño, iteramos nuestra lista buscando algún bloque libre con tamaño suficiente.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">find_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">**</span><span class="n">last</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">global_base</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
</span><span class='line'>    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si no encontramos un bloque que nos sirva, le tenemos que pedir ese espacio al SO usando <code>sbrk</code> y lo agregamos al final de nuestra lista.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">request_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">last</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">META_SIZE</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">block</span> <span class="o">==</span> <span class="n">request</span><span class="p">);</span> <span class="c1">// Not thread safe.</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// sbrk failed.</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// NULL on first request.</span>
</span><span class='line'>    <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como en nuestra implementación original, pedimos espacio usando <code>sbrk</code>, pero ahora le pedimos un poquito más de espacio para poder almacenar nuestra estructura, y además inicializamos los campos correctamente.</p>

<p>Ahora que tenemos las funciones auxiliares para ver si tenemos espacio libre y para pedirlo, nuestro <code>malloc</code> es simple. Si nuestro puntero base global es <code>NULL</code>, tenemos que pedir espacio y apuntar nuestro puntero base a ese nuevo bloque. Si no es <code>NULL</code>, buscamos si podemos reusar el espacio existente. Si podemos, lo hacemos, y si no pedimos espacio nuevo y lo usamos.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// TODO: align size?</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_base</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// First call.</span>
</span><span class='line'>    <span class="n">block</span> <span class="o">=</span> <span class="n">request_space</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">global_base</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">global_base</span><span class="p">;</span>
</span><span class='line'>    <span class="n">block</span> <span class="o">=</span> <span class="n">find_free_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Failed to find free block.</span>
</span><span class='line'>      <span class="n">block</span> <span class="o">=</span> <span class="n">request_space</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>      <span class="c1">// Found free block</span>
</span><span class='line'>      <span class="c1">// TODO: consider splitting block here.</span>
</span><span class='line'>      <span class="n">block</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>      <span class="n">block</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x77777777</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span><span class="p">(</span><span class="n">block</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para quienes no se lleven mucho con C, devolvemos <code>block+1</code> porque queremos devolver un puntero a la región siguiente a <code>block_meta</code>. Dado que <code>block</code> es un puntero del tipo <code>struct block_meta</code>, hacerle <code>+1</code> incrementa la dirección en <code>sizeof(struct block_meta)</code> bytes.</p>

<p>Si sólo quisiéramos un <code>malloc</code> sin un <code>free</code>, podríamos haber usado nuestro <code>malloc</code> original, mucho más simple. Entonces, ¡escribamos nuestro <code>free</code>! Lo principal que <code>free</code> tiene que hacer es setear el campo <code>-&gt;free</code>.</p>

<p>Como vamos a necesitar obtener la dirección de nuestro struct en varios lugares de nuestro código, definamos una función para ello:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">get_block_ptr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ahora que lo tenemos, este es <code>free</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// TODO: consider merging blocks once splitting blocks is implemented.</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">block_ptr</span> <span class="o">=</span> <span class="n">get_block_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="mh">0x77777777</span> <span class="o">||</span> <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="mh">0x12345678</span><span class="p">);</span>
</span><span class='line'>  <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x55555555</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Además de asignar <code>-&gt;free</code>, es válido llamar a <code>free</code> con un puntero <code>NULL</code>, y por eso chequeamos por <code>NULL</code>. Como <code>free</code> no debería llamarse con cualquier dirección arbitraria o bloques que ya hayan sido liberados, <code>assert</code>eamos que esas cosas no pasen.</p>

<p>En realidad no es necesario <code>assert</code>ear nada, pero suele ayudar a debuggear. De hecho, cuando escribí este código tuve un bug que hubiera resultado en corromper silenciosamente los datos si los asserts no hubieran estado ahí. En cambio, el código falló por los <code>assert</code>s, y debuggear el problema se volvió trivial.</p>

<p>Ahora que tenemos <code>malloc</code> y <code>free</code>, ¡podemos escribir programas usando nuestro propio gestor de memoria! Pero antes de meter nuestro gestor en programas ya existentes, necesitamos implementar un par de funciones comunes más: <code>realloc</code> y <code>calloc</code>. <code>calloc</code> es simplemente un <code>malloc</code> que inicializa la memoria en 0, así que arranquemos por <code>realloc</code>. <code>realloc</code> debería ajustar el tamaño de un bloque de memoria que obtuvimos a través de <code>malloc</code>, <code>calloc</code> o <code>realloc</code>.</p>

<p>El prototipo de <code>realloc</code> es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si le pasamos un puntero a <code>NULL</code>, debería funcionar exactamente igual que <code>malloc</code>. Si le pasamos un puntero previamente <code>malloc</code>eado, debería liberar espacio si el tamaño es menor al previo, y asignar más espacio y copiar los datos existentes si el tamaño es mayor que el anterior.</p>

<p>Los programas pueden seguir funcionando si no hiciéramos lo de achicar el bloque o liberarlo, pero sí necesitamos reservar más espacio cuando el tamaño se incrementa, así que empecemos con eso:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// NULL ptr. realloc should act like malloc.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">block_ptr</span> <span class="o">=</span> <span class="n">get_block_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// We have enough space. Could free some once we implement split.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Need to really realloc. Malloc new space and free old space.</span>
</span><span class='line'>  <span class="c1">// Then copy old data to new space.</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">new_ptr</span><span class="p">;</span>
</span><span class='line'>  <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// TODO: set errno on failure.</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">memcpy</span><span class="p">(</span><span class="n">new_ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">new_ptr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y ahora <code>calloc</code>, que simplemente inicializa la memoria antes de devolver el puntero:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nelem</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">elsize</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nelem</span> <span class="o">*</span> <span class="n">elsize</span><span class="p">;</span> <span class="c1">// TODO: check for overflow.</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notemos que no chequea overflows en <code>nelem * elsize</code>, requerido por la especificación. Todo este código es simplemente lo mínimo necesario para que las cosas más o menos funcionen.</p>

<p>Y ahora que tenemos algo que más o menos funciona, usémoslo con los programas ya existentes (¡sin siquiera recompilarlos!).</p>

<p>Primero que nada, necesitamos compilar nuestro código. En Linux, algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>clang -O0 -g -W -Wall -Wextra -shared -fPIC malloc.c -o malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>debería funcionar.</p>

<p><code>-g</code> agrega los símbolos de debug, para poder mirar nuestro código con <code>gdb</code> o <code>lldb</code>. <code>-O0</code> va a ayudar a debuggear, evitando que en las optimizaciones se eliminen variables. <code>-W -Wall -Wextra</code> agrega warnings adicionales. <code>-shared -fPIC</code> nos permite linkear nuestro código dinámicamente, que es lo que nos permite <a href="http://jvns.ca/blog/2014/11/27/ld-preload-is-super-fun-and-easy/">usar nuestro código con binarios ya existentes</a>.</p>

<p>En Mac usaríamos algo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>clang -O0 -g -W -Wall -Wextra -dynamiclib malloc.c -o malloc.dylib
</span></code></pre></td></tr></table></div></figure>


<p>Notar que <code>sbrk</code> fue deprecado en las versiones recientes de OS X. Apple usa una definición poco ortodoxa de <em>deprecado</em> &ndash; algunas llamadas al sistema deprecadas directamente fallan. No probé esto en una Mac, así que puede que la implementación tenga fallas, o directamente no funcione en Mac.</p>

<p>Ahora, para que un binario use nuestro <code>malloc</code> en Linux, tenemos que setear la variable de entorno <code>LD_PRELOAD</code>. Si estás usando <code>bash</code>, podés hacerlo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">LD_PRELOAD</span><span class="o">=</span>/path/absoluto/a/malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>Si estás en Mac, el comando es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">DYLD_INSERT_LIBRARIES</span><span class="o">=</span>/path/absoluto/a/malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>Si todo funciona, podés correr cualquier binario arbitrario y debería funcionar normalmente (excepto que será un poquito más lento).</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>Makefile  malloc.c  malloc.so  README.md  <span class="nb">test  test</span>-0  <span class="nb">test</span>-1  <span class="nb">test</span>-2  <span class="nb">test</span>-3  <span class="nb">test</span>-4
</span></code></pre></td></tr></table></div></figure>


<p>Si hubiera un bug, vas a ver algo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Debuggeando</h3>

<p>¡Hablemos de debugear! Si te es familiar el uso del debugger para poner breakpoints, inspeccionar la memoria y ejecutar paso a paso el código, podés saltear esta sección e ir directamente a <a href="#ejercicios">los ejercicios</a>.</p>

<p>Esta sección asume que podés instalar <code>gdb</code> en tu sistema. Si estás en Mac, probablemente quieras usar <code>lldb</code> y traducir los comandos apropiadamente. Como no tengo idea de qué bugs podés encontrarte, voy a introducir algunos bugs en el código para mostrarte cómo encontrarlos y resolverlos.</p>

<p>Primero, necesito poder correr <code>gdb</code> sin que genere un segmentation fault. Si <code>ls</code> <em>segfaultea</em> y tratamos de correr <code>gdb ls</code>, muy probablemente <code>gdb</code> vaya a segfaultear también. Podríamos escribir un wrapper para hacer esto, pero <code>gdb</code> también lo soporta. Si iniciamos <code>gdb</code> y después corremos <code>set environment LD_PRELOAD=./malloc.so</code> antes de correr el programa, <code>LD_PRELOAD</code> va a funcionar normalmente.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>0x00007ffff7bd7dbd in free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x0<span class="o">)</span> at malloc.c:113
</span><span class='line'>113       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span></code></pre></td></tr></table></div></figure>


<p>Como esperábamos, tenemos un segfault. Podemos usar <code>list</code> para ver el código alrededor del error:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> list
</span><span class='line'>108     <span class="o">}</span>
</span><span class='line'>109
</span><span class='line'>110     void free<span class="o">(</span>void *ptr<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>111       // TODO: consider merging blocks once splitting blocks is implemented.
</span><span class='line'>112       struct block_meta* <span class="nv">block_ptr</span> <span class="o">=</span> get_block_ptr<span class="o">(</span>ptr<span class="o">)</span>;
</span><span class='line'>113       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span><span class='line'>114       assert<span class="o">(</span>block_ptr-&gt;magic <span class="o">==</span> 0x77777777 <span class="o">||</span> block_ptr-&gt;magic <span class="o">==</span> 0x12345678<span class="o">)</span>;
</span><span class='line'>115       block_ptr-&gt;free <span class="o">=</span> 1;
</span><span class='line'>116       block_ptr-&gt;magic <span class="o">=</span> 0x55555555;
</span><span class='line'>117     <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y podemos usar <code>p</code> (<em>print</em>) para ver qué está pasando con las variables:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p ptr
</span><span class='line'><span class="nv">$6</span> <span class="o">=</span> <span class="o">(</span>void *<span class="o">)</span> 0x0
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p block_ptr
</span><span class='line'><span class="nv">$7</span> <span class="o">=</span> <span class="o">(</span>struct block_meta *<span class="o">)</span> 0xffffffffffffffe8
</span></code></pre></td></tr></table></div></figure>


<p><code>ptr</code> vale <code>0</code>, o sea, <code>NULL</code>, y esa es la causa del problema: nos olvidamos de chequear por <code>NULL</code>.</p>

<p>Ahora que encontramos eso, probemos con un bug un poco más complicado. Digamos que decidimos reemplazar nuestra estructura por:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>    <span class="c1">// For debugging only. TODO: remove this in non-debug mode.</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y devolver <code>block-&gt;data</code> en lugar de <code>block+1</code> en <code>malloc</code>, sin más cambios. Se parece bastante a lo que veníamos haciendo, sólo que ahora definimos un campo más que apunta al final de la estructura, y retornamos un puntero ahí.</p>

<p>Pero esto es lo que pasa si usamos nuestro nuevo <code>malloc</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/bin/ls
</span><span class='line'>Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>
</span><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run
</span><span class='line'>
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>_IO_vfprintf_internal <span class="o">(</span><span class="nv">s</span><span class="o">=</span>s@entry<span class="o">=</span>0x7fffff7ff5f0, <span class="nv">format</span><span class="o">=</span>format@entry<span class="o">=</span>0x7ffff7567370 <span class="s2">&quot;%s%s%s:%u: %s%sAssertion     `%s&#39; failed.\n%n&quot;</span>, <span class="nv">ap</span><span class="o">=</span>ap@entry<span class="o">=</span>0x7fffff7ff718<span class="o">)</span> at vfprintf.c:1332
</span><span class='line'>1332    vfprintf.c: No such file or directory.
</span><span class='line'>1327    in vfprintf.c
</span></code></pre></td></tr></table></div></figure>


<p>Este no es tan lindo como el error anterior &ndash; podemos ver que uno de nuestros <code>assert</code>s falló, pero <code>gdb</code> nos deja tirados dentro de una función de <code>printf</code>, llamada cuando un <code>assert</code> falla. Pero esa función usa nuestro <code>malloc</code> buggeado ¡y revienta!</p>

<p>Lo que podemos hacer es inspeccionar <code>ap</code> para ver qué era lo que <code>assert</code> trataba de imprimir:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p *ap
</span><span class='line'><span class="nv">$4</span> <span class="o">=</span> <span class="o">{</span><span class="nv">gp_offset</span> <span class="o">=</span> 16, <span class="nv">fp_offset</span> <span class="o">=</span> 48, <span class="nv">overflow_arg_area</span> <span class="o">=</span> 0x7fffff7ff7f0, <span class="nv">reg_save_area</span> <span class="o">=</span> 0x7fffff7ff730<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Eso funcionaría bien. Podemos jugar un poquito hasta encontrar qué es lo que pretendía imprimir, y encontrar el error de ese modo. Otras formas hubieran sido implementar nuestro propio <code>assert</code> o usar los <em>hooks</em> correctos para prevenir que <code>assert</code> use nuestro <code>malloc</code>.</p>

<p>Pero, en este caso, nosotros sabemos que hay sólo unos pocos <code>assert</code>s en nuestro código: el de <code>malloc</code>, garantizando que no estemos usandolo en un programa multihilo, y los dos de <code>free</code> chequeando que no estemos liberando algo que no debiéramos. Miremos primero <code>free</code>, poniendo un <em>breakpoint</em>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>free
</span><span class='line'>Breakpoint 1 at 0x400530
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run /bin/ls
</span><span class='line'>
</span><span class='line'>Breakpoint 1, free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x61c270<span class="o">)</span> at malloc.c:112
</span><span class='line'>112       <span class="k">if</span> <span class="o">(</span>!ptr<span class="o">)</span> <span class="o">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>Aún no asignamos <code>block_ptr</code>, pero si hacemos <code>s</code> un par de veces para avanzar hasta después de que fuera asignado, podemos ver que su valor es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'>free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x61c270<span class="o">)</span> at malloc.c:118
</span><span class='line'>118       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *block_ptr
</span><span class='line'><span class="nv">$11</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0, <span class="nv">next</span> <span class="o">=</span> 0x78, <span class="nv">free</span> <span class="o">=</span> 0, <span class="nv">magic</span> <span class="o">=</span> 0, <span class="nv">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Estoy usando <code>p/x</code> en vez de <code>p</code> para poder verlo en hexadecimal. El campo <code>magic</code> está en 0, que debería ser imposible para una estructura válida para liberar. ¿Puede que <code>get_block_ptr</code> esté devolviendo un offset incorrecto? Tenemos <code>ptr</code> disponible, así que podemos inspeccionar distintos offsets. Dado que es un <code>void *</code>, vamos a tener que castearlo para que <code>gdb</code> sepa cómo interpretar los resultados:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p sizeof<span class="o">(</span>struct block_meta<span class="o">)</span>
</span><span class='line'><span class="nv">$12</span> <span class="o">=</span> 32
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-32<span class="o">)</span>
</span><span class='line'><span class="nv">$13</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x0, <span class="nv">next</span> <span class="o">=</span> 0x78, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x0, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x0<span class="o">}}</span>
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-28<span class="o">)</span>
</span><span class='line'><span class="nv">$14</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x7800000000, <span class="nv">next</span> <span class="o">=</span> 0x0, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x0, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x78<span class="o">}}</span>
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-24<span class="o">)</span>
</span><span class='line'><span class="nv">$15</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x78, <span class="nv">next</span> <span class="o">=</span> 0x0, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x12345678, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x6e<span class="o">}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si miramos un poco la dirección que estamos usando, podemos ver que el offset correcto es 24 y no 32. Lo que está pasando es que la estructura tiene <em>padding</em>, es decir, está siendo alineada al tamaño de palabra del procesador. Entonces, <code>sizeof(struct block_meta)</code> es 32, incluso aunque el último campo válido esté en 24. Si queremos remover ese espacio extra, tenemos que arreglar <code>get_block_ptr</code>.</p>

<p>¡Y eso fue todo el debugging!</p>

<h3><a name="ejercicios">Ejercicios</a></h3>

<p>Personalmente, estas cosas no me quedan hasta que no hago un par de ejercicios, así que voy a dejar algunos acá para quienes les interese.</p>

<ol>
<li>Se espera que <code>malloc</code> devuelva un puntero <em>convenientemente alineado a cualquier tipo nativo</em>. ¿Hace eso el nuestro? Si lo hace, ¿por qué? Si no, corregilo. Notá que &ldquo;cualquier tipo nativo&rdquo; es, básicamente, 8 bytes en C, dado que los tipos de SSE/AVX no son nativos.</li>
<li>Nuestro <code>malloc</code> desperdicia un montón de espacio si reusamos un bloque sin necesitar <em>tanto</em> tamaño. Implementá una función que lo divida en bloques que ocupen el espacio mínimo necesario.</li>
<li>Después de hacer <code>2</code>, si llamamos a <code>malloc</code> y <code>free</code> muchas veces con tamaños aleatorios, terminaremos con un montón de bloques pequeños que sólo se pueden reusar si pedimos cantidades pequeñas de memoria. Implementá un mecanismo que una bloques libres adyacentes para que varios bloques consecutivos se unan en uno solo.</li>
<li>¡Encontrá bugs en el código existente! No lo testeé demasiado, así que <em>tienen que</em> haber bugs, por más que esto más o menos funcione.</li>
</ol>


<h2>Parte 2 en adelante</h2>

<p>A continuación vamos a ver cómo hacer que esto sea más rápido y que sea <em>thread safe</em>.</p>

<h3>Recursos</h3>

<p>Leí <a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf">este tutorial</a> de Marwan Burelle antes de sentarme a escribir mi propia implementación, así que se parece bastante. Las principales diferencias son que mi versión es más simple, pero más vulnerable a la fragmentación de memoria. En términos de exposición, mi estilo es bastante más informal. Si querés algo más formal, el Dr. Burelle es tu camino a seguir.</p>

<p>Para saber más sobre cómo Linux maneja la memoria, mirá <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">este post</a> de Gustavo Duarte.</p>

<p>Para saber más sobre cómo funcionan las implementaciones reales de <code>malloc</code>, <a href="http://g.oswego.edu/dl/html/malloc.html">dlmalloc</a> y <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">tcmalloc</a> son dos grandes lecturas. No leí el código de <a href="http://www.canonware.com/jemalloc/">jemalloc</a>, y escuché que es un poco más difícil de entender, pero es una de las implementaciónes de [malloc] de alta performance más usadas que hay.</p>

<p>Para ayuda debuggeando, <a href="https://code.google.com/p/address-sanitizer/wiki/AddressSanitizer">Address Sanitizer</a> la rompe. Y si querés escribir una versión thread-safe, <a href="https://code.google.com/p/data-race-test/wiki/ThreadSanitizer">Thread Sanitizer</a> también es una gran herramienta.</p>

<h3>Agradecimientos</h3>

<p>Gracias a Gustavo Duarte por permitirme usar una de sus imágenes para ilustrar <code>sbrk</code>, a Ian Whitlock y Danielle Sucher por encontrar algunos <em>typos</em>, a Nathan Kurz por sus sugerencias sobre los recursos adicionales, y a &ldquo;tedu&rdquo; por encontrar un bug. Por favor, <a href="https://twitter.com/danluu">avisame</a> si encontrás otros bugs en este post (tanto en el texto como en el código).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[P. Sherman, Calle Wallaby 42, Sydney]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/09/04/p-sherman-calle-wallaby-42-sydney/"/>
    <updated>2014-09-04T00:42:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/09/04/p-sherman-calle-wallaby-42-sydney</id>
    <content type="html"><![CDATA[<blockquote><p>Con algo de suerte, este será el primero de una serie de al menos 3 posts hablando sobre la gestión de la memoria en C. Sólo parece no aportar tanto, pero probablemente entre los 3 den un mensaje más o menos copado. Stay tuned :)</p></blockquote>


<p>Una de las complejidades más importantes asociadas a la programación en C es la gestión y el uso de la memoria.<!--more--></p>

<p>Para un programa C, la memoria de la computadora es poco más que un gran vector (<em>array</em>) de bytes consecutivos. Todos y cada uno de estos bytes tienen una dirección: un número que permite al programa identificar a cada byte unequívocamente. Las direcciones arrancan (como todo en C) por la dirección 0. Y, como suelen representarse en hexa, vamos a decir que el primer byte de memoria es el de la dirección <code>0x0</code>.</p>

<p>Es importante recordar que C trabaja con <em>punteros</em> (referencias a direcciones de memoria) <em>absolutos</em>, por lo que, en principio, el byte <code>0x0</code> no será necesariamente el primero de los que use nuestro programa para almacenar datos, sino el primero de la memoria de la computadora<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>Las direcciones son consecutivas, por lo que el byte siguiente al <code>0x0</code> será el <code>0x1</code>, <code>0x2</code>, y así siguiendo. Hablamos en hexa, así que el décimo byte será el <code>0x9</code>, pero el undécimo será <code>0xa</code>, y así.</p>

<p>Pero, en general, uno como programador no usa bytes de memoria, sino una abstracción un poquito por encima: las variables.</p>

<p>Al declarar una variable, le estamos indicando al compilador que reserve una determinada cantidad de bytes de memoria, según el tipo declarado, y además le asociamos un nombre a ese conjunto de bytes, de modo que podamos identificarlo y referirlo de modo más simple.</p>

<p>Es importante recalcar que el nombre de la variable sólo existe hasta la compilación: al ejecutar nuestro programa, todas las referencias a memoria se hacen a través de direcciones y tamaños<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>Entonces, así como la declaración <code>unsigned int nombre[10];</code> reserva (en una arquitectura de 32 bits) 40 bytes, la referencia <code>nombre[0]</code> habla de la misma dirección que <code>nombre</code> (por ejemplo, podría referir a <code>0x0842f5</code>), mientras que <code>nombre[2]</code> referirá a la dirección 8 bytes más grande, <code>0x0842fd</code>. Como el tipo de datos es <code>unsigned int</code>, de 32 bits, el compilador sabe cuántos bytes desplazarse para cada elemento (sabiendo, así, que <code>nombre[2]</code> está 8 bytes después de <code>nombre[0]</code>, y no 4, 2, 16 o cualquier otra cantidad), y cuántos bytes a partir de esa dirección tiene que leer para obtener el dato buscado.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>En particular, el byte <code>0x0</code> suele tener un significado muy especial en la mayoría de los sistemas operativos (<code>NULL</code> suele ser una referencia al <code>0x0</code>), por lo que en la inmensa mayoría de los casos el byte <code>0x0</code> <em>no va</em> a pertenecer a nuestro proceso.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Cuando indicamos compilar en modo debug, el compilador incluye en el programa final información extra (como los nombres de las variables y funciones) a fin de poder mostrar mensajes de error más apropiados que simplemente muchas direcciones de memoria, pero esta información <strong>NO ES REQUERIDA</strong> para la ejecución del programa.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[She bangs, she bangs...]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/03/20/she-bangs-she-bangs/"/>
    <updated>2014-03-20T19:33:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/03/20/she-bangs-she-bangs</id>
    <content type="html"><![CDATA[<p>Si alguna vez editaron un script UNIX, seguramente habrán visto que arrancan de manera similar: <code>#!/bin/sh</code>. Por algún motivo, esa línea mágica se llama <a href="0">Shebang</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<figure class='code'><figcaption><span>mi_script </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;¡Hola, mundo!&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Llamamos <code>mi_script</code> a este archivo.</p>

<p>Esa línea mágica es la responsable de que podamos correr un script ejecutando <code>./mi_script</code> en la consola.<!--more--> Como dijimos en <a href="tutorial-c/blog/2013/08/19/arrancando">el primer post</a>, para ejecutar un programa en UNIX, el programa tiene que tener permisos de ejecución<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, y luego tenemos que tipear su ruta completa en la consola:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>chmod +x mi_script
</span><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'>¡Hola, mundo!
</span></code></pre></td></tr></table></div></figure>


<p>Al hacerlo, el sistema operativo carga el programa en memoria y lo ejecuta.</p>

<p>El problema es que un script es texto. Los programas compilados tienen las instrucciones que nuestro procesador entiende, entonces es relativamente trivial ejecutarlo<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>. Un script tiene texto. Y, adivinaste: el procesador no ejecuta texto. Entonces, ¿qué es lo que ocurre? ¿Por qué y cómo funciona la ejecución de scripts?</p>

<p>La clave es el shebang. Cuando el sistema operativo detecta que lo que pretendemos ejecutar es un script (digamos, no es un programa en algún formato binario que el sistema operativo comprenda), busca en la primer línea para encontrar este shebang. Esa ruta que se encuentra después del <code>#!</code> (en nuestro caso anterior, <code>/bin/sh</code>) es la que va a ser ejecutada, pasándole como primer parámetro la ruta de nuestro script. Sí: en <code>/bin/sh</code> tenés que tener un programa ejecutable para que la ejecución del script funcione. Si, además, querés que se ejecute como corresponde, ese <code>/bin/sh</code> debería entender que cuando se lo ejecuta con un parámetro, ese parámetro representa una ruta a un archivo que contiene código en un lenguaje que ese programa sepa interpretar.</p>

<p>En general, esto ocurre: por convención, en los sistemas UNIX <code>/bin/sh</code> es una <a href="http://es.wikipedia.org/wiki/Bourne_Shell">Bourne Shell</a>, o alguna otra shell con el modo de compatibilidad activado. ¿Qué es una Bourne Shell? Un programa capaz de interpretar scripts escritos en ese lenguaje. Dado que los programas que se ponen en los shebangs tienen como objetivo <em>interpretar</em> scripts, se los llamó (muy originalmente) <em>intérpretes</em>.</p>

<p>¿Existen otros intérpretes? Claro que sí. <a href="https://www.python.org/">Python</a> es un lenguaje interpretado, y uno puede hacer scripts en Python y ejecutarlos en la consola, como <a href="https://github.com/chapuni/llvm-project/blob/bbf3f7262bd18fe1b140ba0db9ada8defa2c839f/klee/scripts/objdump">este</a>. Lo mismo pasa con Ruby, perl, y tantos otros lenguajes.</p>

<p>Ahora, como somos curiosos, podríamos ponernos a jugar con esto y abusar un poquito. ¿Qué pasa si usamos otro programa como intérprete? ¿Podemos usar cualquier programa? Podemos, sí, pero los resultados van a cambiar.</p>

<p>Editemos nuestro script. Modifiquemos únicamente el shebang, poniéndole como intérprete <code>/bin/cat</code>. <code>cat</code> es un programa que imprime <em>en pantalla</em> el contenido de la ruta que le pasamos por parámetro. ¿Qué va a pasar cuando volvamos a ejecutar nuestro script?</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'><span class="c">#!/bin/cat</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;¡Hola, mundo!&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Claro que sí. Al ejecutar nuestro script, el sistema operativo ejecutó <code>/bin/cat</code> pasándole la ruta a <code>mi_script</code> como parámetro. <code>cat</code>, como siempre, abrió la ruta que le pasaron por parámetro y mostró su contenido.</p>

<p>Sigamos jugando. Usemos otro programa: <code>echo</code>. Cambiemos el intérprete por <code>/bin/echo</code>, y ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'>./mi_script
</span></code></pre></td></tr></table></div></figure>


<p>Así es. <code>echo</code> imprime lo que sea que le pasemos como parámetro. Si lo que le pasamos es la ruta de nuestro script, como pasa con todas las ejecuciones de los scripts, <code>echo</code> va a imprimir eso mismo en la consola.</p>

<p>Otro intérprete &ldquo;loco&rdquo; que podemos poner es <code>rm</code>: <code>#!/bin/rm</code>. Ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'><span class="nv">$ </span>ls mi_script
</span><span class='line'>ls: mi_script: No such file or directory
</span></code></pre></td></tr></table></div></figure>


<p>Así es, lo borramos.</p>

<p>Entonces, hagamos una última prueba para jugar. Escribamos un programa que liste todos los parámetros con los que fue ejecutado:</p>

<figure class='code'><figcaption><span>interprete.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;  Parametro %d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Compilemos y ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc interprete.c -o interprete
</span><span class='line'><span class="nv">$ </span>./interprete
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'><span class="nv">$ </span>./interprete primerParametro segundo 3ro
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: primerParametro
</span><span class='line'>  Parametro 2: segundo
</span><span class='line'>  Parametro 3: 3ro
</span></code></pre></td></tr></table></div></figure>


<p>El primer parámetro de cualquier programa C es el propio programa. Ahora bien, pongámoslo como intérprete de nuestro script:</p>

<figure class='code'><figcaption><span>mi_script </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!./interprete</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;Este codigo nunca se ejecutara&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: ./mi_script
</span><span class='line'><span class="nv">$ </span>./mi_script primerParametro
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: ./mi_script
</span><span class='line'>  Parametro 2: primerParametro
</span></code></pre></td></tr></table></div></figure>


<p>Así es: se ejecuta el programa que pusimos en la shebang, y luego se le pasa todo lo que tipeemos en la consola. Y no sólo podemos poner un programa en el shebang, sino también parámetros:</p>

<figure class='code'><figcaption><span>mi_script </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!./interprete unParametroFijo</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;Este codigo nunca se ejecutara&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: unParametroFijo
</span><span class='line'>  Parametro 2: ./mi_script
</span><span class='line'><span class="nv">$ </span>./mi_script otroParametro
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: unParametroFijo
</span><span class='line'>  Parametro 2: ./mi_script
</span><span class='line'>  Parametro 3: otroParametro
</span></code></pre></td></tr></table></div></figure>


<p>Creo que no queda mucho más para agregar. <em>Espero que mis respuestas os haya iluminados :)</em></p>

<hr>


<p><strong>EDIT:</strong> Recordé que <strong>sí</strong> había algo más para agregar.</p>

<p>Muchas veces ví que podía escribir un script sin ponerle un shebang, y que de todos modos funcionaba. ¿Por qué? Bueno, porque de algún modo se defaultea. En <a href="http://stackoverflow.com/a/9945113/641451">Stackoverflow</a> dicen que se ejecuta con la misma shell que estás usando en ese momento, pero esto no es comportamiento estándar: la documentación de la syscall <a href="http://linux.die.net/man/2/execve"><code>execve</code></a> dice que un script <strong>tiene que</strong> comenzar con un shebang válido<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>. Conviene no dar nada por sentado y especificar el intérprete que queremos usar, asegurándonos así la compatibilidad y buen funcionamiento.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>El caracter <code>#</code> en inglés se llama &ldquo;hash&rdquo; (y supongo que se lo llamará, también, &ldquo;sha&rdquo;), y el <code>!</code> es el &ldquo;bang&rdquo;.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>¡Gracias, Victor, por la corrección!<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><em>trivial</em> es un decir. Ejecutar un programa no tiene nada de trivial, pero digamos que <em>la idea de cómo ejecutarlo</em> es relativamente sencilla, al menos respecto a interpretar un script.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Y, abajo de todo, en la documentación, muestra el código de un programa llamado <code>myecho</code> <em>MUUUUUUUY</em> similar a nuestro <code>interprete.c</code> :)<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Me dí cuenta que me tiraste la señal]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/"/>
    <updated>2013-12-31T00:27:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal</id>
    <content type="html"><![CDATA[<p>Uno de los mecanismos de <abbr title="Inter-Process Communication - Comunicación entre procesos">IPC</abbr> que nos provee Linux es el envío de señales. Es un modo de comunicación MUY minimalista: un proceso le envía una determinada señal a otro, y este último simplemente recibe el código asociado a la señal recibida.</p>

<p>Y nada más. No hay parámetros, no hay información del emisor, nada. Sólo un código.<!--more--></p>

<p>Y, aún así, es un método más que útil: para terminar un proceso en la terminal (cuando apretamos <kbd>CTRL+C</kbd>), para cerrar un programa que se colgó (desde algún administrador de tareas), para pausar la ejecución de un proceso o para cerrar un programa clickeando la <code>x</code> de cierre en su ventana &ndash; en todos estos casos estamos mandando una señal a un proceso.</p>

<p>Las señales tienen asociadas distintas acciones por defecto, que se ejecutarán cuando el proceso reciba cada señal. Por ejemplo, al recibir <code>SIGTERM</code> o <code>SIGKILL</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, el proceso finalizará con un código de salida no-exitoso, mientras que la señal <code>SIGUSR1</code> será ignorada (el proceso no hará nada al recibirla).</p>

<p>Lo interesante de las señales es que los procesos pueden especificar sus propias acciones a ejecutar cuando la señal es recibida, en lugar de ejecutar la acción por defecto. Dado que las señales se envían a los procesos<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, alguno de sus hilos se interrumpirá para pasar a ejecutar una función que nosotros determinemos cuando la señal llegue, tal como si en la línea de código que está ejecutándose al momento de recibir la señal invocara a la función determinada. Al concluir la ejecución de la función, el programa retornará al punto en que estaba antes del arribo de la señal, y todo seguirá su curso normalmente.</p>

<p>Por ser un mecanismo de IPC (es decir, involucra a más de un proceso), no hay otra opción: para que esto funcione, de algún modo <strong>debe</strong> intervenir el sistema operativo. Linux utiliza tres máscaras (bitmaps) para cada proceso, indicando qué señales deberán ignorarse, cuáles están bloqueadas (se encolan hasta ser desbloqueadas) y cuáles serán capturadas para ser atendidas por el proceso en lugar de aplicarles la acción por defecto.</p>

<p>Entonces, si el proceso tiene un manejador de señal definido, al recibir la señal el proceso bloqueará la recepción de esa señal, ejecutará la función correspondiente y, al finalizar, desbloqueará la señal. De este modo, se evita interrumpir la ejecución del manejador de la señal, para evitar conflictos con por sincronización (si el manejador lockea un mutex y se interrumpe con una nueva ejecución de si mismo antes de liberarlo, estaríamos en presencia de un auto-deadlock <code>:)</code>).</p>

<p>El problema que inspiró este post viene con el uso de <code>exec*</code>. <code>execve</code> es una llamada al sistema que reemplaza la imagen de un proceso por una nueva, pasando a ejecutar un nuevo programa. La familia de funciones <code>exec*</code> son wrappers de esa syscall.</p>

<p>Lo importante de todo esto son dos cosas: una <code>execve</code> exitosa no retorna, y reemplazar la imagen de un proceso no implica cambiar los atributos del mismo. De <code>man 2 execve</code>:</p>

<pre><code>All process attributes are preserved during an execve(), except the following:
</code></pre>

<p>Y, adiviná qué: las máscaras de las señales no son parte de las excepciones. Entonces, repasemos: llega la señal, se bloquean la señal recibida, y se ejecuta el handler de la señal. Si ese handler hiciera un <code>execve</code> exitoso, la función no retorna: empieza a ejecutar el nuevo proceso. Pero, si el handler no retorna, nunca se desbloquea la señal, por lo que el nuevo proceso no recibirá más la señal especificada, porque serán encoladas eternamente. Bang.</p>

<p>La solución a esto es desbloquear la señal a mano antes de llamar a <code>execve</code>. En C, desde dentro del handler, podríamos lograrlo usando este fragmento de código:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>
</span><span class='line'><span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
</span><span class='line'><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
</span><span class='line'><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>sigemptyset</code> inicializa un set de señales vacío, y luego marcamos la señal que nos interese (en este caso, <code>SIGINT</code>) en ese set. Por último, la función <code>sigprocmask</code> es la que se encargará, con estos parámetros, de desbloquear el set de señales marcados (sólo <code>SIGINT</code>). Luego de esto, sí, podremos ejecutar <code>execve</code> sin problemas.</p>

<p><strong>Créditos</strong>: mucha información de este post surgió a partir de <a href="http://stackoverflow.com/a/1024778">esta respuesta en StackOverflow</a>.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Se pueden listar todas las señales ejecutando <code>kill -l</code><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>En Linux, que tiene <abbr title="Kernel Level Thread - Hilos de Kernel">KLTs</abbr>, uno puede enviar la señal especificando un <abbr title="Thread ID - Identificador de Hilo">TID</abbr> en lugar de un <abbr title="Process ID - Identificador de Proceso">PID</abbr>, por lo que puede mandarle la señal a un hilo en particular. Poniéndonos más técnicos, el PID coincide con el TID del hilo principal (<code>main()</code>), por lo que al enviarle la señal al proceso en realidad se la estamos enviando al hilo principal. Pero la idea genérica de &ldquo;las señales se envían a procesos&rdquo; es más feliz.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[inotify]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/30/inotify/"/>
    <updated>2013-12-30T02:09:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/30/inotify</id>
    <content type="html"><![CDATA[<blockquote><p>**Disclaimer**: nunca implementé inotify, por lo que este post puede ser incompleto, incorrecto, o cualquier otro &#8220;in&#8221; que se te ocurra. Su espíritu es simplemente poder referenciar acá cada vez que surja un inconveniente con la herramienta, para no repetir lo que escribo siempre, y para cada vez dar una mejor respuesta. Todo aporte será más que bienvenido.</p></blockquote>


<p>El mundo real apesta. Existe el hambre, la capa de ozono se debilita, y el software obra de maneras misteriosas.</p>

<p><code>inotify</code> es una API de Linux que nos permite monitorear cambios en un archivo o directorio. En criollo, es un <em>duende</em> al que le pedimos que levante la mano cuando ocurre algún evento que a nosotros nos interese, como la creación de un archivo en un directorio, la eliminación de un archivo o una escritura.<!--more--></p>

<p>Como es funcionalidad que provee el kernel, claramente está bien implementada: nada de tener al duende haciendo <code>ls</code> cada medio segundo para que avise al encontrar diferencias entre los últimos dos <code>ls</code>, sino que existe un modelo de eventos, y nosotros podemos especificar aquellos que nos interesa que se nos notifiquen (de ahí el 90% del nombre, je).</p>

<p>El otro 10% es la i. <code>inotify</code> es funcionalidad que provee el kernel, por lo que trabaja al nivel al que el kernel conoce a los archivos, el File Control Block: los inodos. Al atender las diferentes llamadas al sistema (syscalls), el kernel dispara también las notificaciones correspondientes.</p>

<p>Los eventos por los que podemos ser notificados están explicados en el man:</p>

<pre><code>IN_ACCESS         File was accessed (read) (*).
IN_ATTRIB         Metadata changed, e.g., permissions, timestamps, extended attributes,
                    link count (since Linux 2.6.25), UID, GID, etc. (*).
IN_CLOSE_WRITE    File opened for writing was closed (*).
IN_CLOSE_NOWRITE  File not opened for writing was closed (*).
IN_CREATE         File/directory created in watched directory (*).
IN_DELETE         File/directory deleted from watched directory (*).
IN_DELETE_SELF    Watched file/directory was itself deleted.
IN_MODIFY         File was modified (*).
IN_MOVE_SELF      Watched file/directory was itself moved.
IN_MOVED_FROM     File moved out of watched directory (*).
IN_MOVED_TO       File moved into watched directory (*).
IN_OPEN           File was opened (*).
</code></pre>

<p>El problema ocurre con el mundo real. Dado que en ningún lugar está definido el contrato de cómo un programa tiene que implementar sus funcionalidades (por comunes que sean, como la actualización de un archivo), cada aplicación en particular puede implementar un conjunto de llamadas al sistema distinto para hacerlo. Si a esto sumamos la antiguedad y diversidad de orígenes de los editores de texto que se usan en Linux (algunos datan de los 70, pensados para usar en mainframes, mientras que otros son más recientes y apuntan a optimizar acceso a disco, o uso de memoria, o tiempo de respuesta), el panorama es realmente complejo: algunos editores de texto simplemente actualizarán los bloques de datos que hayan cambiado, mientras que otros optarán por enfoques más extraños.</p>

<p>Un caso conocido es el de <code>nano</code>. Al grabar un archivo pequeño (archivos menores a 1 bloque &ndash; 4kb), <code>nano</code> optará por vaciar el archivo (truncarlo a 0 bytes) y luego grabar su contenido, por lo que <code>inotify</code> disparará dos eventos: <code>IN_MODIFIY</code> (&ldquo;el archivo fue vaciado&rdquo;), y luego otro <code>IN_MODIFY</code> (&ldquo;se escribió el contenido del archivo&rdquo;).</p>

<p><code>vim</code>, por otro lado, mantiene un archivo de backup mientras vamos trabajando, para ahorrarnos algún dolor de cabeza si se nos llegara a apagar mal la máquina. Ahora, como ya mantiene ese archivo de backup, a <code>vim</code> le es más facil, cuando le pedimos grabar un archivo, reemplazar el archivo que existía por el backup actualizado, y listo. El resultado de esto es un set de llamadas al sistema bastante distinto al de <code>nano</code>: primero elimina el archivo original, y luego renombra el backup para que ocupe la ruta en que se encontraba el original. El problema con esto no sólo es que no hay eventos <code>IN_MODIFY</code>, sino que, como dijimos, <code>inotify</code> conoce inodos: el archivo del backup, por más que pase a llamarse igual que el original, es un inodo distinto, por lo que <code>inotify</code> dejará de detectar eventos sobre el archivo que se encuentra en el path que habíamos especificado.</p>

<p>&ldquo;Solucionar&rdquo; estos problemas requiere tener en cuenta el comportamiento de cada editor y reaccionar de manera acorde cuando se detectan los eventos.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bajando el nivel]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/10/21/bajando-el-nivel/"/>
    <updated>2013-10-21T01:19:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/10/21/bajando-el-nivel</id>
    <content type="html"><![CDATA[<p>&ldquo;Che, me acabás de decir que el 0 sigue existiendo por más que <em>lo pise</em> con otro valor. ¿El 0 es un objeto al que la VM le mantiene referencias y por eso no se lo lleva el Garbage Collector?&rdquo;<!--more--></p>

<p>What!? No way, papá. Por un cuatrimestre, las palabras &ldquo;objeto&rdquo; y &ldquo;Garbage Collector&rdquo; dejalas en la oficina, y VM = VirtualBox :)</p>

<p>En C no hay objetos.</p>

<p>Perdón si fui duro, pero es necesario: en C no hay objetos. Y no hay GC.</p>

<p>&ldquo;Entonces, ¿qué es el 0?&rdquo;</p>

<p>El 0 es una constante. Si recordás, en Arquitectura (bazinga) vimos que los números se representan en binario en la PC. Las variables de C son meras referencias a algún bloque de memroia, siendo el tipo de la variable el que anuncia qué tamaño tiene esa referencia.</p>

<p>Digamos, esto es una memoria de 30 bytes<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (éramos tan pobres):</p>

<p><img src="http://mgarciaisaia.github.io/tutorial-c/assets/memoria-libre.png" alt="Una RAM de 30 bytes" /></p>

<p>Esa es toda la memoria de esta computadora hipotética. Si en mi programa declaro una variable <code>int exit_status;</code>, podríamos pensarlo como que C hará algo así:</p>

<p><img src="http://mgarciaisaia.github.io/tutorial-c/assets/memoria-reservada.png" alt="La RAM con una variable" /></p>

<p>En algún lugar de la memoria (en este caso, a partir del byte 13), C reservó<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> unos bytes para nuestra variable ¿Cuántos bytes reservó? Eso depende del tipo de dato que le declaramos a la variable. Por definición, el tipo <code>int</code> equivale al <a href="http://es.wikipedia.org/wiki/Palabra_(inform%C3%A1tica)">tamaño de palabra del procesador</a>. Esto significa que en máquinas de 32 bits (como esta computadora hipotética, o las VMs de la cátedra, o la enorme mayoría de los Windows XP y Vista), un <code>int</code> va a ocupar 4 bytes (32 bits).</p>

<p>Entonces, al hacer algo como <code>exit_status = 0;</code> (y sabiendo que <code>exit_status</code> es una variable entera de 4 bytes), el compilador sabe que tiene que hacer que los 4 bytes que están a partir del byte en que empieza <code>exit_status</code> valgan un 0. En Arquitectura aprendimos que los enteros con signo se representan usando el <a href="http://es.wikipedia.org/wiki/Complemento_a_dos">complemento a 2</a>, por lo que el 0 en 32 bits es simplemente <a href="http://es.wikipedia.org/wiki/Sistema_hexadecimal"><code>0x0000 0000</code></a> (4 bytes en 0).</p>

<p>Entonces, ¿dónde está ese 0? <a href="http://es.wikipedia.org/wiki/Hard_code">Hardcodeado</a> en el binario. Compilar un programa es pedirle al compilador (<code>gcc</code> en nuestro caso) que traduzca todo ese C hermoso que escribimos en las instrucciones de Assembler que nuestro procesador tiene que ejecutar para que el código funcione con nuestro sistema operativo. De todas esas, alguna va a ser algo como <code>mov eax, 0x00000000</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>: <strong>ese</strong> es tu 0.</p>

<p>&ldquo;¿Y a mí cuál?&rdquo;</p>

<p>Meh, no mucho. Sólo quería dejar en claro cómo funciona esto: C es una mini abstracción de la programación en Assembler, por lo que no está tan lejos. No tenés que ser un capo de Assembler para programar C<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> (no necesitás saber Assembler, siquiera), pero tenés que tener un claro entendimiento de cómo funciona la computadora a bajo nivel para entender qué es lo que está haciendo tu código.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>La memoria de una PC tiene muchísimo más tamaño, pero dejame hacerla dibujable.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>C es un lenguaje. Decir &ldquo;C hizo tal cosa&rdquo; es medio vago: probablemente sea algo que hizo el compilador, o el sistema operativo, o alguna biblioteca más o menos estándar. Cuando decimos &ldquo;C hizo tal cosa&rdquo; es porque: a) no nos interesa mucho quién lo hizo (importa que lo hizo <em>otra persona</em>, y que es más o menos lo mismo para cualquier programa en C), o b) no sabemos quién lo hizo (y nos da fiaca averiguarlo, de momento).<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>No se Assembler, creo que el parámetro no va en la misma línea que el <code>mov</code>, pero anda por ahí cerca.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Lo aclaré en la anterior: no se Assembler.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variables]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/20/variables/"/>
    <updated>2013-08-20T01:21:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/20/variables</id>
    <content type="html"><![CDATA[<p>Bien. Escribimos, compilamos y corrimos nuestro primer programa. Pero es como bastante aburrido, ¿no? Vamos a ponerle onda: declaremos una variable (¡iupi! (¿?))</p>

<figure class='code'><figcaption><span>ok.c (v2) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Guau. Me la jugué :) Anoche no dormí porque me quedé debuggeando un error en este programa.<!--more--></p>

<p>¿Qué cambió? Bueno, entre las llaves hay dos instrucciones ahora. En principio, donde antes decía <code>return 0;</code>, ahora dice <code>return exit_status;</code>.</p>

<p>&ldquo;Así que seguramente <code>exit_status</code> sea una variable mágica de C, como <code>$?</code> en bash&rdquo; Pendorcho. <code>exit_status</code> es una variable, sí. Osea, es un identificador de un <em>cacho&#8217;e memoria</em>. Puedo guardar <em>cosas</em> ahí, y luego leerlas. Pero antes necesito declararla, para decir: a) que existe; y b) qué tipo de cosas va a manejar esa variable. Y eso es lo que hicimos antes: <code>int exit_status = 0;</code>.</p>

<p>Para declarar una variable, especificamos su tipo de dato, seguido por su nombre. En nuestro caso, <code>int exit_status</code> crea una variable de tipo <code>int</code> llamada <code>exit_status</code>. Declaraciones válidas son <code>int hola;</code> o <code>int hola, chau;</code>, por ejemplo: la primera declara una variable <code>hola</code> de tipo <code>int</code>, mientras que la segunda crea <code>hola</code> y <code>chau</code>, dos variables de tipo <code>int</code>, ambas totalmente independientes entre sí.</p>

<p>Pero con declarar la variable no alcanza: si queremos devolverla o leerla, primero tenemos que darle un valor (&ldquo;inicializarla&rdquo;, para los amigos). En C, las asignaciones son del estilo <code>variable = expresion;</code>, donde, en nuestro caso original, <code>expresion</code> es un triste <code>0</code> constante. Y ahí tenemos nuestra primera línea: <code>int exit_status = 0;</code>.</p>

<p>&ldquo;Che, y, entonces, si no es una variable mágica de C, ¿por qué se llama <code>exit_status</code> y no, por ejemplo, <code>a</code>, <code>bleh</code> o <code>code</code>?&rdquo; Bueno, porque nosotros <strong>sí</strong> fuimos a la clase de nombres bonitos y representativos :) Y si esa variable representa nuestro estado de salida, así la llamaremos<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Podríamos haberla llamado <code>a</code>, <code>bleh</code>, <code>code</code> o <code>__a256723b</code>, pero preferimos reservarnos los nombres horribles para las PPT :)</p>

<p>Buen, a ver qué hace este programa:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>Compilamos y ejecutamos, y vemos que sigue sin mostrar nada. Hacemos el <code>echo</code> y vemos nuestro hermoso 0.</p>

<p>&ldquo;Che, para mí que éste nos está chamuyando y el 0 está hardcodeado por ahí&rdquo;</p>

<p>OK, cambiémoslo:</p>

<figure class='code'><figcaption><span>ok.c (v2.1) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y probemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>&ldquo;¡Ajá! ¡Te dije que nos mentía!&rdquo;</p>

<p>¡Momento, cerebrito! No recompilaste, chámpion ;&ndash;)</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p><em>¡Touché!</em></p>

<p>&ldquo;OK, ganaste. Ahora, si necesito recompilarpara cambiar el valor de una variable, muy variable no me parece. Y podría cambiar el 0 por un 1 en la primer versión de <code>ok.c</code>, y no tengo que andar haciendo tanta parafernalia. ¿Por qué se llaman <em>variables</em>?&rdquo;</p>

<p>Buen, sí, justamente, porque podés cambiarles el valor durante una misma ejecución del programa. Así como inicializamos <code>exit_status</code> en 0 o en 1, podríamos después de esa incialización <em>asignarle</em> un nuevo valor. Desde que se ejecute esa instrucción en adelante, cada vez que se lea el contenido de la variable obtendremos el nuevo valor, como si nunca hubiera tenido un valor distinto:</p>

<figure class='code'><figcaption><span>ok.c (v2.2) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p><code>=</code> es el operador de asignación. El resultado de evaluar lo que esté a su derecha (ya veremos alternativas, pero por ahora quedémonos con que los números evalúan a sí mismos) se almacena en el espacio de memoria referido a la izquierda.
Y, ¿qué pasó con el 0? Se perdió. El 0 sigue existiendo y valiendo 0, como siempre. Sólo que el contenido de la variable <code>exit_status</code> se sobreescribe con <code>1</code>: la asignación es <em>destructiva</em>.</p>

<p>Sigamos jugando con esto:</p>

<figure class='code'><figcaption><span>ok.c (v2.3) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">exit_status</span> <span class="o">=</span> <span class="n">a_number</span><span class="p">;</span>
</span><span class='line'>  <span class="n">a_number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p>&ldquo;¡Eh! ¡¿Qué onda?! Si <code>exit_status</code> es igual a <code>a_number</code>, y a <code>a_number</code> le asigno <code>3</code>, ¿por qué el estado de salida es <code>1</code>?&rdquo;</p>

<p>Bueno, porque te olvidaste lo que dije de la asignación: en lo que está a la izquierda del <code>=</code> guardo el resultado de evaluar lo que está a <em>la otra izquierda</em> del mismo (comunmente conocida como &ldquo;derecha&rdquo;). Y nada más que eso: las variables no se ligan, ni quedan relacionadas, ni nada. Las variables se evalúan a su contenido del momento en que se ejecuta la instrucción, por lo que al hacer <code>exit_status = a_number;</code> estamos diciendo &ldquo;en <code>exit_status</code> guardame lo que <code>a_number</code> valga en ese momento&rdquo;. Como <code>a_number</code> venía valiendo 1, <code>exit_status</code> pasa a valer 1 también. Que después modifiquemos <code>a_number</code> es otra canción, y no tiene ninguna relación con esa asignación que ya se hizo: lo hecho, hecho está, y si al evaluar la variable ésta valía 1, los posibles valores que tenga después no importan, porque ya se realizó la asignación.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Hay miles de debates sobre escribir código en inglés vs español. No prometo ser constante durante la guía, pero tiendo a codificar en inglés. Comercialmente hablando, ~todos deseamos que nos compre Google, tercerizar el desarrollo a India, o pedir ayuda con los problemas en <a href="http://stackoverflow.com/">StackOverflow</a>. Pero, si escribir en inglés hará que no entiendas lo que representa cada cosa (cargándote la clase de nombres descriptivos), dale con el español. El piso mínimo que deberías tener es que todo el equipo (sea del TP, o de un trabajo <em>de posta</em>) use la misma convención. Y atenti con el tema de caracteres acentuados y eso, que a ¡¡50!! años de inventarse <a href="http://es.wikipedia.org/wiki/ASCII">el código ASCII</a> seguimos encontrándonos caracteres mochos por ahí, y, en el peor de los casos, puede hacernos fallar la compilción por problemas de encoding. Nadie quiere eso.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arrancando]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/19/arrancando/"/>
    <updated>2013-08-19T21:59:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/19/arrancando</id>
    <content type="html"><![CDATA[<p>Vamos a hacer un programa en C, por lo que empezamos con una función:</p>

<figure class='code'><figcaption><span>ok.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este es (aproximadamente) el programa más chico que podamos hacer en C. <code>main()</code> es la función que se ejecuta al ejecutar un programa C. En este caso, el prototipo de la función es <code>int main(void)</code>: nuestro programa no recibirá parámetros (<code>void</code>), y devolverá a quién lo ejecute un entero signado (<code>int</code>).<!--more--></p>

<p>Nuestro programa tiene una única instrucción: devolver (<code>return</code>) 0, un código de salida que, por convención, indica que el programa ejecutó correctamente.
Compilemos nuestro programa:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>ok.c ok
</span></code></pre></td></tr></table></div></figure>


<p><code>gcc</code> es el compilador más usado de C. Parte de la GNU Compiler Collection, <code>gcc</code> es el compilador específico de C (el proyecto se llamaba GNU C Compiler, pero cambiaron el nombre por soportar también C++, Java y tantos otros lenguajes). Como casi todo comando en Linux, Unix y derivados, podemos leer su manual haciendo <code>man gcc</code>.</p>

<p><code>gcc</code> recibe como parámetro (entre tantos otros) el archivo fuente a compilar (<code>ok.c</code>), y el parámetro <code>-o NOMBRE</code> indica qué nombre queremos darle al binario resultante (<code>ok</code>). De no indicarlo, <code>gcc</code> elije uno <em>hermoso</em>: <code>a.out</code>.</p>

<p>Ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>Hay un 0, así que debemos estar <em>no-tan-mal</em>, como mínimo. ¿Qué pasó acá?</p>

<p>En UNIX, la forma de ejecutar un programa es escribiendo como orden la ruta completa al mismo y, luego, separados por espacios, todos sus parámetros. Por ejemplo:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/bin/ps --version
</span><span class='line'>procps-ng version 3.3.3
</span></code></pre></td></tr></table></div></figure>


<p>Ejecutamos el programa <code>/bin/ps</code> con el parámetro <code>--version</code>. <code>ps</code> nos contesta la versión que tenemos instalada. En nuestro caso anterior, ejecutamos <code>./ok</code>. <code>.</code> y <code>..</code> son dos enlaces especiales que hay en todo directorio: <code>.</code> enlaza al directorio actual (el propio directorio que contiene a <code>.</code>), y <code>..</code> enlaza al directorio padre del actual (osea, al directorio que contiene al directorio que contiene a <code>..</code>). Entonces, al escribir <code>.</code> ya estamos referenciando toda la ruta al directorio actual. Si estamos ubicados en <code>/home/utnso</code>, <code>.</code> y <code>/home/utnso</code> se refieren al mismo directorio. Agregándole <code>/ok</code> queda <code>./ok</code>, que equivale a <code>/home/utnso/ok</code>, la ruta completa a nuestro programa. Hell yeah, ruta completa => ¡ejecutamos el programa!</p>

<p>&ldquo;Che, pero&hellip; ¡No me mostró nada! ¿Dónde está mi 0?&rdquo;</p>

<p>Bueno, sí, es cierto. No muestra nada porque no le pedimos que muestre nada: nuestro programa sólo devuelve un 0, y nuestra consola sólo ejecuta las instrucciones que le damos. Entonces, pidámosle que muestre el resultado: <code>echo $?</code>.</p>

<p>&ldquo;¡Que te recontra!&rdquo; Bueno, sí. <a href="http://en.wikipedia.org/wiki/Stephen_R._Bourne">El amigo Bourne</a> había faltado a la clase de nombres descriptivos. <code>echo</code> es un comando de las consolas que imprime en pantalla<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> lo que sea que le pasemos por parámetro. Por ejemplo, <code>echo Hola mundo</code> imprime <code>Hola mundo</code>. <code>bash</code> (el lenguaje que interpreta nuestra consola) posee variables, y para dereferenciarlas (leerlas) hay que anteponerle un <code>$</code> al nombre de la variable. Por ejemplo (<code>#</code> es el caracter de comentario):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ nombre</span> <span class="o">=</span> <span class="s2">&quot;Mundo&quot;</span> <span class="c"># asigno &quot;Mundo&quot; a la variable nombre, creandola si no existe</span>
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$nombre</span> <span class="c"># imprimo el contenido de la variable llamada nombre</span>
</span><span class='line'>Mundo
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;Hola $nombre&quot;</span>
</span><span class='line'>Hola Mundo
</span></code></pre></td></tr></table></div></figure>


<p>En particular, nosotros le habíamos pedido mostrar una variable: <code>$?</code>. <code>?</code> es una variable manejada automáticamente por Bash. Cada vez que ejecuta una instrucción, Bash almacena en <code>?</code> el código de salida del programa ejecutado. Por eso, al pedirle que imprima la variable <code>?</code> (<code>echo $?</code>), Bash nos mostró el 0 que nuestro programa había devuelto.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>En realidad, imprime en la salida estándar, ya lo veremos más adelante. Por ahora, creeme que es la pantalla.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
