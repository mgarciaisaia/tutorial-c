<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[C para Operativos]]></title>
  <link href="http://mgarciaisaia.github.io/tutorial-c/atom.xml" rel="self"/>
  <link href="http://mgarciaisaia.github.io/tutorial-c/"/>
  <updated>2015-03-20T02:05:36-03:00</updated>
  <id>http://mgarciaisaia.github.io/tutorial-c/</id>
  <author>
    <name><![CDATA[mgarciaisaia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dream of Serialization]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/"/>
    <updated>2015-02-27T00:30:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization</id>
    <content type="html"><![CDATA[<p>Las variables de C son nombres que refieren a una posición de memoria de la computadora. El compilador traduce cada nombre a una dirección de memoria, y el tamaño de la variable está determinado por su tipo.</p>

<p>Pero si bien el estándar de C pone algunas restricciones a los tamaños de los tipos de datos básicos, no todos tienen igual tamaño en las distintas plataformas, o incluso entre distintos compiladores de C para la misma plataforma.<!-- more --></p>

<p>Además, para optimizar los accesos a memoria (operación lenta desde el punto de vista de la CPU), los compiladores suelen ubicar las variables <em>alineadas a la palabra de la CPU</em>. En general, la CPU no lee bytes individuales desde la memoria, si no que pide bloques del tamaño del ancho del bus de datos (4 bytes en máquinas de 32 bits, 8 en máquinas de 64 bits). Si una variable de 4 bytes estuviera ubicada en una posición no-múltiplo de 4 en un procesador de 32 bits, la CPU tendría que hacer 2 lecturas para accederla: una para leer el bloque de 4 bytes con los primeros bytes de la variable, y otra para el segundo bloque.</p>

<p>Esto aplica, también, a los <code>struct</code>s. Los campos de un <code>struct</code> se almacenan contiguamente en memoria, alineándose a la palabra. De hecho, <code>sizeof</code> nos va a devolver el tamaño del <code>struct</code> incluyendo los bytes de alineación (es decir, es muy probable que un <code>struct</code> compuesto por un <code>char</code> y un <code>int</code> &ndash; en ese orden &ndash; pese 8 bytes y no 5).</p>

<p>Todo esto fundamenta una única frase: no tenemos garantías sobre cómo van a organizarse los datos en un proceso que no sea el de nuestro propio programa. Encapsulamiento, que le dicen los hippies de Paradigmas :)</p>

<p>Entonces, ¿qué es la serialización? Bueno, es el arte de especificar un protocolo mediante el cual dos procesos van a comunicarse. Me encantaría poder hacer <code>send(socket, myStruct, sizeof(myStruct), ...)</code> y que eso funcione, pero si del otro lado me hacen <code>recv(socket, &amp;myStruct, sizeof(myStruct), ...)</code> no tengo ninguna garantía de que los bytes estén en el orden correcto<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (ni de que el otro proceso también haya estado hecho en C, o que exista un <code>struct</code> como el que tengo yo, etc).</p>

<p>En fin, no puedo confiar en que mi estructura pueda viajar <em>como está</em>, entonces especifico mi propio protocolo: si tengo que mandar una estructura que tiene un <code>char</code> y un <code>int</code>, especifico &ndash; por ejemplo &ndash; que siempre voy a mandar un primer byte con el <code>char</code> y luego otros 4 bytes con el <code>int</code>.</p>

<p>De este modo, en lugar de hacer el <code>send()</code> de hace un rato, seguramente prefiera primero armar un buffer para meter todo el mensaje contiguo (<em>serializado</em>), y hacer <code>send</code> de eso<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>:</p>

<figure class='code'><figcaption><span>Enviando una estructura medio primitivamente </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="p">.</span><span class="n">aChar</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="p">.</span><span class="n">anInt</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
</span><span class='line'><span class="n">send</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Del otro lado, al recibir la estructura, hago algo parecido: recibo 5 bytes (todo un mensaje), y copio el primer byte al <code>char</code>, y los 4 siguientes al <code>int</code>:</p>

<figure class='code'><figcaption><span>Recibiendo una estructura medio primitivamente </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="n">recv</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="k">struct</span> <span class="n">my_struct_t</span> <span class="o">*</span><span class="n">myStruct</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_struct_t</span><span class="p">));</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="o">-&gt;</span><span class="n">aChar</span><span class="p">),</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="o">-&gt;</span><span class="n">anInt</span><span class="p">),</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>De este modo, las estructuras de uno y otro lado están súper desacopladas: los campos podrían tener distintos nombres, podrían existir campos extras, tener distintas precisiones&hellip; Incluso podrían ser programas hechos en distintos lenguajes. Lo único que importa es que ambos extremos de la comunicación entiendan cómo deben interpretar esos bytes: si hago un programa en Prolog que relacione el primer byte recibido (andá a saber cómo) con un caracter, y los cuatro siguientes con un número, todos felices.</p>

<p>Es importante notar que tomamos decisiones re grosas: en nuestro protocolo, los caracteres son de 1 byte, y los enteros de 4, al menos para este mensaje. Si queremos hacer un cliente para plataformas cuyos <code>int</code> son de 2 bytes, vamos a tener que decidir cómo manejar los overflows (por ejemplo, usar variables de algún tipo más grande en nuestro <code>struct</code>, o truncar el valor recibido, o lo que sea), y mismo si estamos en 64 bits: nuestro <code>int</code> de 64 bits podría no ser representable en 4 bytes. No hay una receta universal para esto: son decisiones de diseño intrínsecas a nuestro problema.</p>

<p><em>(Continuará&hellip;)</em></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>No olvidar, tampoco, little-endian vs big-endian, etc.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>El código que se muestra en el post tiene como prioridad ilustrar las ideas relacionadas con serialización con la menor cantidad de código extra posible. <strong>No sigue</strong> muchísimas buenas prácticas de programación, ni es digno de ser usado en código productivo, ni código de Trabajo Práctico. En particular, además de modularizar, elegir buenos nombres, etc, cualquiera que pretenda usar esto debería agregar chequeo de errores, reintentos, validaciones, etc&hellip; Y completar los parámetros faltantes de los <code>send</code> y <code>recv</code> :)<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aprendiendo C con GDB]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/24/aprendiendo-c-con-gdb/"/>
    <updated>2015-02-24T22:07:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/24/aprendiendo-c-con-gdb</id>
    <content type="html"><![CDATA[<p><em>Este post es mi traducción del post <a href="https://www.hackerschool.com/blog/5-learning-c-with-gdb">Learning C with GDB</a> de <a href="https://github.com/happy4crazy">Alan O&#8217;Donnell</a>, del blog de <a href="https://www.hackerschool.com/">Hacker School</a>. La traducción fue hecha con el permiso de Hacker School, y obviamente todos los derechos sobre el post original les pertenecen a ellos.
Cualquier error o sugerencia sobre la traducción es más que bienvenida.</em></p>

<p>Viniendo del mundo de lenguajes de más alto nivel como Ruby, Scheme o Haskell, aprender C puede ser complicado. Además de tener que pelear con las características de bajo nivel de C como el manejo manual de memoria y los punteros, tenés que arreglártelas sin un REPL. Una vez que te acostumbrás a programar explorando en un REPL, tener que lidiar con el ciclo escribir-compilar-correr es bastante un desalentador.</p>

<p>Hace poco se me ocurrió que podría usar <code>gdb</code> como un pseudo-REPL para C. Estuve experimentando el uso de <code>gdb</code> como una herramienta para aprender C, en lugar de simplemente para debuggear C, y está bastante bueno.</p>

<p>Mi objetivo en este post es mostrarte que <code>gdb</code> es una gran herramienta para aprender C. Te voy a mostrar algunos de mis comandos de <code>gdb</code> favoritos, y después te voy a mostrar cómo podés usar <code>gdb</code> para entender una parte bastante complicada de C: la diferencia entre los arrays y los punteros.<!-- more --></p>

<h2>Una introducción a GDB</h2>

<p>Empecemos creando este pequeño programa C, <code>minimal.c</code>:</p>

<figure class='code'><figcaption><span>minimal.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1337</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notá que el programa no hace nada, y ni siquiera tiene un <code>printf</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. ¡Bienvenido al nuevo mundo de aprender C con <code>gdb</code>!</p>

<p>Compilalo con la opción <code>-g</code> para que <code>gdb</code> tenga información de debug, y después correlo con <code>gdb</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc -g minimal.c -o minimal
</span><span class='line'><span class="nv">$ </span>gdb minimal
</span></code></pre></td></tr></table></div></figure>


<p>Ahora deberías encontrarte con el prompt bastante austero de <code>gdb</code>. Te prometí un REPL, así que acá va:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
</span><span class='line'><span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>¡Excelente! <code>print</code> es un built-in de <code>gdb</code> que imprime el resultado de evaluar una expresión de C. Si en algún momento tenés dudas sobre el funcionamiento de un comando de <code>gdb</code>, probá corriendo <code>help nombre-del-comando</code>.</p>

<p>Acá hay un ejemplo un poco más interesante:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gbd</span><span class="p">)</span> <span class="n">print</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="mi">2147483648</span>
</span><span class='line'><span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483648</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ignoremos los motivos por los que <code>2147483648 == -2147483648</code>. El punto es que <code>gdb</code> también entiende la aritmética, que puede ser bastante complicada en C.</p>

<p>Pongamos un breakpoint en la función <code>main</code> y arranquemos el programa:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gbd</span><span class="p">)</span> <span class="k">break</span> <span class="n">main</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">run</span>
</span></code></pre></td></tr></table></div></figure>


<p>El programa ahora está pausado en la línea 3, justo antes de inicializar <code>i</code>. Resulta interesante que, por más que <code>i</code> no haya sido inicializada aún, podamos ver su valor con el comando <code>print</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gbd</span><span class="p">)</span> <span class="n">print</span> <span class="n">i</span>
</span><span class='line'><span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="mi">32767</span>
</span></code></pre></td></tr></table></div></figure>


<p>En C, el valor de una variable local no inicializada es indefinido, por lo que podrías ver distintos valores cuando lo pruebes vos.</p>

<p>Podemos ejecutar la línea actual usando el comando <code>next</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">next</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="n">i</span>
</span><span class='line'><span class="err">$</span><span class="mi">4</span> <span class="o">=</span> <span class="mi">1337</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Examinando la memoria con <code>x</code></h2>

<p>Las variables en C son simplemente nombres que se le pone a bloques de memoria. El bloque de memoria de una variable está caracterizada por dos números:</p>

<ol>
<li>La dirección numérica del primer byte del bloque</li>
<li>El tamaño del bloque, medido en bytes. El tamaño del bloque de una variable está determinado por el tipo de la variable</li>
</ol>


<p>Una de las características distintivas de C es que tenés acceso directo al bloque de memoria de las variables. El operador <code>&amp;</code> computa la dirección de una variable, y el operador <code>sizeof</code> computa el tamaño de esa variable en memoria.</p>

<p>Podemos jugar con estos conceptos en <code>gdb</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="o">&amp;</span><span class="n">i</span>
</span><span class='line'><span class="err">$</span><span class="mi">5</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x7fff5fbff584</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="err">$</span><span class="mi">6</span> <span class="o">=</span> <span class="mi">4</span>
</span></code></pre></td></tr></table></div></figure>


<p>En palabras, eso dice que el bloque de memoria de <code>i</code> empieza en la dirección <code>0x7fff5fbff584</code>, y que ocupa 4 bytes de memoria.</p>

<p>Antes mencioné que el tamaño de una variable en memoria es determinado por su tipo, y, de hecho, el operador <code>sizeof</code> puede operar directamente sobre tipos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span><span class='line'><span class="err">$</span><span class="mi">7</span> <span class="o">=</span> <span class="mi">4</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span>
</span><span class='line'><span class="err">$</span><span class="mi">8</span> <span class="o">=</span> <span class="mi">8</span>
</span></code></pre></td></tr></table></div></figure>


<p>Esto significa que, al menos en mi máquina, las variables de tipo <code>int</code> ocupan 4 bytes de memoria, y las <code>double</code> ocupan 8.</p>

<p><code>gdb</code> incluye una herramienta muy poderosa para examinar la memoria: el comando <code>x</code>. <code>x</code> examina la memoria, comezando en una dirección en particular. Incluye distintos comandos de formato para tener un control preciso de cuántos bytes querés examinar y cómo querés que se muestren. En caso de dudas, <code>help x</code> en el prompt de <code>gdb</code>.</p>

<p>El operador <code>&amp;</code> computa la dirección de una variable, por lo que podemos pasarle <code>&amp;i</code> a <code>x</code> y ver qué hay en los bytes que conforman el valor de <code>i</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">4</span><span class="n">xb</span> <span class="o">&amp;</span><span class="n">i</span>
</span><span class='line'><span class="mh">0x7fff5fbff584</span><span class="o">:</span> <span class="mh">0x39</span>    <span class="mh">0x05</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>
</span></code></pre></td></tr></table></div></figure>


<p>Los flags indican que queremos examinar <code>4</code> valores, formateados como números he<code>x</code>adecimales, de a un <code>b</code>yte a la vez. Elegí examinar 4 bytes porque ese es el tamaño de <code>i</code> en memoria &ndash; la salida muestra la representación byte a byte de <code>i</code> en memoria.</p>

<p>Un detalle a tener en cuenta con las representaciones byte a byte en las máquinas de la familia x86 es que los bytes se almacenan en <em>little-endian</em>: contrario a la notación humana, los bytes menos significativos de un número se almacenan primero en memoria.</p>

<p>Una forma de clarificar el tema es darle a <code>i</code> un valor más significativo y volver a examinar su bloque de memoria:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">set</span> <span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x12345678</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">4</span><span class="n">xb</span> <span class="o">&amp;</span><span class="n">i</span>
</span><span class='line'><span class="mh">0x7fff5fbff584</span><span class="o">:</span> <span class="mh">0x78</span> <span class="mh">0x56</span> <span class="mh">0x34</span> <span class="mh">0x12</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Examinando tipos con <code>ptype</code></h2>

<p>El comando <code>ptype</code> puede que sea mi comando favorito. Te dice el tipo de una expresión C:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">i</span>
</span><span class='line'><span class="n">type</span> <span class="o">=</span> <span class="kt">int</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="o">&amp;</span><span class="n">i</span>
</span><span class='line'><span class="n">type</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">main</span>
</span><span class='line'><span class="n">type</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Los tipos en C pueden volverse <a href="http://c-faq.com/decl/spiral.anderson.html">complejos</a>, pero <code>ptype</code> te permite explorarlos interactivamente.</p>

<h2>Punteros y arrays</h2>

<p>Los arrays en C son un concepto sumamente delicado. La idea de esta sección es que escribamos un programa simple y nos pongamos a jugar con <code>gdb</code> hasta que los arrays empiecen a tener sentido.</p>

<p>Escribí este programa <code>arrays.c</code>:</p>

<figure class='code'><figcaption><span>arrays.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Compilalo con la opción <code>-g</code>, correlo con <code>gdb</code>, y dale <code>next</code> para saltar la línea de inicialización:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="err">$</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">g</span> <span class="n">arrays</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">arrays</span>
</span><span class='line'><span class="err">$</span> <span class="n">gdb</span> <span class="n">arrays</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="k">break</span> <span class="n">main</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">run</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">next</span>
</span></code></pre></td></tr></table></div></figure>


<p>En este punto ya deberías poder hacer <code>print</code> del contenido de <code>a</code> y examinar su tipo:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="n">a</span>
</span><span class='line'><span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">a</span>
</span><span class='line'><span class="n">type</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ahora que nuestro programa ya inició en <code>gdb</code>, lo primero que deberíamos hacer es usar <code>x</code> para ver cómo se ve <code>a</code> internamente:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">12</span><span class="n">xb</span> <span class="o">&amp;</span><span class="n">a</span>
</span><span class='line'><span class="mh">0x7fff5fbff56c</span><span class="o">:</span> <span class="mh">0x01</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>  <span class="mh">0x02</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>
</span><span class='line'><span class="mh">0x7fff5fbff574</span><span class="o">:</span> <span class="mh">0x03</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>
</span></code></pre></td></tr></table></div></figure>


<p>Esto significa que el bloque de memoria de <code>a</code> comienza en la dirección <code>0x7fff5fbff56c</code>. Los primeros 4 bytes almacenan <code>a[0]</code>, los 4 siguientes almacenan <code>a[1]</code>, y los últimos 4 almacenan <code>a[2]</code>. De hecho, podés ver que <code>sizeof</code> sabe que el tamaño de <code>a</code> en memoria son 12 bytes:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="mi">12</span>
</span></code></pre></td></tr></table></div></figure>


<p>Hasta acá, los arrays parecen comportarse bastante como arrays. Tienen su propio tipo como arrays, y almacenan sus componentes en bloques de memoria contiguos. De todos modos, en algunas situaciones los arrays se comportan <em>bastante</em> como punteros. Por ejemplo, podemos hacer aritmética de punteros con <code>a</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'><span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x7fff5fbff570</span>
</span></code></pre></td></tr></table></div></figure>


<p>En palabras, esto dice que <code>a + 1</code> es un puntero a un <code>int</code>, y ubicado en la dirección <code>0x7fff5fbff570</code>. A esta altura, pasarle los punteros que veas a <code>x</code> debería serte un acto reflejo, así que probemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">4</span><span class="n">xb</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'><span class="mh">0x7fff5fbff570</span><span class="o">:</span> <span class="mh">0x02</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notá que <code>0x7fff5fbff570</code> es 4 más que <code>0x7fff5fbff56c</code>, la dirección del primer byte de memoria de <code>a</code>. Dado que los valores <code>int</code> ocupan 4 bytes, esto significa que <code>a + 1</code> apunta a <code>a[1]</code>.</p>

<p>De hecho, los subíndices de los arrays de C son <em>syntactic sugar</em> (agregados sintátcitos) para hacer aritmética de punteros: <code>a[i]</code> es equivalente a <code>*(a + i)</code>. Podés probarlo en <code>gdb</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'><span class="err">$</span><span class="mi">4</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="o">*</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="err">$</span><span class="mi">5</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span><span class='line'><span class="err">$</span><span class="mi">6</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="o">*</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="err">$</span><span class="mi">7</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span><span class='line'><span class="err">$</span><span class="mi">8</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="o">*</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="err">$</span><span class="mi">9</span> <span class="o">=</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>Vimos que, en algunas situaciones, <code>a</code> se comporta como un array, meintras que en otras actúa como un puntero a su primer elemento. ¿Qué está pasando?</p>

<p>La respuesta es que cuando se usa el nombre de un array en una expresión C, <em>degenera</em><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> en un puntero al primer elemento del array. Existen sólo dos excepciones a esta regla: cuando el nombre del array se le pasa a <code>sizeof</code>, y cuando se le pasa al operador <code>&amp;</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>El hecho de que <code>a</code> no degenere en un puntero cuando se lo pasamos al operador <code>&amp;</code> dispara una pregunta interesante: ¿hay alguna diferencia entre el puntero al que <code>a</code> degenera y <code>&amp;a</code>?</p>

<p>Numéricamente hablando, representan la misma dirección:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">4</span><span class="n">xb</span> <span class="n">a</span>
</span><span class='line'><span class="mh">0x7fff5fbff56c</span><span class="o">:</span> <span class="mh">0x01</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">4</span><span class="n">xb</span> <span class="o">&amp;</span><span class="n">a</span>
</span><span class='line'><span class="mh">0x7fff5fbff56c</span><span class="o">:</span> <span class="mh">0x01</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>  <span class="mh">0x00</span>
</span></code></pre></td></tr></table></div></figure>


<p>Así y todo, sus tipos son diferentes. Ya vimos que el valor al que <code>a</code> degenera es un puntero al primer elemento de <code>a</code>, por lo que su tipo debe ser <code>int *</code>. En cuanto al tipo de <code>&amp;a</code>, preguntémosle a <code>gdb</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="o">&amp;</span><span class="n">a</span>
</span><span class='line'><span class="n">type</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>En palabras, <code>&amp;a</code> es un puntero a un array de tres <code>int</code>s. Tiene sentido: <code>a</code> no degenera al ser pasado a <code>&amp;</code>, y el tipo de <code>a</code> es <code>int[3]</code>.</p>

<p>Podés observar la diferencia entre el valor al que degenera <code>a</code> y <code>&amp;a</code> probando cómo se comportan con la aritmética de punteros:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'><span class="err">$</span><span class="mi">10</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x7fff5fbff570</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'><span class="err">$</span><span class="mi">11</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span> <span class="mh">0x7fff5fbff578</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notá que sumarle 1 a <code>a</code> le suma 4 a su dirección, mientras que sumarle 1 a <code>&amp;a</code> le agrega ¡12!</p>

<p>El puntero al que <code>a</code> realmente degenera es <code>&amp;a[0]</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">print</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'><span class="err">$</span><span class="mi">11</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x7fff5fbff56c</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Conclusión</h2>

<p>Con un poquito de suerte, ya te convencí de que <code>gdb</code> es un lindo ambiente de exploración para aprender C. Podés imprimir el resultado de evaluar expresiones con <code>print</code>, e<code>x</code>aminar los bytes de memoria en crudo, y jugar con el sistema de tipos usando <code>ptype</code>.</p>

<p>Si querés experimentar un poco más con <code>gdb</code> para aprender C, estas son algunas sugerencias:</p>

<ul>
<li>Usá <code>gdb</code> para resolver el <a href="https://blogs.oracle.com/ksplice/entry/the_ksplice_pointer_challenge">desafío Ksplice de punteros</a></li>
<li>Investigá cómo se almacenan los <code>struct</code>s en memoria. ¿Cómo se comparan con los arrays?</li>
<li>¡Usá el comando <code>dissasemble</code> de <code>gdb</code> para aprender assembler! Un ejercicio particularmente entretenido es investigar cómo funciona el stack de llamadas.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li>
<li>Probá el modo <code>tui</code> de <code>gdb</code>, que ofrece una interfaz a <code>gdb</code> hecha en ncurses<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</li>
</ul>


<p><em>Alan es facilitador en Hacker School. Agradece a <a href="http://dave.is/">David Albert</a>, <a href="https://github.com/thomasballinger">Tom Ballinger</a>, <a href="http://nick.is/">Nicholas Bergson-Shilcock</a> y <a href="https://github.com/oxling">Amy Dyer</a> por sus muy útiles comentarios.</em></p>

<p><em>¿Te intriga Hacker School? Leé <a href="https://hackerschool.com/about">sobre ello</a>, mirá <a href="https://hackerschool.com/testimonials">lo que dicen sus alumnos</a>, y <a href="https://hackerschool.com/apply">aplicá</a> para la próxima camada.</em></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Dependiendo de cuán agresivo sea tu compilador a la hora de optimizar código inútil, podrías tener que hacer que efectivamente haga algo :) Yo probé estos ejemplos en mi Raspberry Pi y funcionó bien.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><strong>NdT</strong>: el artículo original dice que <em>it “decays” to a pointer to the array’s first element</em>. No conocía esa expresión, y no encuentro a mano algún material que diga <em>decay</em> y del que conozca su traducción, para ver cuál es el término usado en español (si es que hubiera uno consensuado). Elegí <em>degenera</em> porque se usa en algunas temáticas relacionadas, y porque me pareció que expresa un poco la intención original. Si así no lo hiciese, que <code>$DEITY</code> y la patria me lo demanden, o que alguien me deje un comentario con el término apropiado. Y así fue como, hace mil años, algún español nos pegó el karma de &ldquo;instancia&rdquo; en lugar de &ldquo;individuo, especimen&rdquo;. Soy un criminal, ¡oh yeah!<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Formalmente hablando, el nombre de un array es un &ldquo;non-modifiable lvalue&rdquo; (<em>valor izquierdo no modificable</em>). Cuando es usado en una expresión que requiere un rvalue (<em>valor derecho</em>), el nombre del array degenera en un puntero a su primer elemento. En cuanto a las excepciones, el operador <code>&amp;</code> requiere un lvalue, y <code>sizeof</code> simplemente es raro.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><strong>NdT</strong>: Podés leer este post relacionado: <a href="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/19/aprendiendo-assembler-para-entender-c/">Aprendiendo Assembler Para Entender C</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p><strong>NdT</strong>: podés leerte la <a href="http://beej.us/guide/bggdb/">Guía rápida de Beej para GDB</a>, que es corta, bastante buena, y usa todo el tiempo el modo <code>tui</code>.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aprendiendo Assembler para entender C]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/19/aprendiendo-assembler-para-entender-c/"/>
    <updated>2015-02-19T19:10:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/19/aprendiendo-assembler-para-entender-c</id>
    <content type="html"><![CDATA[<p><em>Este post es mi traducción del post <a href="https://www.hackerschool.com/blog/7-understanding-c-by-learning-assembly">Understanding C by learning assembly</a> de <a href="https://github.com/davidbalbert">David Albert</a>, del blog de <a href="https://www.hackerschool.com/">Hacker School</a>. La traducción fue hecha con el permiso de Hacker School, y obviamente todos los derechos sobre el post original les pertenecen a ellos.
Cualquier error o sugerencia sobre la traducción es más que bienvenida.</em></p>

<p>La última vez, <a href="https://github.com/happy4crazy">Alan</a> mostró cómo usar <a href="https://www.hackerschool.com/blog/5-learning-c-with-gdb">GDB como una herramienta para aprender C</a>. Hoy quiero ir un paso más allá y usar GDB para ayudarnos a entender assembler, también.</p>

<p>Las capas de abstracción son grandes herramientas para construir cosas, pero a veces pueden interponerse en el aprendizaje. Mi objetivo en este post es convencerte de que para aprender C rigurosamente, también necesitamos entender el código assembler que nuestro compilador de C genera. Voy a hacer esto mostrándote cómo desensamblar y leer un programa simple con GDB, y después vamos a usar GDB y nuestro conocimiento de assembler para entender cómo funcionan las variables locales estáticas en C.<!--more--></p>

<p><em>Nota: todo el código en este post fue compilado en una CPU x86_64 corriendo Mac OS X 10.8.1, usando Clang 4.0 con las optimizaciones deshabilitadas (<code>-O0</code>)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</em></p>

<h2>Aprendiendo assembler con GDB</h2>

<p>Empecemos por desensamblar un programa con GDB y aprender a leer su salida. Tipeá el siguiente programa en un archivo de texto y grabalo como <code>simple.c</code>:</p>

<figure class='code'><figcaption><span>sample.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">6</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ahora compilalo con los símbolos de depuración y sin optimizaciones, y corré GDB<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ CFLAGS</span><span class="o">=</span><span class="s2">&quot;-g -O0&quot;</span> make simple
</span><span class='line'>cc -g -O0    simple.c   -o simple
</span><span class='line'><span class="nv">$ </span>gdb simple
</span></code></pre></td></tr></table></div></figure>


<p>Dentro de GDB, pongamos un breakpoint en <code>main</code> y ejecutemos hasta llegar al <code>return</code>. Ponemos el número 2 después de <code>next</code> para especificar que queremos ejecutar el comando <code>next</code> dos veces:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="k">break</span> <span class="n">main</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">run</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">next</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ahora usemos el comando <code>disassemble</code> para mostrar las instrucciones assembler de la función actual. También podés pasarle el nombre de una función a <code>disassemble</code> para examinar una función diferente.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">disassemble</span>
</span><span class='line'><span class="n">Dump</span> <span class="n">of</span> <span class="n">assembler</span> <span class="n">code</span> <span class="k">for</span> <span class="n">function</span> <span class="n">main</span><span class="o">:</span>
</span><span class='line'><span class="mh">0x0000000100000f50</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">0</span><span class="o">&gt;:</span>    <span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="mh">0x0000000100000f51</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;:</span>    <span class="n">mov</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="mh">0x0000000100000f54</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">4</span><span class="o">&gt;:</span>    <span class="n">mov</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'><span class="mh">0x0000000100000f59</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">9</span><span class="o">&gt;:</span>    <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span><span class='line'><span class="mh">0x0000000100000f60</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">16</span><span class="o">&gt;:</span>   <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x5</span><span class="p">,</span><span class="o">-</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span><span class='line'><span class="mh">0x0000000100000f67</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">23</span><span class="o">&gt;:</span>   <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">ecx</span>
</span><span class='line'><span class="mh">0x0000000100000f6a</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">26</span><span class="o">&gt;:</span>   <span class="n">add</span>    <span class="err">$</span><span class="mh">0x6</span><span class="p">,</span><span class="o">%</span><span class="n">ecx</span>
</span><span class='line'><span class="mh">0x0000000100000f70</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">32</span><span class="o">&gt;:</span>   <span class="n">mov</span>    <span class="o">%</span><span class="n">ecx</span><span class="p">,</span><span class="o">-</span><span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span><span class='line'><span class="mh">0x0000000100000f73</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">35</span><span class="o">&gt;:</span>   <span class="n">pop</span>    <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="mh">0x0000000100000f74</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">36</span><span class="o">&gt;:</span>   <span class="n">retq</span>
</span><span class='line'><span class="n">End</span> <span class="n">of</span> <span class="n">assembler</span> <span class="n">dump</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>El comando <code>disassemble</code> defaultea a mostrar las instrucciones en la sintaxis de AT&amp;T, que es la misma sintaxis usada por el assembler de GNU<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>. Las instrucciones en la sintaxis AT&amp;T son del formato <code>mnemónico origen, destino</code>. El mnemónico es el nombre <em>humanamente legible</em><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> de la instrucción. <code>origen</code> y <code>destino</code> son operandos, que pueden ser valores inmediatos, registros, direcciones de memoria o etiquetas. Los valores inmediatos son constantes, y están prefijados por un <code>$</code>. Por ejemplo, <code>$0x5</code> representa al número 5 en hexadecimal. Los nombres de registros están prefijados por un <code>%</code>.</p>

<h3>Registros</h3>

<p>Vale la pena dedicarle un ratito a entender los registros. Los registros son porciones de almacenamiento de datos que se encuentran directamente en el CPU. Salvo algunas excepciones, el tamaño, o <em>ancho</em>, de los registros de una CPU definen su arquitectura. Entonces, si tenés una CPU de 64 bits, tus registros van a medir 64 bits. Lo mismo ocurre con las CPUs de 32 bits (registros de 32 bits), 16 bits, y así<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>. Los registros son de muy rápido acceso, y en general son los operandos de las operaciones aritméticas y lógicas.</p>

<p>La familia x86 tiene registros de propósito general y de propósito específico. Los de propósito general pueden usarse para cualquier operación, y su valor no tiene un significado especial para la CPU. En cambio, la CPU depende de ciertos registros de propósito específico para su propia operación, y los valores que en ellos se almacenan tienen un significado especial según el registro de que se trate. En nuestro ejemplo anterior, <code>%eax</code> y <code>%ecx</code> son registros de propósito general, mientras que <code>%rbp</code> y <code>%rsp</code> son de propósito específico. <code>%rbp</code> es el <em>base pointer</em> (puntero base), que apunta a la base del marco actual dentro del stack (<em>current stack frame</em>), y <code>%rsp</code> es el <em>stack pointer</em> (puntero al stack), que apunta al tope del stack frame actual. <code>%rbp</code> siempre tiene un valor mayor a <code>%rsp</code> porque el stack comienza en una dirección de memoria alta y crece hacia abajo. Si no te es muy familiar el concepto de stack de llamadas, podés encontrar <a href="http://en.wikipedia.org/wiki/Call_stack">una buena introducción en Wikipedia</a> (y <a href="http://es.wikipedia.org/wiki/Pila_de_llamadas">acá en español</a>).</p>

<p>Un detalle de la familia x86 es que mantuvo compatibilidad hacia atrás desde el procesador 8086, de 16 bits. A medida que el x86 avanzó de 16 bits a 32, y de 32 a 64, los registros se expandieron y fueron tomando nuevos nombres, de modo de no romper la compatibilidad con código escrito para CPUs anteriores, menos anchos.</p>

<p>Tomemos de ejemplo al registro <code>AX</code> de propósito general, de 16 bits. El byte <em>alto</em> puede accederse con el nombre <code>AH</code> (<em>A High</em>), y el bajo con <code>AL</code> (<em>A Low</em>). Cuando salió el 80386, de 32 bits, el registro AX Extendido (<em>Extended AX</em>, <code>EAX</code>) refirió al registro de 32 bits, mientras que <code>AX</code> se siguió refiriendo al registro formado por los 16 bits de la mitad baja del <code>EAX</code>. Del mismo modo, al salir la arquitectura x86_64, se usó el prefijo <code>R</code>, y el <code>EAX</code> pasó a ser la mitad baja del registro <code>RAX</code>, de 64 bits. Este es un diagrama basado en un <a href="http://en.wikipedia.org/wiki/X86#x86_registers">artículo de Wikipedia</a> para visualizar estas relaciones:</p>

<figure class='code'><figcaption><span>Subdivisiones de los registros en x86_64 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>|__64__|__56__|__48__|__40__|__32__|__24__|__16__|__8___|
</span><span class='line'>|__________________________RAX__________________________|
</span><span class='line'>|xxxxxxxxxxxxxxxxxxxxxxxxxxx|____________EAX____________|
</span><span class='line'>|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|_____AX______|
</span><span class='line'>|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|__AH__|__AL__|</span></code></pre></td></tr></table></div></figure>


<h3>Volviendo al código</h3>

<p>Ya deberíamos tener información suficiente para entender nuestro programa desensamblado:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="mh">0x0000000100000f50</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">0</span><span class="o">&gt;:</span>    <span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="mh">0x0000000100000f51</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;:</span>    <span class="n">mov</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
</span></code></pre></td></tr></table></div></figure>


<p>Las primeras dos instrucciones se llaman el <em>prólogo</em> o <em>preámbulo</em> de una función. Primero <code>push</code>eamos el antiguo base pointer al stack para guardarlo para más tarde. Después copiamos el valor del stack pointer al base pointer. Después de esto, <code>%rbp</code> apunta a la base del stack frame de <code>main</code>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="mh">0x0000000100000f54</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">4</span><span class="o">&gt;:</span>    <span class="n">mov</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span></code></pre></td></tr></table></div></figure>


<p>Esta instrucción copia un 0 a <code>%eax</code>. La convención de llamadas (<em>calling convention</em>) del x86 dice que el valor de retorno de una función debe almacenarse en <code>%eax</code>, de modo que esta instrucción prepara el <code>return 0</code> al final de nuestra función.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="mh">0x0000000100000f59</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">9</span><span class="o">&gt;:</span>    <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Acá vemos algo que no habíamos visto antes: <code>-0x4(%rbp)</code>. Los paréntesis nos indican que eso es una dirección de memoria. En este caso, <code>%rbp</code> es el registro base, y <code>-0x4</code> es el desplazamiento. Esto es equivalente a <code>%rbp + -0x4</code>. Como el stack crece hacia abajo, restarle 4 a la base del stack frame actual nos mueve dentro del frame mismo, donde se almacenan las variables locales. Esto significa que esta instrucción almacena un 0 en <code>%rbp - 4</code>. Me llevó un rato entender para qué era esta línea, pero parece que clang <a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2012-February/019767.html">reserva una variable local oculta</a> para un valor de retorno implícito de <code>main</code>.</p>

<p>También habrás notado que el mnemónico tiene el sufijo <code>l</code>. Esto significa que los operandos van a ser de tipo <code>l</code>ong (32 bits, para los enteros). Otros sufijos válidos son <code>b</code>yte, <code>s</code>hort, <code>q</code>uad y <code>t</code>en. Si ves una instrucción que no tiene un sufijo, el tamaño de los operandos se infiere de los tamaños de los registros origen y destino. Por ejemplo, en la línea anterior, <code>%eax</code> mide 32 bits, por lo que la instrucción <code>mov</code> se infiere a <code>movl</code>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="mh">0x0000000100000f60</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">16</span><span class="o">&gt;:</span>   <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x5</span><span class="p">,</span><span class="o">-</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>¡Ahora estamos llegando a la papa de nuestro programa! Esta primer línea de assembler es la primera línea de C en <code>main</code>, y almacena el número 5 en el espacio de la próxima variable local (<code>%rbp - 0x8</code>), 4 bytes debajo de nuestra última variable local. Esa es la posición de <code>a</code>. Podemos usar GDB para verificarlo:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">a</span>
</span><span class='line'><span class="mh">0x7fff5fbff768</span><span class="o">:</span> <span class="mh">0x00000005</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span> <span class="err">$</span><span class="n">rbp</span> <span class="o">-</span> <span class="mi">8</span>
</span><span class='line'><span class="mh">0x7fff5fbff768</span><span class="o">:</span> <span class="mh">0x00000005</span>
</span></code></pre></td></tr></table></div></figure>


<p>Fijate que las direcciones de memoria son las mismas. Vas a notar que GDB tiene variables que representan nuestros registros, pero como todas las variables en GDB, las prefijamos con <code>$</code> en vez del <code>%</code> usado en el assembler de AT&amp;T.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="mh">0x0000000100000f67</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">23</span><span class="o">&gt;:</span>   <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">ecx</span>
</span><span class='line'><span class="mh">0x0000000100000f6a</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">26</span><span class="o">&gt;:</span>   <span class="n">add</span>    <span class="err">$</span><span class="mh">0x6</span><span class="p">,</span><span class="o">%</span><span class="n">ecx</span>
</span><span class='line'><span class="mh">0x0000000100000f70</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">32</span><span class="o">&gt;:</span>   <span class="n">mov</span>    <span class="o">%</span><span class="n">ecx</span><span class="p">,</span><span class="o">-</span><span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Entonces movemos (<code>mov</code>) <code>a</code> a <code>%ecx</code>, uno de nuestros registros de propósito general, le sumamos (<code>add</code>) 6, y almacenamos el resultado en <code>%rbp - 0xc</code>. Esta es la segunda línea de C en <code>main</code>. Quizá te diste cuenta que <code>%rbp - 0xc</code> es <code>b</code>, cosa que podemos verificar en GDB:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">b</span>
</span><span class='line'><span class="mh">0x7fff5fbff764</span><span class="o">:</span> <span class="mh">0x0000000b</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span> <span class="err">$</span><span class="n">rbp</span> <span class="o">-</span> <span class="mh">0xc</span>
</span><span class='line'><span class="mh">0x7fff5fbff764</span><span class="o">:</span> <span class="mh">0x0000000b</span>
</span></code></pre></td></tr></table></div></figure>


<p>El resto de <code>main</code> es simplemente limpieza, llamado el <em>epílogo</em> de la función:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="mh">0x0000000100000f73</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">35</span><span class="o">&gt;:</span>   <span class="n">pop</span>    <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="mh">0x0000000100000f74</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">36</span><span class="o">&gt;:</span>   <span class="n">retq</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>pop</code>eamos el viejo base pointer del stack y lo devolvemos al <code>%rbp</code>, y luego <code>retq</code> nos devuelve a nuestra dirección de retorno, que también está almacenada en el stack frame.</p>

<p>Hasta ahora, usamos GDB para desensamblar un pequeño programa C, le pegamos un vistazo a cómo leer la sintaxis de assembler de AT&amp;T, y hablamos un poco de los operandos de registros y direcciones de memoria. También usamos GDB para verificar dónde se almacenan nuestras variables locales en relación a <code>%rbp</code>. Ahora vamos a ver cómo usar nuestras nuevas habilidades para explicar cómo funcionan las variables locales estáticas.</p>

<h2>Entendiendo las variables estáticas locales</h2>

<p>Las variables estáticas locales son una característica muy copada de C. En dos palabras, son variables locales que se inicializan una única vez y persisten sus valores a través de las sucesivas llamadas a la función en que fueron definidas. Un caso de uso bastante simple de las variables estáticas locales es un generador <em>à la</em> Python. Este ejemplo genera todos los números naturales hasta <code>INT_MAX</code>:</p>

<figure class='code'><figcaption><span>static.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* static.c */</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">natural_generator</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">natural_generator</span><span class="p">());</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">natural_generator</span><span class="p">());</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">natural_generator</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cuando lo compilamos y ejecutamos, este programa imprime los primeros tres números naturales:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ CFLAGS</span><span class="o">=</span><span class="s2">&quot;-g -O0&quot;</span> make static
</span><span class='line'>cc -g -O0    static.c   -o static
</span><span class='line'><span class="nv">$ </span>./static
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span></code></pre></td></tr></table></div></figure>


<p>Pero, ¿cómo funciona esto? Para entender las estáticas locales, vamos a meternos en GDB y mirar el assembler. Saqué las direcciones que muestra GDB al desensamblado para que entre en la pantalla:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="err">$</span> <span class="n">gdb</span> <span class="k">static</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="k">break</span> <span class="n">natural_generator</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">run</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">disassemble</span>
</span><span class='line'><span class="n">Dump</span> <span class="n">of</span> <span class="n">assembler</span> <span class="n">code</span> <span class="k">for</span> <span class="n">function</span> <span class="n">natural_generator</span><span class="o">:</span>
</span><span class='line'><span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="n">mov</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="n">movl</span>   <span class="err">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span><span class='line'><span class="n">mov</span>    <span class="mh">0x177</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>        <span class="err">#</span> <span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">add</span>    <span class="err">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'><span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="mh">0x16c</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>        <span class="err">#</span> <span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">mov</span>    <span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'><span class="n">add</span>    <span class="mh">0x163</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>        <span class="err">#</span> <span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">pop</span>    <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="n">retq</span>
</span><span class='line'><span class="n">End</span> <span class="n">of</span> <span class="n">assembler</span> <span class="n">dump</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lo primero que necesitamos descubrir es en qué instrucción estamos. Podemos hacer eso examinando el &ldquo;instruction pointer&rdquo; (<em>puntero de instrucción</em>) o &ldquo;program counter&rdquo; (<em>contador de programa</em>). El instruction pointer es un registro que almacena la dirección de memoria de la próxima instrucción. En x86_64, ese registro es <code>%rip</code>. Podemos acceder al instruction pointer usando la variable <code>$rip</code>, o podemos usar <code>$pc</code>, la alternativa independiente de la plataforma:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="n">i</span> <span class="err">$</span><span class="n">pc</span>
</span><span class='line'><span class="mh">0x100000e94</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="o">+</span><span class="mi">4</span><span class="o">&gt;:</span>  <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>El instruction pointer siempre contiene la dirección de la <em>próxima</em> instrucción a ejecutar, lo que significa que la tercer instrucción aún no se ejecutó, pero está a punto.</p>

<p>Como es bastante útil conocer la próxima instrucción, vamos a hacer que GDB nos muestre la próxima instrucción cada vez que frenamos el programa. A partir de GDB 7.0, podés ejecutar <code>set disassemble-next-line on</code>, que muestra todas las instrucciones que conforman la próxima instrucción fuente, pero estamos usando Mac OS X, que trae GDB 6.3, así que vamos a tener que recurrir al comando <code>display</code>. <code>display</code> es como <code>x</code>, sólo que evalúa la expresión cada vez que nuestro programa se detiene:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">display</span><span class="o">/</span><span class="n">i</span> <span class="err">$</span><span class="n">pc</span>
</span><span class='line'><span class="mi">1</span><span class="o">:</span> <span class="n">x</span><span class="o">/</span><span class="n">i</span> <span class="err">$</span><span class="n">pc</span>  <span class="mh">0x100000e94</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="o">+</span><span class="mi">4</span><span class="o">&gt;:</span>  <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ahora GDB está listo para mostrarnos siempre la próxima instrucción a ejecutar antes del prompt.</p>

<p>Ya pasamos el prólogo de la función, del que hablamos antes, así que vamos a empezar en la tercer instrucción. Esto corresponde a la primer línea de código que asigna 1 a <code>a</code>. En lugar de <code>next</code>, que nos mueve a la próxima instrucción fuente, vamos a usar <code>nexti</code>, que nos mueve a la próxima instrucción assembler. Después, vamos a examinar <code>%rbp - 0x4</code> para verificar nuestra hipótesis de que <code>a</code> se almacena en <code>%rbp - 0x4</code>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">nexti</span>
</span><span class='line'><span class="mi">7</span>           <span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="mi">1</span><span class="o">:</span> <span class="n">x</span><span class="o">/</span><span class="n">i</span> <span class="err">$</span><span class="n">pc</span>  <span class="n">mov</span>   <span class="mh">0x177</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span> <span class="err">#</span> <span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span> <span class="err">$</span><span class="n">rbp</span> <span class="o">-</span> <span class="mh">0x4</span>
</span><span class='line'><span class="mh">0x7fff5fbff78c</span><span class="o">:</span> <span class="mh">0x00000001</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">a</span>
</span><span class='line'><span class="mh">0x7fff5fbff78c</span><span class="o">:</span> <span class="mh">0x00000001</span>
</span></code></pre></td></tr></table></div></figure>


<p>Son lo mismo, tal como esperábamos. La próxima instrucción es más interesante:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="n">mov</span>    <span class="mh">0x177</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>        <span class="err">#</span> <span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Acá es donde esperaríamos encontrar la línea <code>static int b = -1;</code>, pero se ve substancialmente distinta de cualquier otra cosa que hayamos visto antes. Por empezar, no hay referencia al stack frame, donde esperaríamos encontrar las variables locales. ¡Ni siquiera hay un <code>-0x1</code>! En cambio, tenemos una instrucción que carga <code>0x100001018</code>, ubicada en algún lugar después del instruction pointer, a <code>%eax</code>. GDB nos da un comentario bastante útil con el resultado del cálculo del operando en memoria, y nos da una pista diciéndonos que <code>natural_generator.b</code> se encuentra en esa dirección. Corramos esta instrucción y veamos qué pasa:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">nexti</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="err">$</span><span class="n">rax</span>
</span><span class='line'><span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="mi">4294967295</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span><span class="o">/</span><span class="n">x</span> <span class="err">$</span><span class="n">rax</span>
</span><span class='line'><span class="err">$</span><span class="mi">5</span> <span class="o">=</span> <span class="mh">0xffffffff</span>
</span></code></pre></td></tr></table></div></figure>


<p>Por más que el desensamblado muestre <code>%eax</code> como destino, nosotros imprimimos <code>$rax</code>, porque GDB sólo nos provee variables para los registros completos.</p>

<p>En este momento necesitamos recordar que, mientras que las variables tienen tipos que especifican si son signadas o no, los registros no, por lo que GDB imprime el valor de <code>%rax</code> sin signo. Probemos de nuevo, casteando <code>%rax</code> a un <code>int</code> signado:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="err">$</span><span class="n">rax</span>
</span><span class='line'><span class="err">$</span><span class="mi">11</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Parece que encontramos a <code>b</code>. Podemos re-chequear esto usando el comando <code>x</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="n">d</span> <span class="mh">0x100001018</span>
</span><span class='line'><span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;:</span>  <span class="o">-</span><span class="mi">1</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="n">d</span> <span class="o">&amp;</span><span class="n">b</span>
</span><span class='line'><span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;:</span>  <span class="o">-</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Entonces, no es sólo que <code>b</code> está en una dirección de memoria baja, fuera del stack, si no que además se la inicializa a -1 antes de que se llame a <code>natural_generator</code>. De hecho, incluso si desensamblaras el programa completo, no encontrarías ningún código que setteara <code>b</code> a -1. Esto ocurre porque el valor de <code>b</code> se hardcodea en otra sección del ejecutable <code>sample</code>, y el loader del sistema operativo lo carga en memoria junto con todo el código de máquina cuando se lanza el proceso<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>.</p>

<p>Después de todo esto, las cosas empiezan a tener más sentido. Tras almacenar <code>b</code> en <code>%eax</code>, pasamos a la próxima instrucción fuente, en la que incrementamos <code>b</code>. Esto se corresponde a las próximas dos instrucciones:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="n">add</span>    <span class="err">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'><span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="mh">0x16c</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>        <span class="err">#</span> <span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Acá le agregamos (<code>add</code>) 1 a <code>%eax</code>, y almacenamos el resultado en la memoria. Corramos estas instrucciones y verifiquemos el resultado:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">nexti</span> <span class="mi">2</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="n">d</span> <span class="o">&amp;</span><span class="n">b</span>
</span><span class='line'><span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;:</span>  <span class="mi">0</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="err">$</span><span class="n">rax</span>
</span><span class='line'><span class="err">$</span><span class="mi">15</span> <span class="o">=</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>Las próximas dos instrucciones nos preparan para devolver <code>a + b</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="n">mov</span>    <span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'><span class="n">add</span>    <span class="mh">0x163</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>        <span class="err">#</span> <span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Acá cargamos <code>a</code> en <code>%eax</code>, y luego le sumamos <code>b</code>. En este punto, esperaríamos que <code>%eax</code> valga 1. Verifiquemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">nexti</span> <span class="mi">2</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="err">$</span><span class="n">rax</span>
</span><span class='line'><span class="err">$</span><span class="mi">16</span> <span class="o">=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se usa <code>%eax</code> para almacenar el valor de retorno de <code>natural_generator</code>, así que estamos listos para el epílogo, que limpia el stack y retorna:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="n">pop</span>    <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'><span class="n">retq</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ahora que entendemos cómo se inicializa <code>b</code>, veamos qué pasa cuando corremos <code>natural_generator</code> otra vez:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c-objdump'><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="k">continue</span>
</span><span class='line'><span class="n">Continuing</span><span class="p">.</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'>
</span><span class='line'><span class="n">Breakpoint</span> <span class="mi">1</span><span class="p">,</span> <span class="n">natural_generator</span> <span class="p">()</span> <span class="n">at</span> <span class="k">static</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">5</span>
</span><span class='line'><span class="mi">5</span>           <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="mi">1</span><span class="o">:</span> <span class="n">x</span><span class="o">/</span><span class="n">i</span> <span class="err">$</span><span class="n">pc</span>  <span class="mh">0x100000e94</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="o">+</span><span class="mi">4</span><span class="o">&gt;:</span>  <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">b</span>
</span><span class='line'><span class="mh">0x100001018</span> <span class="o">&lt;</span><span class="n">natural_generator</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;:</span>  <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como <code>b</code> no está almacenada en el stack junto con las otras variables locales, al volver a llamar a <code>natural_generator</code> sigue valiendo 0. No importa cuántas veces llamemos a nuestro generador, <code>b</code> siempre va a retener su valor. Esto ocurre porque está almacenada fuera del stack, y es inicializada cuando el loader mueve el programa a memoria en lugar de por nuestor código máquina.</p>

<h2>Conclusión</h2>

<p>Comenzamos viendo cómo leer assembler y cómo desensamblar un programa con GDB. Luego, vimos cómo funcionan las variables estáticas locales, cosa que no podríamos haber hecho sin desensamblar nuestro ejecutable.</p>

<p>Pasamos mucho tiempo alternando entre leer instrucciones assembler y verificando nuestras hipótesis en GDB. Puede parecer repetitivo, pero hay una razón muy importante para hacerlo así: la mejor manera de aprender algo abstracto es volverlo más concreto, y una de las mejores maneras de hacer más concreto a algo es usando herramientas que te dejen sacarle capas de abstracción. La mejor manera de aprender estas herramientas es forzándote a usarlas hasta que te sean naturales.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><strong>NdeT</strong>: Lo de que es en OS X no es porque me haga el careta usando Mac, si no porque el post original estaba así, y todavía no tengo la sopa/tiempo/ganas de hacer todo lo mismo pero en Linux con <code>gcc</code> :)<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Tal vez notes que usamos Make para buildear <code>simple.c</code> sin un makefile. Podemos hacerlo porque Make tiene reglas implícitas para buildear ejecutables a partir de archivos C. Podés encontrar más información sobre esas reglas en el <a href="http://www.gnu.org/software/make/manual/make.html#Implicit-Rules">manual de Make</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>También podés hacer que GDB muestre la sintaxis de Intel, usada por NASM, MASM y otros assemblers, pero eso se va del alcance del post.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><strong>NdeT</strong>: Con <em>humanamente legible</em> quiere decir <em><strong>Joaco</strong>-humanamente legible</em>, pero bue&hellip;<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Los procesadores con sets de instrucciones SIMD (como MMX y SSE para x86, y AltiVec para PowerPC) suelen tener algunos registros que son más anchos que la arquitectura de la CPU.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>Reservamos para un post futuro la discusión sobre formatos de objeto, loaders y linkers.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Between a rock and a hard link]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/07/between-a-rock-and-a-hard-link/"/>
    <updated>2015-02-07T11:47:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/07/between-a-rock-and-a-hard-link</id>
    <content type="html"><![CDATA[<blockquote><p>¿Qué es un hard link? ¿Qué es un soft link? ¿Qué diferencia hay entre ellos?</p></blockquote>


<p>Me parece que la clave para entender los enlaces en los filesystems basados en inodos<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> es entender <em>qué es un archivo</em>.<!--more--></p>

<h2>Archivos y directorios</h2>

<p>Un archivo está compuesto por dos partes: su contenido (<em>los bloques de datos</em>) y su metadata (<em>el inodo</em>).</p>

<p>Cuando creo un archivo llamado <code>miarchivo.txt</code> cuyo único contenido es <code>hola</code> (con, por ejemplo, el comando <code>echo hola &gt; miarchivo.txt</code>), en mi FS se reserva un bloque de datos en el que se escriben los 5 bytes <code>hola\n</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, y además se reserva un inodo que se marca como ocupado, en el que se especifica que el contenido del archivo mide 5 bytes, y se establece en el primer puntero del inodo que el primer bloque de datos es el que acabamos de reservar. Se ponen más datos, obviamente, pero por ahora no nos importan.</p>

<p>Y con eso tenemos un archivo, pero nos falta algo importante: referenciarlo. Ese archivo <strong>no tiene nombre</strong>. <em>El inodo no guarda el nombre del archivo</em>. Y yo nunca le pido al sistema operativo que me abra el archivo del inodo 5236: yo le pido rutas. Y una ruta está formada por una lista de directorios, y el nombre del archivo al final.</p>

<p>El nombre existe en el directorio.</p>

<p>Un directorio es un archivo cuyo contenido es una tabla. Cada entrada de esa tabla (las <em>entradas de directorios</em>) relaciona un nombre de archivo con un número de inodo. Al querer abrir un archivo (digamos, <code>miarchivo.txt</code>), el FS busca en esa tabla la entrada con ese nombre, y mira cuál es el número de inodo que le corresponde (digamos, <code>402</code>), y hace todas las operaciones usando ese inodo. Siguiendo el ejemplo, si quisieramos leer todo el archivo <code>miarchivo.txt</code> (<code>cat miarchivo.txt</code>), el FS encuentra la entrada de directorio de ese archivo, lee que le corresponde el inodo 402, abre el inodo 402, mira que mide 5 bytes, busca cuál es el primer bloque de datos, lee los primeros 5 bytes de ese bloque de datos y se los devuelve a <code>cat</code>, que se encarga de imprimirlos por pantalla.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cat miarchivo.txt
</span><span class='line'>hola
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Hard links</h2>

<p>Ahora, ¿qué me impide tener otra entrada de directorio que apunte al inodo 402? En el inodo no hay ninguna referencia del estilo <code>directorioPadre</code> ni nada por el estilo. Tranquilamente podría crear una nueva entrada en ese directorio (o en otro, es indistinto<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>) que apunte al mismo inodo. Asumamos que creamos una entrada para el nombre <code>passwords.txt</code>, que también apunta al inodo 402.</p>

<p>¿Qué va a ocurrir cuando quiera leer el archivo <code>passwords.txt</code> haciendo <code>cat passwords.txt</code>? Esto:</p>

<blockquote><p>el FS encuentra la entrada de directorio de ese archivo, lee que le corresponde el inodo 402, abre el inodo 402, mira que mide 5 bytes, busca cuál es el primer bloque de datos, lee los primeros 5 bytes de ese bloque de datos y se los devuelve a `cat`, que se encarga de imprimirlos por pantalla.</p></blockquote>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cat passwords.txt
</span><span class='line'>hola
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Exactamente lo mismo que hace un rato, porque, a partir de que encontró que el inodo es el 402, el resto va todo igual: el inodo es lo que representa a nuestro archivo en el FS.</p>

<p>Y si quisiera agregarle contenido a <code>miarchivo.txt</code>, ¿qué pasaría? Ejecuto <code>echo clave123 &gt;&gt; miarchivo.txt</code>, y entonces el FS busca la entrada correspondiente a <code>miarchivo.txt</code>, encuentra que corresponde al inodo 402, va al inodo 402, ve que mide 5 bytes y que si le agrega los 9 bytes correspondientes a <code>clave123\n</code> sigue entrando en el primer bloque de datos, entonces abre el primer bloque de datos, y a partir del sexto byte escribe ese contenido. Por último, anota en el inodo que el archivo ahora pesa 14 bytes, cierra el archivo, y todos felices. Si ahora hacemos <code>cat miarchivo.txt</code>, encuentra la entrada de directorio<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>, abre el inodo 402, abre el bloque de datos, lee los 14 bytes, se los devuelve a <code>cat</code>, y <code>cat</code> los imprime por pantalla.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cat miarchivo.txt
</span><span class='line'>hola
</span><span class='line'>clave123
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>¿Y si ahora leo el contenido de <code>passwords.txt</code>? Bueno, <em>leo la entrada de directorio de <code>passwords.txt</code>, veo que es el inodo 402, abro el inodo, veo que mide 14 bytes, abro el primer bloque de datos, leo los 14 bytes, y se los devuelvo a <code>cat</code> para que los imprima en pantalla</em>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cat passwords.txt
</span><span class='line'>hola
</span><span class='line'>clave123
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Las dos entradas de directorio referencian al mismo archivo</strong>. Lo que <em>escribo en un archivo se ve reflejado en el otro</em>, pero porque <strong>es mentira que sean dos archivos</strong>: <em>son el mismo</em>. Son <em>dos referencias al mismo objeto</em>.</p>

<p>Ahora bien, podemos mirar por la consola que esos dos archivos referencian al mismo inodo. La clave está en el switch <code>-i</code> del comando <code>ls</code>, que acá vamos a usar junto con el <code>-1</code> para ver un archivo por línea:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -i1
</span><span class='line'>402 miarchivo.txt
</span><span class='line'>402 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ambas entradas referencian al inodo 402.</p>

<p><strong>Ese es el concepto de hard link</strong>: varias entradas de directorio referenciando al mismo inodo. <em>Varias referencias al mismo archivo</em>.</p>

<p>Pero es interesante que, a partir del momento en que se crea el hard link, ya no existe <em>el archivo</em> y <em>el hard link</em>: el archivo es el inodo, y todas las referencias a inodos son hardlinks. O sea, técnicamente hablando, <em>todas las entradas de directorios son hard links</em>, pero coloquialmente hablando nos referimos a hard links en el momento en que hay más de una entrada refiriendo a ese inodo. Pero es importante tener siempre presente que, a partir de que se crea el hard link (es decir, que se crea la segunda entrada apuntando al mismo inodo), ya no hay diferencia entre la referencia original y la nueva: podríamos borrar <code>miarchivo.txt</code>, y <code>passwords.txt</code> seguiría existiendo y apuntando al mismo contenido. Podríamos crear un tercer hard link, borrar los dos anteriores, y el inodo seguiría siendo el mismo, con el mismo contenido.</p>

<p>Y, ya que estamos, ¿qué pasa si borro un hard link? ¿Cómo se cuándo liberar el inodo y los bloques de datos? Para eliminar un archivo, siempre uso el mismo comando: <code>rm</code>. Y no tengo que especificarle yo si es el último hard link o no, o si liberar o no el inodo: es el FS el que decide eso.</p>

<p>Para eso, el FS usa una técnica llamada <a href="http://en.wikipedia.org/wiki/Reference_counting">reference counting</a><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> (conteo de referencias). El inodo tiene un campo en el que se cuenta la cantidad de referencias que hay hacia él en el file system. Al crear un archivo, ese contador arranca en 1 (porque hay una única entrada de directorio que lo apunta), cuando se crea un hard link se aumenta en 1, y cuando se elimina una entrada (<em>se elimina un hard link</em>) se decrementa en 1. Si ese contador llega a 0, el FS libera el inodo y los bloques de datos asociados. De este modo, en el caso de <code>miarchivo.txt</code>, el inodo 402 arrancó con el contador de links en 1, y cuando creamos el hard link <code>passwords.txt</code> pasó a 2. Si ahora borramos alguno de los dos (es indistinto cuál, digamos que hacemos <code>rm miarchivo.txt</code>), se borra la entrada de directorio correspondiente y se decrementa en uno el contador de links del inodo 402, pasando a 1. Si borramos el link que quedaba (<code>rm passwords.txt</code>), el contador de links del inodo 402 pasa a 0, y ahí el FS libera ese inodo y el bloque de datos asociado.</p>

<p>Podemos ver la cantidad de hard links usando <code>ls -l</code> (o combinarlo con <code>-i</code> para ver también el número de inodo):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 2
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Esos <code>2</code> que vemos entre los permisos y el owner del archivo es el contador de hard links. Creemos un archivo cualquiera para ver que tiene un único link:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>touch vacio
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 3
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'>406 -rw-r--r--+ 1 mgarcia staff 14 Feb 7 13:27 vacio
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Borremos tanto a <code>vacio</code> como a <code>miarchivo.txt</code> para ver que no les mentí<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rm miarchivo.txt vacio
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 1
</span><span class='line'>402 -rw-r--r--+ 1 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si borrara <code>passwords.txt</code>, recién ahí se liberaría el inodo 402.</p>

<p>Por último, un detalle de los hard links: toda la relación que existe entre la entrada de directorio y el inodo es el número de inodo. Debido a esto, los hard links sólo pueden realizarse <em>intra-filesystem</em>, es decir, el archivo destino y el directorio que contiene al nuevo link <strong>deben</strong> estar dentro del mismo file system<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>. Porque si no, ¿al inodo 402 de qué file system se refiere la entrada? ¿Qué garantías tengo de que el otro filesystem también maneje inodos? Por ese motivo, los hard links son intra-FS.</p>

<p>Y, algo que nos faltaba: ¿con qué creamos el hard link? Con el comando <code>ln</code>:</p>

<figure class='code'><figcaption><span>Esto es lo que ejecuté (hace un rato) para crear passwords.txt </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 1
</span><span class='line'>402 -rw-r--r--+ 1 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'><span class="nv">$ </span>ln miarchivo.txt passwords.txt
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 2
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Soft links</h2>

<p>Ahora bien, ¿ya está? Si quiero hacer un enlace a otro FS, ¿<a href="https://youtu.be/Pj1Hgw75V1w">estoy en el horno</a>? Nops: para eso hicieron los soft links :)</p>

<p>Un softlink<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> es un <strong>archivo nuevo</strong> que referencia a otra ruta. Creemos uno:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 2
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="nv">$ </span>ln -s miarchivo.txt blandito
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 3
</span><span class='line'>415 lrwxr-xr-x  1 mgarcia staff 14 Feb 7 13:46 blandito -&gt; miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Por lo pronto, para crear un soft link le pasamos el parámetro <code>-s</code> a <code>ln</code>. Por otro lado, vemos que se creó una nueva entrada de directorio llamada <code>blandito</code><sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>, <strong>que tiene su propio inodo</strong>. Es decir, es un archivo completamente separado de los otros. De hecho, tiene sus propios atributos: la <code>l</code> que vemos al principio es la que indica que ese archivo es un softlink. También vemos que el contador de links está en 1, porque, claro, este inodo (el 415) está referenciado únicamente por la entrada de directorio <code>blandito</code>.</p>

<p>Y, si es un inodo aparte, ¿cómo referencia al otro archivo? Bueno, el FS sabe que los archivos con el atributo de enlace (la <code>l</code> esa que vimos en los permisos) son softlinks, y entonces sabe que tiene que tratarlos de manera especial: cuando le pidan leerlo (<code>cat blandito</code>), no va a hacer lo que hacía siempre (abrir el inodo referenciado &ndash; 415 &ndash;, leer su contenido y pasárselo a <code>cat</code>). Por ser un softlink, el contenido que está guardado en el bloque de datos no es el contenido del archivo, si no <strong>la ruta del archivo al que enlaza</strong><sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>. Entonces, al hacer <code>cat blandito</code> el FS abre el inodo 415, ve que es un softlink, lee el bloque de datos, ve que está guardada la ruta <code>miarchivo.txt</code>, y entonces, ahora sí, busca la entrada <code>miarchivo.txt</code>, abre el inodo correspondiente (el viejo y conocido 402), lee el bloque de datos, etc.</p>

<p>¿Se ve la diferencia? <strong>El contenido del softlink dice cuál es el path del archivo al que uno realmente quiere acceder.</strong> Esto es lo que le permite ser cross-FS: el link se puede hacer a, no se, <code>/mount/DVD/autorun.inf</code>, que sea otro FS, y no hay ningún problema: el identificador ya no es el número de inodo, y por eso puede ir a otros FS.</p>

<p>Del <code>ls</code> que hicimos después de crear el softlink tenemos que notar otro detalle: el link count del inodo 402 sigue en 2, <strong>no aumentó a 3</strong>. Esto significa que <strong>el archivo <em>apuntado</em> no se entera de que hay un softlink que lo enlaza</strong>.</p>

<p>El hecho de que el enlace esté hecho a nivel <em>ruta</em> (y no <em>inodo</em>) implica que puedo tener lo que se conoce como <em>enlaces rotos</em>: links que apuntan a archivos que no  existen [más]. Por ejemplo, ¿qué pasa si eliminamos <code>miarchivo.txt</code>? <code>blandito</code> sigue referenciando a un archivo llamado <code>miarchivo.txt</code>, pero ese archivo ya no existe, así que cualquier operación sobre el link va a fallar. No importa que siga existiendo <code>passwords.txt</code>, que sigue apuntando al inodo 402: el link funciona a nivel de paths. Lo mismo ocurre si renombro el archivo <code>miarchivo.txt</code>, o si pongo un archivo distinto llamado <code>miarchivo.txt</code>: el enlace apunta a <em>lo que sea que haya</em> en la ruta <code>miarchivo.txt</code>.</p>

<p>Existe un comando (más <em>low level</em><sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup> que <code>ls -l</code>) para leer el <em>destino</em> de un softlink: <code>readlink</code>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>readlink blandito
</span><span class='line'>miarchivo.txt
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rompamos el enlace:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>mv miarchivo.txt archivo.txt
</span><span class='line'><span class="nv">$ </span>ls -li
</span><span class='line'>total 3
</span><span class='line'>415 lrwxr-xr-x  1 mgarcia staff 14 Feb 7 13:46 blandito -&gt; miarchivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 archivo.txt
</span><span class='line'>402 -rw-r--r--+ 2 mgarcia staff 14 Feb 7 11:53 passwords.txt
</span><span class='line'><span class="nv">$ </span>cat blandito
</span><span class='line'>cat: blandito: No such file or directory
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s it :)</p>

<h2>Windows</h2>

<p>Ok, hablemos (un poco, medio de mala gana, y bastante desde el desconocimiento) de Windows.</p>

<p>En FAT no existen la conceptos de soft ni hard links. NTFS los tiene.</p>

<p>Lo que sí existe en Windows desde antes de NTFS son los viejos y conocidos accesos directos.</p>

<p>¿Qué son los accesos directos?</p>

<p>Bueno, son archivos que están guardados en el file system, y que cuando los abro en realidad me abren otros archivos a los que &ldquo;apuntan&rdquo;.</p>

<p><em>¡ESO ES UN SOFTLINK! ¡AHHHHH IGNORANTE! ¡ME MENTISTE! ¡¡¿¿VISTE QUE SÍ EXISTÍAN??!! Te dije que este pibe era un talibán linuxero y que no puede contar objetivamente nada de Windows.</em></p>

<p>Sí, bueno, no&hellip; Son softlinks, pero leé de nuevo lo que puse: FAT no soporta symlinks; Windows lo soporta.</p>

<p>¿Y qué cambia? Bueno, cambia bastante. En Windows/FAT, los accesos directos los interpreta el shell (es decir, la interfaz de ventanitas que te deja hacer doble click sobre los archivos), y no el file system. Esto significa que, dependiendo de cómo interactúe cada aplicación con la API de Windows, al abrir un acceso directo podría leer el contenido del archivo destino o el del propio acceso directo. Tengo la sensación de que en las versiones nuevas<sup id="fnref:12"><a href="#fn:12" rel="footnote">12</a></sup> de Windows hicieron algunos cambios para que esto no pase, pero, por ejemplo, uno puede darle doble click a un acceso directo a un txt en Windows XP para abrir el archivo destino en notepad<sup id="fnref:13"><a href="#fn:13" rel="footnote">13</a></sup>, pero si abrimos notepad y hacemos drag&amp;drop del acceso directo vamos a ver un montón de chirimbolos horrendos que tienen codificada de algún modo extraño la ruta al destino<sup id="fnref:14"><a href="#fn:14" rel="footnote">14</a></sup>.</p>

<p><img src="http://mgarciaisaia.github.io/tutorial-c/assets/shortcut-windows-xp.gif" alt="Abriendo accesos directos con notepado en Windows XP" /></p>

<p>En Unix/ext, el propio sistema de archivos se encarga de resolver el enlace al abrir un softlink, por lo que siempre vemos el contenido del destino<sup id="fnref:15"><a href="#fn:15" rel="footnote">15</a></sup>.</p>

<h2>Links útiles</h2>

<ul>
<li><a href="http://teaching.idallen.com/dat2330/04f/notes/links_and_inodes.html">http://teaching.idallen.com/dat2330/04f/notes/links_and_inodes.html</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Existen los enlaces <del>en FAT</del> en Windows, pero funcionan a otro nivel, me disgustan, me caen mal <del>, y voy a ignorarlos rotundamente</del> :)<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Por defecto, <code>echo</code> imprime un salto de línea, y por eso el <code>\n</code> al final del contenido. Se puede evitar el <code>\n</code> final haciendo <code>echo -n</code>.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Sólo importa que sea dentro del mismo filesystem, ya veremos por qué.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>A esta altura ya te habrás imaginado que tiene bastante sentido aplicar algúna técnica de caché para las entradas de directorios, porque <em>se usan bastante seguido</em>, je :)<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Como dice el artículo de Wikipedia, la misma idea de reference counting se usa mucho en los garbage collectors de muchos lenguajes de programación de objetos.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>Que no les mentí <em>tanto</em>. Estoy inventando un poco esos outputs de los comandos, porque no los estoy corriendo realmente en la consola. Hago pruebas y lo fabrico, pero debería ser consistente.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>Sí, en el sistema operativo se pueden (y de hecho, se suelen) montar más de un sistema de archivos. Cuando metés un CD en la máquina, estás montando otro FS. Cuando tenés más de una partición disponible, estás montando más de un sistema de archivos. Incluso cuando tenés una partición de swap, estás montando otro sistema de archivos.<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>&ldquo;softlink&rdquo;, &ldquo;soft link&rdquo;, &ldquo;enlace dinámico&rdquo;, &ldquo;enlace <em>suave</em>&rdquo;, <em>you name it</em><a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p>Lo de <code>-&gt; miarchivo.txt</code> es información que agrega <code>ls</code> para ser <em>más usable</em>, pero esa información <strong>no está guardada en la entrada de directorio</strong>.<a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
<li id="fn:10">
<p>La enorme mayoría de las implementaciones de ext optimizan el uso de disco almacenando la ruta destino <em>en el inodo</em> en lugar de en un bloque de datos aparte (escribiéndola en la zona reservada para los punteros a bloques de datos). De hecho, <a href="http://www.nongnu.org/ext2-doc/ext2.html#DEF-SYMBOLIC-LINKS">la especificación de ext2 dice que ese es el modo de hacerlo</a> (digamos, no lo nombra como un opcional). De todos modos, esto es una optimización de espacio, y no hace diferencias importantes a la hora de entender el concepto del symlink.<a href="#fnref:10" rev="footnote">&#8617;</a></p></li>
<li id="fn:11">
<p>En general, trato de usar los comandos de UNIX más <em>cercanos</em> a las llamadas al sistema. <code>ls</code> hace <em>muchas</em> cosas, no existe una llamada al sistema <code>ls</code>, pero sí existe una llamada al sistema <a href="http://linux.die.net/man/2/readlink">readlink</a> (o quizá no se llame así, pero cumple esa tarea específica).<a href="#fnref:11" rev="footnote">&#8617;</a></p></li>
<li id="fn:12">
<p>Llamar &ldquo;nuevas&rdquo; a las que tienen menos de 15 años de antigüedad denota mi pasión por <a href="http://i.imgur.com/91sn32Q.jpg?fb">gritarle a las nubes</a><a href="#fnref:12" rev="footnote">&#8617;</a></p></li>
<li id="fn:13">
<p>Hice recién la misma prueba en Windows 8.1, y funcionó del mismo modo, pero no se por qué siento que alguna vez me pasó distinto.<a href="#fnref:13" rev="footnote">&#8617;</a></p></li>
<li id="fn:14">
<p>Y, obviamente, si usamos el programa <code>edit</code> desde la consola/CMD/DOS, peor todavía.<a href="#fnref:14" rev="footnote">&#8617;</a></p></li>
<li id="fn:15">
<p>Entiendo que uno podría modificar una implementación de ext para que muestre el contenido de los enlaces en lugar de resolverlos, recompilarla, instalarla y montar un FS con esa implementación, pero sería <em>llevar las cosas bastante al límite</em>, y, obviamente, dejaría de ser ext (porque ya no cumple con la especificación de cómo abrir los enlaces, je).<a href="#fnref:15" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[int vs int32_t]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/int-vs-int32-t/"/>
    <updated>2014-12-26T20:05:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/int-vs-int32-t</id>
    <content type="html"><![CDATA[<p><em>Este post es un laburo en conjunto que hicimos con <a href="http://github.com/micaelaoriolo">Micaela Oriolo</a>. Kudos para ella :)</em></p>

<blockquote><p>No entiendo qué pito tocan los uint32. ¿Cuándo hay que usarlos sí o sí?</p></blockquote>


<p>En la vida real, todo puede explotar. Entre las miles de causas del típico “en casa compila”, se encuentra el uso (o no uso, mejor dicho) de los tipos de datos que especifican su tamaño. En este caso, vamos a hablar del tipo de dato <code>int</code>.<!--more--></p>

<p>La definición que el estándar de C da sobre el <code>int</code> es muy vaga:</p>

<blockquote><p>A ‘plain’ int object has the natural size suggested by the architecture of the execution environment (large enough to contain any value in the range INT_MIN to INT_MAX as defined in the header <limits.h></p><footer><strong>ISO/IEC 9899:TC3</strong> <cite><a href='http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf'>6.2.5 - Types, P33</a></cite></footer></blockquote>


<p>Lo que nos importa ahora de esta definición es que dice que el <code>int</code> tiene el tamaño sugerido por la arquitectura del entorno de ejecución. Esto significa que, en arquitecturas de 32 bits, el <code>int</code> suele medir 32 bits, mientras que en arquitecturas de 64 bits el <code>int</code> puede medir 32 o 64 bits.</p>

<p>A simple vista, esto puede parecer molesto, pero tiene sus razones, una de las cuales es que el hecho de que los datos estén <em>alineados a la palabra del procesador</em> hace que las operaciones a nivel CPU sean más ágiles.</p>

<p>Si en tu programa declarás todas las variables como <code>int32_t</code> y alguien compila ese programa para correr en un procesador de, por ejemplo, 16 bits, ese procesador no va a estar muy feliz, porque cada operación que haga con esos <code>int32_t</code> implica 2 lecturas, incluso si lo único que querías hacer con esa variable es un for de 1 a 10.</p>

<p><em>Entonces, ¿qué hago? ¿cuándo uso <code>int</code> y cuándo <code>int32_t</code>?</em></p>

<p>Si lo que querés guardar en tu variable es un número, entonces no va a haber ningún problema porque, justamente, por eso de que el dato está alineado, va a andar bien y rápido. Pero, hay veces en las que necesitás tener garantía del tamaño. Por ejemplo, cuando se trata de direcciones de memoria, pero también cuando querés serializar datos para mandarlos de una computadora a la otra. Si serializás el <code>int</code> copiando <code>sizeof(int)</code> bytes y mandándolos, no sabés cuánto es <code>sizeof(int)</code> en la otra máquina. Si no coinciden, ¡pum!.</p>

<p>Para <em>estos casos</em> aparecen los tipos de datos que especifican su tamaño. Podemos distinguir dos enfoques distintos:</p>

<ul>
<li>Los tipos de datos <em>nativos</em> tienen un nombre muy declarativo, que te dice “yo soy un carácter, yo soy un número chiquito, yo soy un número normal, yo soy un número grande”</li>
<li>Los tipos de datos que especifican su tamaño, están muy ligados a la implementación: “yo mido 16 bits, yo mido 32, yo mido 64”.</li>
</ul>


<p><em>Todo muy lindo, pero&hellip; ¿cuál es la relación entre todo esto y el intervalo de números que soporta cada tipo de dato?</em></p>

<p>Bueno, siempre depende del tamaño del tipo de dato. Sin importar cómo esté declarada la variable, si mide 32 bits se va a bancar 2<sup>32</sup> números distintos. De ahí que a veces puede pasar que el <code>long int</code> mida lo mismo que el <code>int</code>, y entonces el <code>long int</code> puede soportar el mismo intervalo que el <code>int</code>&hellip; lo cual no es muy feliz, pero <em>es lo que hay</em>.</p>

<p>Una buena práctica de programación es asegurar la portabilidad de tu programa, es decir, que sea lo más independiente de la arquitectura posible, para que pueda correrse en muchas máquinas distintas. Entonces, no sería una mala idea poner en práctica el criterio y empezar a decidir cuándo sería conveniente usar <code>int</code> o cuándo es mejor <code>int32_t</code> (a.k.a. “Acá pongo <code>int32_t</code> porque sí.”)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiladores Y Errores]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/compiladores-y-errores/"/>
    <updated>2014-12-26T19:17:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/compiladores-y-errores</id>
    <content type="html"><![CDATA[<p>Hace un tiempo me llegó la siguiente consulta por mail:</p>

<blockquote><p>Cuando trato de correr un proceso por consola me tira un mensaje &#8220;violacion de segmento&#8221; (&#8216;core&#8217; generado). Como mi proceso compilaba correctamente, no me tira errores, me resultaba extraño que me tire en tiempo de ejecución ese error.</p><p>Mi pregunta es, ¿puede ser que los errores del segmentation fault no me los alerte en tiempo de compilacion?</p></blockquote>


<!--more-->


<p>¡Claro que el programa puede fallar incluso cuando no tiene problemas de compilación! El software fallaría mucho menos si lo único que necesitáramos es que el compilador reporte cero errores. Pero hay montones de cosas que afectan la ejecución de un programa, y que exceden por completo las capacidades del compilador, y por eso el compilador <strong>no puede</strong> reportarlas.</p>

<p>Un error del compilador significa que el código es sintácticamente inválido, al punto de que el compilador no puede traducir tu texto a código de máquina. Pero entre código válido y código funcional hay un tremendo salto, y entre código válido y código sin errores, puff.</p>

<p>Pero además de &ldquo;detectar código mal formado&rdquo;, el compilador tiene los warnings, que son avisos de cosas que probablemente estés haciendo mal. Un programa con warnings compila y puede ejecutarse, pero existe una gran probabilidad de que haya errores lógicos que hagan que funcione de modo inesperado.</p>

<p>Y hasta ahí puede llegar el compilador. Pero hay montones de errores que el compilador no puede detectar, por lo que no es una gran garantía la compilación.</p>

<p>Por esto es que hace años que se viene laburando un montón en crear cosas como los tests, las buenas prácticas, los patrones de diseño, la delegación y encapsulamiento como medios para reutilizar código, la abstracción, etc.
TL;DR: es muuuuuuuy difícil garantizar la ausencia de errores en el software, al punto de que es inviable para cualquier programa más o menos útil.</p>

<p>Así que hay que aprender a bailar con eso.</p>

<p>Segmentation fault, en particular, es un error en tiempo de ejecución, que indica un acceso inválido a memoria.</p>

<p>Lo mejor que podés hacer cuando tenés un problema de memoria en tu código es usar <a href="http://valgrind.org/docs/manual/quick-start.html"><code>valgrind</code></a>. Es una herramienta con la que ejecutar tu programa, y que lleva una especie de <em>contabilidad</em> de cómo estas usando la memoria. Cuando tu programa usa erróneamente la memoria (sea un error evitable o uno abortivo), <code>valgrind</code> te informa en qué línea de código intentaste acceder a qué parte de la memoria, y si puede te dice cerca de qué zonas de memoria válidas fue tu acceso (para, por ejemplo, darte cuenta de que estás tratando de escribir un byte de más porque te faltó reservar el espacio para el <code>\0</code> de un string, ponele).</p>

<p>Buscá en <a href="http://utn.so/">el blog de la materia</a> que en la parte de <a href="http://www.utn.so/recursos/">recursos</a> hay <a href="http://faq.utn.so/valgrind">un documento que ayuda a entender los reportes de valgrind</a>. El 90% de los problemas los podés atacar con eso.</p>

<p>Además, hay <a href="https://www.youtube.com/watch?v=-CI4MexyU3I">un vídeo en que explico cómo poder inspeccionar con eclipse un proceso que falló</a>, para poder ver el estado de las variables al momento del fallo. Eso ayuda bastante a ver por qué te ocurrió el problema que reporta valgrind cuando no son tan evidentes las causas.</p>

<p>En cuanto a los pseudo ejemplos de código que me pasas, no te olvides que hay una enorme diferencia entre <code>t_estructura</code> y <code>t_estructura *</code>. Una cosa es la estructura (un conjunto de bytes con los datos que estás modelando) y otra es el puntero (unos pocos bytes con la dirección de memoria en que uno espera encontrar la estructura con los datos del modelo).</p>

<p>No te olvides, tampoco, del scope de las variables en tu programa. Las variables locales, almacenadas en el stack (tal como en el TP), sólo viven hasta que finaliza la ejecución de la función en que son declaradas. Si tu función que crea la estructura lo hace en una variable local, al retornar de esa función la memoria en que se almacenó la estructura deja de estar reservada, y puede ser sobreescrita. Entonces puede que tu programa pinche por eso, también.</p>

<p>Y por esto usamos <code>malloc()</code>: reservamos memoria en el heap, que nosotros decidiremos cuándo liberar, pudiendo &ldquo;sobrevivir&rdquo; a la función que la reservó.</p>

<p>Como &ldquo;moraleja&rdquo; número 2 del mail, recorda lo que dijimos en las charlas sobre usar las herramientas adecuadamente.</p>

<p>No le escapes a <code>malloc()</code>. Hay motivos para que exista, y yo te prometo que es desproporcionadamente más fácil aprender a usar <code>malloc</code> y gestionar bien la memoria que aprobar un TP de Operativos sin aprenderlo (asumiendo que eso sea posible). Aprovecha, además, que el TP este tiene bastante que ver con la gestión de memoria, y debería aportar en ese sentido.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un tutorial rápido para implementar y debuggear malloc, free, calloc y realloc]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/"/>
    <updated>2014-12-26T00:29:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc</id>
    <content type="html"><![CDATA[<p><em>Este post es mi traducción del post <a href="http://danluu.com/malloc-tutorial/">A Quick Tutorial on Implementing and Debugging Malloc, Free, Calloc, and Realloc</a> de <a href="https://twitter.com/danluu">Dan Luu</a>. Cualquier error o sugerencia sobre la traducción es bienvenida, y si querés que haga de intermediario para sugerirle cambios de contenido a él, también vale.</em></p>

<p>¡Implementemos nuestro propio <a href="http://man7.org/linux/man-pages/man3/malloc.3.html"><code>malloc</code></a> y veamos cómo funciona con programas pre-existentes!</p>

<p>Este tutorial asume que sabés qué es un puntero, y que <code>*ptr</code> dereferencia un puntero, y que <code>ptr-&gt;foo</code> significa <code>(*ptr).foo</code>, que <code>malloc</code> se usa para <a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/">reservar (<em>allocar</em>) espacio dinámicamente</a>, y que te es familiar el concepto de lista enlazada. Si decidís seguir este tutorial sin tener un claro conocimiento de C, contame qué partes convendría explicar un poco más. Si querés mirar todo el código de una, está disponible <a href="https://github.com/danluu/malloc-tutorial/blob/master/malloc.c">acá</a>.<!--more--></p>

<p>Presentaciones aparte, la firma de <code>malloc</code> es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Recibe un número de bytes y devuelve un puntero a un bloque de memoria de ese tamaño.</p>

<p>Hay varias formas de implementar esto. Nosotros vamos a elegir arbitrariamente utilizar la llamada al sistema <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html"><code>sbrk</code></a>. El sistema operativo reserva espacios de stack (<em>pila</em>) y heap (<em>montículo</em>) para los procesos, y <code>sbrk</code> nos permite manipular el heap. <code>sbrk(0)</code> devuelve un puntero al tope del heap. <code>sbrk(foo)</code> incrementa el tamaño del heap en <code>foo</code> bytes y devuelve un puntero al tope previo.</p>

<p><img src="http://danluu.com/images/malloc-tutorial/heap.png" alt="Diagrama del esquema de memoria de Linux, cortesía de Gustavo Duarte" /></p>

<p>Si queremos implementar un <code>malloc</code> realmente simple, podemos hacer algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;assert.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// sbrk failed.</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">request</span><span class="p">);</span> <span class="c1">// Not thread safe.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cuando un programa le pide espacio a <code>malloc</code>, éste se lo pide a <code>sbrk</code> para incrementar el tamaño del heap, y devuelve un puntero al inicio de la nueva región en el heap. Esta implementación falla en un tecnisismo, dado que <code>malloc(0)</code> debería devolver <code>NULL</code> u otro puntero que se le pueda pasar a <code>free</code> sin romper todo, pero básicamente funciona.</p>

<p>Pero, hablando de <code>free</code>&hellip; ¿Cómo funciona? Su prototipo es</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cuando le pasan a <code>free</code> un puntero que había sido devuelto por <code>malloc</code> debe liberar ese espacio. Pero si nos dan un puntero a algo reservado por nuestro <code>malloc</code>, no tenemos idea de cuál es el tamaño de ese bloque. ¿Dónde almacenamos eso? Si tuviéramos un <code>malloc</code> funcionando, podríamos <code>malloc</code>ear algo de espacio y guardarlo ahí, pero vamos a meternos en muchos problemas si necesitamos llamar a <code>malloc</code> para reservar espacio cada vez que llamamos a <code>malloc</code> para reservar espacio :)</p>

<p>Un truco común para evitar este problema es guardar meta-información sobre la región de memoria en el espacio previo al puntero que devolvemos. Supongamos que el tope del heap actual está en <code>0x1000</code> y pedimos <code>0x400</code> bytes. Nuestro <code>malloc</code> actual va a pedir <code>0x400</code> bytes a <code>sbrk</code> y devolver un puntero a <code>0x1000</code>. Si, en cambio, guardáramos, digamos, <code>0x10</code> bytes para almacenar información sobre el propio bloque, nuestro <code>malloc</code> pediría <code>0x410</code> bytes a <code>sbrk</code> y devolvería un puntero a <code>0x1010</code>, escondiendo nuestro bloque de <code>0x10</code> bytes de meta-información del código que está llamando a <code>malloc</code>.</p>

<p>Eso nos permite liberar un bloque, pero&hellip; ¿y ahora? Esa región de heap que nos da el SO tiene que ser contigua, entonces no podemos devolverle al SO un pedacito de memoria que esté en el medio. Incluso si quisiéramos copiar todos los datos que están después de la región liberada hacia adelante para rellenar el hueco, cosa de poder liberar el pedazo final del heap, no tenemos forma de actualizar todos los punteros que haya hacia esa zona de memoria a lo largo de todo nuestro programa.</p>

<p>En cambio, podemos marcar que esos bloques fueron liberados sin devolvérselos al SO, y en invocaciones futuras de <code>malloc</code> podríamos reusar esos bloques. Pero para hacer eso necesitamos poder acceder a la meta-información de cada bloque. Hay varias formas de hacerlo, nosotros vamos a elegir arbitrariamente hacerlo con una lista simplemente enlazada por cuestión de simplicidad.</p>

<p>Entonces, para cada bloque, queremos tener algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span> <span class="c1">// For debugging only. TODO: remove this in non-debug mode.</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define META_SIZE sizeof(struct block_meta)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Necesitamos saber el tamaño del bloque, si está o no libre, y cuál es el bloque siguiente. Hay también un número mágico ahí (el campo <code>magic</code>) para ayudarnos a debuggear, pero no es realmente necesario. Le vamos a asignar valores arbitrarios que nos van a permitir saber qué parte del código fue la última en modificar esa estructura.</p>

<p>También necesitamos un inicio para nuestra lista enlazada:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">global_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para nuestro <code>malloc</code>, queremos reusar el espacio libre si fuera posible, _alloc_ando espacio sólo cuando no podemos reusar el que ya tenemos. Dado que tenemos esta estructura de lista enlazada, buscar un bloque libre y devolverlo es casi trivial. Cuando tenemos un pedido de algún tamaño, iteramos nuestra lista buscando algún bloque libre con tamaño suficiente.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">find_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">**</span><span class="n">last</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">global_base</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
</span><span class='line'>    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si no encontramos un bloque que nos sirva, le tenemos que pedir ese espacio al SO usando <code>sbrk</code> y lo agregamos al final de nuestra lista.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">request_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">last</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">META_SIZE</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">block</span> <span class="o">==</span> <span class="n">request</span><span class="p">);</span> <span class="c1">// Not thread safe.</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// sbrk failed.</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// NULL on first request.</span>
</span><span class='line'>    <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como en nuestra implementación original, pedimos espacio usando <code>sbrk</code>, pero ahora le pedimos un poquito más de espacio para poder almacenar nuestra estructura, y además inicializamos los campos correctamente.</p>

<p>Ahora que tenemos las funciones auxiliares para ver si tenemos espacio libre y para pedirlo, nuestro <code>malloc</code> es simple. Si nuestro puntero base global es <code>NULL</code>, tenemos que pedir espacio y apuntar nuestro puntero base a ese nuevo bloque. Si no es <code>NULL</code>, buscamos si podemos reusar el espacio existente. Si podemos, lo hacemos, y si no pedimos espacio nuevo y lo usamos.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// TODO: align size?</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_base</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// First call.</span>
</span><span class='line'>    <span class="n">block</span> <span class="o">=</span> <span class="n">request_space</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">global_base</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">global_base</span><span class="p">;</span>
</span><span class='line'>    <span class="n">block</span> <span class="o">=</span> <span class="n">find_free_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Failed to find free block.</span>
</span><span class='line'>      <span class="n">block</span> <span class="o">=</span> <span class="n">request_space</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>      <span class="c1">// Found free block</span>
</span><span class='line'>      <span class="c1">// TODO: consider splitting block here.</span>
</span><span class='line'>      <span class="n">block</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>      <span class="n">block</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x77777777</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span><span class="p">(</span><span class="n">block</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para quienes no se lleven mucho con C, devolvemos <code>block+1</code> porque queremos devolver un puntero a la región siguiente a <code>block_meta</code>. Dado que <code>block</code> es un puntero del tipo <code>struct block_meta</code>, hacerle <code>+1</code> incrementa la dirección en <code>sizeof(struct block_meta)</code> bytes.</p>

<p>Si sólo quisiéramos un <code>malloc</code> sin un <code>free</code>, podríamos haber usado nuestro <code>malloc</code> original, mucho más simple. Entonces, ¡escribamos nuestro <code>free</code>! Lo principal que <code>free</code> tiene que hacer es setear el campo <code>-&gt;free</code>.</p>

<p>Como vamos a necesitar obtener la dirección de nuestro struct en varios lugares de nuestro código, definamos una función para ello:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">get_block_ptr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ahora que lo tenemos, este es <code>free</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// TODO: consider merging blocks once splitting blocks is implemented.</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">block_ptr</span> <span class="o">=</span> <span class="n">get_block_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="mh">0x77777777</span> <span class="o">||</span> <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="mh">0x12345678</span><span class="p">);</span>
</span><span class='line'>  <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x55555555</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Además de asignar <code>-&gt;free</code>, es válido llamar a <code>free</code> con un puntero <code>NULL</code>, y por eso chequeamos por <code>NULL</code>. Como <code>free</code> no debería llamarse con cualquier dirección arbitraria o bloques que ya hayan sido liberados, <code>assert</code>eamos que esas cosas no pasen.</p>

<p>En realidad no es necesario <code>assert</code>ear nada, pero suele ayudar a debuggear. De hecho, cuando escribí este código tuve un bug que hubiera resultado en corromper silenciosamente los datos si los asserts no hubieran estado ahí. En cambio, el código falló por los <code>assert</code>s, y debuggear el problema se volvió trivial.</p>

<p>Ahora que tenemos <code>malloc</code> y <code>free</code>, ¡podemos escribir programas usando nuestro propio gestor de memoria! Pero antes de meter nuestro gestor en programas ya existentes, necesitamos implementar un par de funciones comunes más: <code>realloc</code> y <code>calloc</code>. <code>calloc</code> es simplemente un <code>malloc</code> que inicializa la memoria en 0, así que arranquemos por <code>realloc</code>. <code>realloc</code> debería ajustar el tamaño de un bloque de memoria que obtuvimos a través de <code>malloc</code>, <code>calloc</code> o <code>realloc</code>.</p>

<p>El prototipo de <code>realloc</code> es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si le pasamos un puntero a <code>NULL</code>, debería funcionar exactamente igual que <code>malloc</code>. Si le pasamos un puntero previamente <code>malloc</code>eado, debería liberar espacio si el tamaño es menor al previo, y asignar más espacio y copiar los datos existentes si el tamaño es mayor que el anterior.</p>

<p>Los programas pueden seguir funcionando si no hiciéramos lo de achicar el bloque o liberarlo, pero sí necesitamos reservar más espacio cuando el tamaño se incrementa, así que empecemos con eso:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// NULL ptr. realloc should act like malloc.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">block_ptr</span> <span class="o">=</span> <span class="n">get_block_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// We have enough space. Could free some once we implement split.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Need to really realloc. Malloc new space and free old space.</span>
</span><span class='line'>  <span class="c1">// Then copy old data to new space.</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">new_ptr</span><span class="p">;</span>
</span><span class='line'>  <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// TODO: set errno on failure.</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">memcpy</span><span class="p">(</span><span class="n">new_ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">new_ptr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y ahora <code>calloc</code>, que simplemente inicializa la memoria antes de devolver el puntero:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nelem</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">elsize</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nelem</span> <span class="o">*</span> <span class="n">elsize</span><span class="p">;</span> <span class="c1">// TODO: check for overflow.</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notemos que no chequea overflows en <code>nelem * elsize</code>, requerido por la especificación. Todo este código es simplemente lo mínimo necesario para que las cosas más o menos funcionen.</p>

<p>Y ahora que tenemos algo que más o menos funciona, usémoslo con los programas ya existentes (¡sin siquiera recompilarlos!).</p>

<p>Primero que nada, necesitamos compilar nuestro código. En Linux, algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>clang -O0 -g -W -Wall -Wextra -shared -fPIC malloc.c -o malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>debería funcionar.</p>

<p><code>-g</code> agrega los símbolos de debug, para poder mirar nuestro código con <code>gdb</code> o <code>lldb</code>. <code>-O0</code> va a ayudar a debuggear, evitando que en las optimizaciones se eliminen variables. <code>-W -Wall -Wextra</code> agrega warnings adicionales. <code>-shared -fPIC</code> nos permite linkear nuestro código dinámicamente, que es lo que nos permite <a href="http://jvns.ca/blog/2014/11/27/ld-preload-is-super-fun-and-easy/">usar nuestro código con binarios ya existentes</a>.</p>

<p>En Mac usaríamos algo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>clang -O0 -g -W -Wall -Wextra -dynamiclib malloc.c -o malloc.dylib
</span></code></pre></td></tr></table></div></figure>


<p>Notar que <code>sbrk</code> fue deprecado en las versiones recientes de OS X. Apple usa una definición poco ortodoxa de <em>deprecado</em> &ndash; algunas llamadas al sistema deprecadas directamente fallan. No probé esto en una Mac, así que puede que la implementación tenga fallas, o directamente no funcione en Mac.</p>

<p>Ahora, para que un binario use nuestro <code>malloc</code> en Linux, tenemos que setear la variable de entorno <code>LD_PRELOAD</code>. Si estás usando <code>bash</code>, podés hacerlo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">LD_PRELOAD</span><span class="o">=</span>/path/absoluto/a/malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>Si estás en Mac, el comando es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">DYLD_INSERT_LIBRARIES</span><span class="o">=</span>/path/absoluto/a/malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>Si todo funciona, podés correr cualquier binario arbitrario y debería funcionar normalmente (excepto que será un poquito más lento).</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>Makefile  malloc.c  malloc.so  README.md  <span class="nb">test  test</span>-0  <span class="nb">test</span>-1  <span class="nb">test</span>-2  <span class="nb">test</span>-3  <span class="nb">test</span>-4
</span></code></pre></td></tr></table></div></figure>


<p>Si hubiera un bug, vas a ver algo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Debuggeando</h3>

<p>¡Hablemos de debugear! Si te es familiar el uso del debugger para poner breakpoints, inspeccionar la memoria y ejecutar paso a paso el código, podés saltear esta sección e ir directamente a <a href="#ejercicios">los ejercicios</a>.</p>

<p>Esta sección asume que podés instalar <code>gdb</code> en tu sistema. Si estás en Mac, probablemente quieras usar <code>lldb</code> y traducir los comandos apropiadamente. Como no tengo idea de qué bugs podés encontrarte, voy a introducir algunos bugs en el código para mostrarte cómo encontrarlos y resolverlos.</p>

<p>Primero, necesito poder correr <code>gdb</code> sin que genere un segmentation fault. Si <code>ls</code> <em>segfaultea</em> y tratamos de correr <code>gdb ls</code>, muy probablemente <code>gdb</code> vaya a segfaultear también. Podríamos escribir un wrapper para hacer esto, pero <code>gdb</code> también lo soporta. Si iniciamos <code>gdb</code> y después corremos <code>set environment LD_PRELOAD=./malloc.so</code> antes de correr el programa, <code>LD_PRELOAD</code> va a funcionar normalmente.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>0x00007ffff7bd7dbd in free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x0<span class="o">)</span> at malloc.c:113
</span><span class='line'>113       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span></code></pre></td></tr></table></div></figure>


<p>Como esperábamos, tenemos un segfault. Podemos usar <code>list</code> para ver el código alrededor del error:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> list
</span><span class='line'>108     <span class="o">}</span>
</span><span class='line'>109
</span><span class='line'>110     void free<span class="o">(</span>void *ptr<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>111       // TODO: consider merging blocks once splitting blocks is implemented.
</span><span class='line'>112       struct block_meta* <span class="nv">block_ptr</span> <span class="o">=</span> get_block_ptr<span class="o">(</span>ptr<span class="o">)</span>;
</span><span class='line'>113       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span><span class='line'>114       assert<span class="o">(</span>block_ptr-&gt;magic <span class="o">==</span> 0x77777777 <span class="o">||</span> block_ptr-&gt;magic <span class="o">==</span> 0x12345678<span class="o">)</span>;
</span><span class='line'>115       block_ptr-&gt;free <span class="o">=</span> 1;
</span><span class='line'>116       block_ptr-&gt;magic <span class="o">=</span> 0x55555555;
</span><span class='line'>117     <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y podemos usar <code>p</code> (<em>print</em>) para ver qué está pasando con las variables:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p ptr
</span><span class='line'><span class="nv">$6</span> <span class="o">=</span> <span class="o">(</span>void *<span class="o">)</span> 0x0
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p block_ptr
</span><span class='line'><span class="nv">$7</span> <span class="o">=</span> <span class="o">(</span>struct block_meta *<span class="o">)</span> 0xffffffffffffffe8
</span></code></pre></td></tr></table></div></figure>


<p><code>ptr</code> vale <code>0</code>, o sea, <code>NULL</code>, y esa es la causa del problema: nos olvidamos de chequear por <code>NULL</code>.</p>

<p>Ahora que encontramos eso, probemos con un bug un poco más complicado. Digamos que decidimos reemplazar nuestra estructura por:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>    <span class="c1">// For debugging only. TODO: remove this in non-debug mode.</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y devolver <code>block-&gt;data</code> en lugar de <code>block+1</code> en <code>malloc</code>, sin más cambios. Se parece bastante a lo que veníamos haciendo, sólo que ahora definimos un campo más que apunta al final de la estructura, y retornamos un puntero ahí.</p>

<p>Pero esto es lo que pasa si usamos nuestro nuevo <code>malloc</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/bin/ls
</span><span class='line'>Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>
</span><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run
</span><span class='line'>
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>_IO_vfprintf_internal <span class="o">(</span><span class="nv">s</span><span class="o">=</span>s@entry<span class="o">=</span>0x7fffff7ff5f0, <span class="nv">format</span><span class="o">=</span>format@entry<span class="o">=</span>0x7ffff7567370 <span class="s2">&quot;%s%s%s:%u: %s%sAssertion     `%s&#39; failed.\n%n&quot;</span>, <span class="nv">ap</span><span class="o">=</span>ap@entry<span class="o">=</span>0x7fffff7ff718<span class="o">)</span> at vfprintf.c:1332
</span><span class='line'>1332    vfprintf.c: No such file or directory.
</span><span class='line'>1327    in vfprintf.c
</span></code></pre></td></tr></table></div></figure>


<p>Este no es tan lindo como el error anterior &ndash; podemos ver que uno de nuestros <code>assert</code>s falló, pero <code>gdb</code> nos deja tirados dentro de una función de <code>printf</code>, llamada cuando un <code>assert</code> falla. Pero esa función usa nuestro <code>malloc</code> buggeado ¡y revienta!</p>

<p>Lo que podemos hacer es inspeccionar <code>ap</code> para ver qué era lo que <code>assert</code> trataba de imprimir:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p *ap
</span><span class='line'><span class="nv">$4</span> <span class="o">=</span> <span class="o">{</span><span class="nv">gp_offset</span> <span class="o">=</span> 16, <span class="nv">fp_offset</span> <span class="o">=</span> 48, <span class="nv">overflow_arg_area</span> <span class="o">=</span> 0x7fffff7ff7f0, <span class="nv">reg_save_area</span> <span class="o">=</span> 0x7fffff7ff730<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Eso funcionaría bien. Podemos jugar un poquito hasta encontrar qué es lo que pretendía imprimir, y encontrar el error de ese modo. Otras formas hubieran sido implementar nuestro propio <code>assert</code> o usar los <em>hooks</em> correctos para prevenir que <code>assert</code> use nuestro <code>malloc</code>.</p>

<p>Pero, en este caso, nosotros sabemos que hay sólo unos pocos <code>assert</code>s en nuestro código: el de <code>malloc</code>, garantizando que no estemos usandolo en un programa multihilo, y los dos de <code>free</code> chequeando que no estemos liberando algo que no debiéramos. Miremos primero <code>free</code>, poniendo un <em>breakpoint</em>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>free
</span><span class='line'>Breakpoint 1 at 0x400530
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run /bin/ls
</span><span class='line'>
</span><span class='line'>Breakpoint 1, free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x61c270<span class="o">)</span> at malloc.c:112
</span><span class='line'>112       <span class="k">if</span> <span class="o">(</span>!ptr<span class="o">)</span> <span class="o">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>Aún no asignamos <code>block_ptr</code>, pero si hacemos <code>s</code> un par de veces para avanzar hasta después de que fuera asignado, podemos ver que su valor es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'>free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x61c270<span class="o">)</span> at malloc.c:118
</span><span class='line'>118       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *block_ptr
</span><span class='line'><span class="nv">$11</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0, <span class="nv">next</span> <span class="o">=</span> 0x78, <span class="nv">free</span> <span class="o">=</span> 0, <span class="nv">magic</span> <span class="o">=</span> 0, <span class="nv">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Estoy usando <code>p/x</code> en vez de <code>p</code> para poder verlo en hexadecimal. El campo <code>magic</code> está en 0, que debería ser imposible para una estructura válida para liberar. ¿Puede que <code>get_block_ptr</code> esté devolviendo un offset incorrecto? Tenemos <code>ptr</code> disponible, así que podemos inspeccionar distintos offsets. Dado que es un <code>void *</code>, vamos a tener que castearlo para que <code>gdb</code> sepa cómo interpretar los resultados:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p sizeof<span class="o">(</span>struct block_meta<span class="o">)</span>
</span><span class='line'><span class="nv">$12</span> <span class="o">=</span> 32
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-32<span class="o">)</span>
</span><span class='line'><span class="nv">$13</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x0, <span class="nv">next</span> <span class="o">=</span> 0x78, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x0, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x0<span class="o">}}</span>
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-28<span class="o">)</span>
</span><span class='line'><span class="nv">$14</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x7800000000, <span class="nv">next</span> <span class="o">=</span> 0x0, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x0, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x78<span class="o">}}</span>
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-24<span class="o">)</span>
</span><span class='line'><span class="nv">$15</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x78, <span class="nv">next</span> <span class="o">=</span> 0x0, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x12345678, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x6e<span class="o">}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si miramos un poco la dirección que estamos usando, podemos ver que el offset correcto es 24 y no 32. Lo que está pasando es que la estructura tiene <em>padding</em>, es decir, está siendo alineada al tamaño de palabra del procesador. Entonces, <code>sizeof(struct block_meta)</code> es 32, incluso aunque el último campo válido esté en 24. Si queremos remover ese espacio extra, tenemos que arreglar <code>get_block_ptr</code>.</p>

<p>¡Y eso fue todo el debugging!</p>

<h3><a name="ejercicios">Ejercicios</a></h3>

<p>Personalmente, estas cosas no me quedan hasta que no hago un par de ejercicios, así que voy a dejar algunos acá para quienes les interese.</p>

<ol>
<li>Se espera que <code>malloc</code> devuelva un puntero <em>convenientemente alineado a cualquier tipo nativo</em>. ¿Hace eso el nuestro? Si lo hace, ¿por qué? Si no, corregilo. Notá que &ldquo;cualquier tipo nativo&rdquo; es, básicamente, 8 bytes en C, dado que los tipos de SSE/AVX no son nativos.</li>
<li>Nuestro <code>malloc</code> desperdicia un montón de espacio si reusamos un bloque sin necesitar <em>tanto</em> tamaño. Implementá una función que lo divida en bloques que ocupen el espacio mínimo necesario.</li>
<li>Después de hacer <code>2</code>, si llamamos a <code>malloc</code> y <code>free</code> muchas veces con tamaños aleatorios, terminaremos con un montón de bloques pequeños que sólo se pueden reusar si pedimos cantidades pequeñas de memoria. Implementá un mecanismo que una bloques libres adyacentes para que varios bloques consecutivos se unan en uno solo.</li>
<li>¡Encontrá bugs en el código existente! No lo testeé demasiado, así que <em>tienen que</em> haber bugs, por más que esto más o menos funcione.</li>
</ol>


<h2>Parte 2 en adelante</h2>

<p>A continuación vamos a ver cómo hacer que esto sea más rápido y que sea <em>thread safe</em>.</p>

<h3>Recursos</h3>

<p>Leí <a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf">este tutorial</a> de Marwan Burelle antes de sentarme a escribir mi propia implementación, así que se parece bastante. Las principales diferencias son que mi versión es más simple, pero más vulnerable a la fragmentación de memoria. En términos de exposición, mi estilo es bastante más informal. Si querés algo más formal, el Dr. Burelle es tu camino a seguir.</p>

<p>Para saber más sobre cómo Linux maneja la memoria, mirá <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">este post</a> de Gustavo Duarte.</p>

<p>Para saber más sobre cómo funcionan las implementaciones reales de <code>malloc</code>, <a href="http://g.oswego.edu/dl/html/malloc.html">dlmalloc</a> y <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">tcmalloc</a> son dos grandes lecturas. No leí el código de <a href="http://www.canonware.com/jemalloc/">jemalloc</a>, y escuché que es un poco más difícil de entender, pero es una de las implementaciónes de [malloc] de alta performance más usadas que hay.</p>

<p>Para ayuda debuggeando, <a href="https://code.google.com/p/address-sanitizer/wiki/AddressSanitizer">Address Sanitizer</a> la rompe. Y si querés escribir una versión thread-safe, <a href="https://code.google.com/p/data-race-test/wiki/ThreadSanitizer">Thread Sanitizer</a> también es una gran herramienta.</p>

<h3>Agradecimientos</h3>

<p>Gracias a Gustavo Duarte por permitirme usar una de sus imágenes para ilustrar <code>sbrk</code>, a Ian Whitlock y Danielle Sucher por encontrar algunos <em>typos</em>, a Nathan Kurz por sus sugerencias sobre los recursos adicionales, y a &ldquo;tedu&rdquo; por encontrar un bug. Por favor, <a href="https://twitter.com/danluu">avisame</a> si encontrás otros bugs en este post (tanto en el texto como en el código).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[P. Sherman, Calle Wallaby 42, Sydney]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/09/04/p-sherman-calle-wallaby-42-sydney/"/>
    <updated>2014-09-04T00:42:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/09/04/p-sherman-calle-wallaby-42-sydney</id>
    <content type="html"><![CDATA[<blockquote><p>Con algo de suerte, este será el primero de una serie de al menos 3 posts hablando sobre la gestión de la memoria en C. Sólo parece no aportar tanto, pero probablemente entre los 3 den un mensaje más o menos copado. Stay tuned :)</p></blockquote>


<p>Una de las complejidades más importantes asociadas a la programación en C es la gestión y el uso de la memoria.<!--more--></p>

<p>Para un programa C, la memoria de la computadora es poco más que un gran vector (<em>array</em>) de bytes consecutivos. Todos y cada uno de estos bytes tienen una dirección: un número que permite al programa identificar a cada byte unequívocamente. Las direcciones arrancan (como todo en C) por la dirección 0. Y, como suelen representarse en hexa, vamos a decir que el primer byte de memoria es el de la dirección <code>0x0</code>.</p>

<p>Es importante recordar que C trabaja con <em>punteros</em> (referencias a direcciones de memoria) <em>absolutos</em>, por lo que, en principio, el byte <code>0x0</code> no será necesariamente el primero de los que use nuestro programa para almacenar datos, sino el primero de la memoria de la computadora<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>Las direcciones son consecutivas, por lo que el byte siguiente al <code>0x0</code> será el <code>0x1</code>, <code>0x2</code>, y así siguiendo. Hablamos en hexa, así que el décimo byte será el <code>0x9</code>, pero el undécimo será <code>0xa</code>, y así.</p>

<p>Pero, en general, uno como programador no usa bytes de memoria, sino una abstracción un poquito por encima: las variables.</p>

<p>Al declarar una variable, le estamos indicando al compilador que reserve una determinada cantidad de bytes de memoria, según el tipo declarado, y además le asociamos un nombre a ese conjunto de bytes, de modo que podamos identificarlo y referirlo de modo más simple.</p>

<p>Es importante recalcar que el nombre de la variable sólo existe hasta la compilación: al ejecutar nuestro programa, todas las referencias a memoria se hacen a través de direcciones y tamaños<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>Entonces, así como la declaración <code>unsigned int nombre[10];</code> reserva (en una arquitectura de 32 bits) 40 bytes, la referencia <code>nombre[0]</code> habla de la misma dirección que <code>nombre</code> (por ejemplo, podría referir a <code>0x0842f5</code>), mientras que <code>nombre[2]</code> referirá a la dirección 8 bytes más grande, <code>0x0842fd</code>. Como el tipo de datos es <code>unsigned int</code>, de 32 bits, el compilador sabe cuántos bytes desplazarse para cada elemento (sabiendo, así, que <code>nombre[2]</code> está 8 bytes después de <code>nombre[0]</code>, y no 4, 2, 16 o cualquier otra cantidad), y cuántos bytes a partir de esa dirección tiene que leer para obtener el dato buscado.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>En particular, el byte <code>0x0</code> suele tener un significado muy especial en la mayoría de los sistemas operativos (<code>NULL</code> suele ser una referencia al <code>0x0</code>), por lo que en la inmensa mayoría de los casos el byte <code>0x0</code> <em>no va</em> a pertenecer a nuestro proceso.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Cuando indicamos compilar en modo debug, el compilador incluye en el programa final información extra (como los nombres de las variables y funciones) a fin de poder mostrar mensajes de error más apropiados que simplemente muchas direcciones de memoria, pero esta información <strong>NO ES REQUERIDA</strong> para la ejecución del programa.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[She bangs, she bangs...]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/03/20/she-bangs-she-bangs/"/>
    <updated>2014-03-20T19:33:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2014/03/20/she-bangs-she-bangs</id>
    <content type="html"><![CDATA[<p>Si alguna vez editaron un script UNIX, seguramente habrán visto que arrancan de manera similar: <code>#!/bin/sh</code>. Por algún motivo, esa línea mágica se llama <a href="0">Shebang</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<figure class='code'><figcaption><span>mi_script </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;¡Hola, mundo!&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Llamamos <code>mi_script</code> a este archivo.</p>

<p>Esa línea mágica es la responsable de que podamos correr un script ejecutando <code>./mi_script</code> en la consola.<!--more--> Como dijimos en <a href="tutorial-c/blog/2013/08/19/arrancando">el primer post</a>, para ejecutar un programa en UNIX, el programa tiene que tener permisos de ejecución<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, y luego tenemos que tipear su ruta completa en la consola:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>chmod +x mi_script
</span><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'>¡Hola, mundo!
</span></code></pre></td></tr></table></div></figure>


<p>Al hacerlo, el sistema operativo carga el programa en memoria y lo ejecuta.</p>

<p>El problema es que un script es texto. Los programas compilados tienen las instrucciones que nuestro procesador entiende, entonces es relativamente trivial ejecutarlo<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>. Un script tiene texto. Y, adivinaste: el procesador no ejecuta texto. Entonces, ¿qué es lo que ocurre? ¿Por qué y cómo funciona la ejecución de scripts?</p>

<p>La clave es el shebang. Cuando el sistema operativo detecta que lo que pretendemos ejecutar es un script (digamos, no es un programa en algún formato binario que el sistema operativo comprenda), busca en la primer línea para encontrar este shebang. Esa ruta que se encuentra después del <code>#!</code> (en nuestro caso anterior, <code>/bin/sh</code>) es la que va a ser ejecutada, pasándole como primer parámetro la ruta de nuestro script. Sí: en <code>/bin/sh</code> tenés que tener un programa ejecutable para que la ejecución del script funcione. Si, además, querés que se ejecute como corresponde, ese <code>/bin/sh</code> debería entender que cuando se lo ejecuta con un parámetro, ese parámetro representa una ruta a un archivo que contiene código en un lenguaje que ese programa sepa interpretar.</p>

<p>En general, esto ocurre: por convención, en los sistemas UNIX <code>/bin/sh</code> es una <a href="http://es.wikipedia.org/wiki/Bourne_Shell">Bourne Shell</a>, o alguna otra shell con el modo de compatibilidad activado. ¿Qué es una Bourne Shell? Un programa capaz de interpretar scripts escritos en ese lenguaje. Dado que los programas que se ponen en los shebangs tienen como objetivo <em>interpretar</em> scripts, se los llamó (muy originalmente) <em>intérpretes</em>.</p>

<p>¿Existen otros intérpretes? Claro que sí. <a href="https://www.python.org/">Python</a> es un lenguaje interpretado, y uno puede hacer scripts en Python y ejecutarlos en la consola, como <a href="https://github.com/chapuni/llvm-project/blob/bbf3f7262bd18fe1b140ba0db9ada8defa2c839f/klee/scripts/objdump">este</a>. Lo mismo pasa con Ruby, perl, y tantos otros lenguajes.</p>

<p>Ahora, como somos curiosos, podríamos ponernos a jugar con esto y abusar un poquito. ¿Qué pasa si usamos otro programa como intérprete? ¿Podemos usar cualquier programa? Podemos, sí, pero los resultados van a cambiar.</p>

<p>Editemos nuestro script. Modifiquemos únicamente el shebang, poniéndole como intérprete <code>/bin/cat</code>. <code>cat</code> es un programa que imprime <em>en pantalla</em> el contenido de la ruta que le pasamos por parámetro. ¿Qué va a pasar cuando volvamos a ejecutar nuestro script?</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'><span class="c">#!/bin/cat</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;¡Hola, mundo!&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Claro que sí. Al ejecutar nuestro script, el sistema operativo ejecutó <code>/bin/cat</code> pasándole la ruta a <code>mi_script</code> como parámetro. <code>cat</code>, como siempre, abrió la ruta que le pasaron por parámetro y mostró su contenido.</p>

<p>Sigamos jugando. Usemos otro programa: <code>echo</code>. Cambiemos el intérprete por <code>/bin/echo</code>, y ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'>./mi_script
</span></code></pre></td></tr></table></div></figure>


<p>Así es. <code>echo</code> imprime lo que sea que le pasemos como parámetro. Si lo que le pasamos es la ruta de nuestro script, como pasa con todas las ejecuciones de los scripts, <code>echo</code> va a imprimir eso mismo en la consola.</p>

<p>Otro intérprete &ldquo;loco&rdquo; que podemos poner es <code>rm</code>: <code>#!/bin/rm</code>. Ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'><span class="nv">$ </span>ls mi_script
</span><span class='line'>ls: mi_script: No such file or directory
</span></code></pre></td></tr></table></div></figure>


<p>Así es, lo borramos.</p>

<p>Entonces, hagamos una última prueba para jugar. Escribamos un programa que liste todos los parámetros con los que fue ejecutado:</p>

<figure class='code'><figcaption><span>interprete.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;  Parametro %d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Compilemos y ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc interprete.c -o interprete
</span><span class='line'><span class="nv">$ </span>./interprete
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'><span class="nv">$ </span>./interprete primerParametro segundo 3ro
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: primerParametro
</span><span class='line'>  Parametro 2: segundo
</span><span class='line'>  Parametro 3: 3ro
</span></code></pre></td></tr></table></div></figure>


<p>El primer parámetro de cualquier programa C es el propio programa. Ahora bien, pongámoslo como intérprete de nuestro script:</p>

<figure class='code'><figcaption><span>mi_script </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!./interprete</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;Este codigo nunca se ejecutara&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: ./mi_script
</span><span class='line'><span class="nv">$ </span>./mi_script primerParametro
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: ./mi_script
</span><span class='line'>  Parametro 2: primerParametro
</span></code></pre></td></tr></table></div></figure>


<p>Así es: se ejecuta el programa que pusimos en la shebang, y luego se le pasa todo lo que tipeemos en la consola. Y no sólo podemos poner un programa en el shebang, sino también parámetros:</p>

<figure class='code'><figcaption><span>mi_script </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!./interprete unParametroFijo</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;Este codigo nunca se ejecutara&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./mi_script
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: unParametroFijo
</span><span class='line'>  Parametro 2: ./mi_script
</span><span class='line'><span class="nv">$ </span>./mi_script otroParametro
</span><span class='line'>  Parametro 0: ./interprete
</span><span class='line'>  Parametro 1: unParametroFijo
</span><span class='line'>  Parametro 2: ./mi_script
</span><span class='line'>  Parametro 3: otroParametro
</span></code></pre></td></tr></table></div></figure>


<p>Creo que no queda mucho más para agregar. <em>Espero que mis respuestas os haya iluminados :)</em></p>

<hr>


<p><strong>EDIT:</strong> Recordé que <strong>sí</strong> había algo más para agregar.</p>

<p>Muchas veces ví que podía escribir un script sin ponerle un shebang, y que de todos modos funcionaba. ¿Por qué? Bueno, porque de algún modo se defaultea. En <a href="http://stackoverflow.com/a/9945113/641451">Stackoverflow</a> dicen que se ejecuta con la misma shell que estás usando en ese momento, pero esto no es comportamiento estándar: la documentación de la syscall <a href="http://linux.die.net/man/2/execve"><code>execve</code></a> dice que un script <strong>tiene que</strong> comenzar con un shebang válido<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>. Conviene no dar nada por sentado y especificar el intérprete que queremos usar, asegurándonos así la compatibilidad y buen funcionamiento.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>El caracter <code>#</code> en inglés se llama &ldquo;hash&rdquo; (y supongo que se lo llamará, también, &ldquo;sha&rdquo;), y el <code>!</code> es el &ldquo;bang&rdquo;.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>¡Gracias, Victor, por la corrección!<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><em>trivial</em> es un decir. Ejecutar un programa no tiene nada de trivial, pero digamos que <em>la idea de cómo ejecutarlo</em> es relativamente sencilla, al menos respecto a interpretar un script.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Y, abajo de todo, en la documentación, muestra el código de un programa llamado <code>myecho</code> <em>MUUUUUUUY</em> similar a nuestro <code>interprete.c</code> :)<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Me dí cuenta que me tiraste la señal]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/"/>
    <updated>2013-12-31T00:27:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal</id>
    <content type="html"><![CDATA[<p>Uno de los mecanismos de <abbr title="Inter-Process Communication - Comunicación entre procesos">IPC</abbr> que nos provee Linux es el envío de señales. Es un modo de comunicación MUY minimalista: un proceso le envía una determinada señal a otro, y este último simplemente recibe el código asociado a la señal recibida.</p>

<p>Y nada más. No hay parámetros, no hay información del emisor, nada. Sólo un código.<!--more--></p>

<p>Y, aún así, es un método más que útil: para terminar un proceso en la terminal (cuando apretamos <kbd>CTRL+C</kbd>), para cerrar un programa que se colgó (desde algún administrador de tareas), para pausar la ejecución de un proceso o para cerrar un programa clickeando la <code>x</code> de cierre en su ventana &ndash; en todos estos casos estamos mandando una señal a un proceso.</p>

<p>Las señales tienen asociadas distintas acciones por defecto, que se ejecutarán cuando el proceso reciba cada señal. Por ejemplo, al recibir <code>SIGTERM</code> o <code>SIGKILL</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, el proceso finalizará con un código de salida no-exitoso, mientras que la señal <code>SIGUSR1</code> será ignorada (el proceso no hará nada al recibirla).</p>

<p>Lo interesante de las señales es que los procesos pueden especificar sus propias acciones a ejecutar cuando la señal es recibida, en lugar de ejecutar la acción por defecto. Dado que las señales se envían a los procesos<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, alguno de sus hilos se interrumpirá para pasar a ejecutar una función que nosotros determinemos cuando la señal llegue, tal como si en la línea de código que está ejecutándose al momento de recibir la señal invocara a la función determinada. Al concluir la ejecución de la función, el programa retornará al punto en que estaba antes del arribo de la señal, y todo seguirá su curso normalmente.</p>

<p>Por ser un mecanismo de IPC (es decir, involucra a más de un proceso), no hay otra opción: para que esto funcione, de algún modo <strong>debe</strong> intervenir el sistema operativo. Linux utiliza tres máscaras (bitmaps) para cada proceso, indicando qué señales deberán ignorarse, cuáles están bloqueadas (se encolan hasta ser desbloqueadas) y cuáles serán capturadas para ser atendidas por el proceso en lugar de aplicarles la acción por defecto.</p>

<p>Entonces, si el proceso tiene un manejador de señal definido, al recibir la señal el proceso bloqueará la recepción de esa señal, ejecutará la función correspondiente y, al finalizar, desbloqueará la señal. De este modo, se evita interrumpir la ejecución del manejador de la señal, para evitar conflictos con por sincronización (si el manejador lockea un mutex y se interrumpe con una nueva ejecución de si mismo antes de liberarlo, estaríamos en presencia de un auto-deadlock <code>:)</code>).</p>

<p>El problema que inspiró este post viene con el uso de <code>exec*</code>. <code>execve</code> es una llamada al sistema que reemplaza la imagen de un proceso por una nueva, pasando a ejecutar un nuevo programa. La familia de funciones <code>exec*</code> son wrappers de esa syscall.</p>

<p>Lo importante de todo esto son dos cosas: una <code>execve</code> exitosa no retorna, y reemplazar la imagen de un proceso no implica cambiar los atributos del mismo. De <code>man 2 execve</code>:</p>

<pre><code>All process attributes are preserved during an execve(), except the following:
</code></pre>

<p>Y, adiviná qué: las máscaras de las señales no son parte de las excepciones. Entonces, repasemos: llega la señal, se bloquean la señal recibida, y se ejecuta el handler de la señal. Si ese handler hiciera un <code>execve</code> exitoso, la función no retorna: empieza a ejecutar el nuevo proceso. Pero, si el handler no retorna, nunca se desbloquea la señal, por lo que el nuevo proceso no recibirá más la señal especificada, porque serán encoladas eternamente. Bang.</p>

<p>La solución a esto es desbloquear la señal a mano antes de llamar a <code>execve</code>. En C, desde dentro del handler, podríamos lograrlo usando este fragmento de código:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>
</span><span class='line'><span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
</span><span class='line'><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
</span><span class='line'><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>sigemptyset</code> inicializa un set de señales vacío, y luego marcamos la señal que nos interese (en este caso, <code>SIGINT</code>) en ese set. Por último, la función <code>sigprocmask</code> es la que se encargará, con estos parámetros, de desbloquear el set de señales marcados (sólo <code>SIGINT</code>). Luego de esto, sí, podremos ejecutar <code>execve</code> sin problemas.</p>

<p><strong>Créditos</strong>: mucha información de este post surgió a partir de <a href="http://stackoverflow.com/a/1024778">esta respuesta en StackOverflow</a>.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Se pueden listar todas las señales ejecutando <code>kill -l</code><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>En Linux, que tiene <abbr title="Kernel Level Thread - Hilos de Kernel">KLTs</abbr>, uno puede enviar la señal especificando un <abbr title="Thread ID - Identificador de Hilo">TID</abbr> en lugar de un <abbr title="Process ID - Identificador de Proceso">PID</abbr>, por lo que puede mandarle la señal a un hilo en particular. Poniéndonos más técnicos, el PID coincide con el TID del hilo principal (<code>main()</code>), por lo que al enviarle la señal al proceso en realidad se la estamos enviando al hilo principal. Pero la idea genérica de &ldquo;las señales se envían a procesos&rdquo; es más feliz.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[inotify]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/30/inotify/"/>
    <updated>2013-12-30T02:09:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/30/inotify</id>
    <content type="html"><![CDATA[<blockquote><p>**Disclaimer**: nunca implementé inotify, por lo que este post puede ser incompleto, incorrecto, o cualquier otro &#8220;in&#8221; que se te ocurra. Su espíritu es simplemente poder referenciar acá cada vez que surja un inconveniente con la herramienta, para no repetir lo que escribo siempre, y para cada vez dar una mejor respuesta. Todo aporte será más que bienvenido.</p></blockquote>


<p>El mundo real apesta. Existe el hambre, la capa de ozono se debilita, y el software obra de maneras misteriosas.</p>

<p><code>inotify</code> es una API de Linux que nos permite monitorear cambios en un archivo o directorio. En criollo, es un <em>duende</em> al que le pedimos que levante la mano cuando ocurre algún evento que a nosotros nos interese, como la creación de un archivo en un directorio, la eliminación de un archivo o una escritura.<!--more--></p>

<p>Como es funcionalidad que provee el kernel, claramente está bien implementada: nada de tener al duende haciendo <code>ls</code> cada medio segundo para que avise al encontrar diferencias entre los últimos dos <code>ls</code>, sino que existe un modelo de eventos, y nosotros podemos especificar aquellos que nos interesa que se nos notifiquen (de ahí el 90% del nombre, je).</p>

<p>El otro 10% es la i. <code>inotify</code> es funcionalidad que provee el kernel, por lo que trabaja al nivel al que el kernel conoce a los archivos, el File Control Block: los inodos. Al atender las diferentes llamadas al sistema (syscalls), el kernel dispara también las notificaciones correspondientes.</p>

<p>Los eventos por los que podemos ser notificados están explicados en el man:</p>

<pre><code>IN_ACCESS         File was accessed (read) (*).
IN_ATTRIB         Metadata changed, e.g., permissions, timestamps, extended attributes,
                    link count (since Linux 2.6.25), UID, GID, etc. (*).
IN_CLOSE_WRITE    File opened for writing was closed (*).
IN_CLOSE_NOWRITE  File not opened for writing was closed (*).
IN_CREATE         File/directory created in watched directory (*).
IN_DELETE         File/directory deleted from watched directory (*).
IN_DELETE_SELF    Watched file/directory was itself deleted.
IN_MODIFY         File was modified (*).
IN_MOVE_SELF      Watched file/directory was itself moved.
IN_MOVED_FROM     File moved out of watched directory (*).
IN_MOVED_TO       File moved into watched directory (*).
IN_OPEN           File was opened (*).
</code></pre>

<p>El problema ocurre con el mundo real. Dado que en ningún lugar está definido el contrato de cómo un programa tiene que implementar sus funcionalidades (por comunes que sean, como la actualización de un archivo), cada aplicación en particular puede implementar un conjunto de llamadas al sistema distinto para hacerlo. Si a esto sumamos la antiguedad y diversidad de orígenes de los editores de texto que se usan en Linux (algunos datan de los 70, pensados para usar en mainframes, mientras que otros son más recientes y apuntan a optimizar acceso a disco, o uso de memoria, o tiempo de respuesta), el panorama es realmente complejo: algunos editores de texto simplemente actualizarán los bloques de datos que hayan cambiado, mientras que otros optarán por enfoques más extraños.</p>

<p>Un caso conocido es el de <code>nano</code>. Al grabar un archivo pequeño (archivos menores a 1 bloque &ndash; 4kb), <code>nano</code> optará por vaciar el archivo (truncarlo a 0 bytes) y luego grabar su contenido, por lo que <code>inotify</code> disparará dos eventos: <code>IN_MODIFIY</code> (&ldquo;el archivo fue vaciado&rdquo;), y luego otro <code>IN_MODIFY</code> (&ldquo;se escribió el contenido del archivo&rdquo;).</p>

<p><code>vim</code>, por otro lado, mantiene un archivo de backup mientras vamos trabajando, para ahorrarnos algún dolor de cabeza si se nos llegara a apagar mal la máquina. Ahora, como ya mantiene ese archivo de backup, a <code>vim</code> le es más facil, cuando le pedimos grabar un archivo, reemplazar el archivo que existía por el backup actualizado, y listo. El resultado de esto es un set de llamadas al sistema bastante distinto al de <code>nano</code>: primero elimina el archivo original, y luego renombra el backup para que ocupe la ruta en que se encontraba el original. El problema con esto no sólo es que no hay eventos <code>IN_MODIFY</code>, sino que, como dijimos, <code>inotify</code> conoce inodos: el archivo del backup, por más que pase a llamarse igual que el original, es un inodo distinto, por lo que <code>inotify</code> dejará de detectar eventos sobre el archivo que se encuentra en el path que habíamos especificado.</p>

<p>&ldquo;Solucionar&rdquo; estos problemas requiere tener en cuenta el comportamiento de cada editor y reaccionar de manera acorde cuando se detectan los eventos.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bajando el nivel]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/10/21/bajando-el-nivel/"/>
    <updated>2013-10-21T01:19:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/10/21/bajando-el-nivel</id>
    <content type="html"><![CDATA[<p>&ldquo;Che, me acabás de decir que el 0 sigue existiendo por más que <em>lo pise</em> con otro valor. ¿El 0 es un objeto al que la VM le mantiene referencias y por eso no se lo lleva el Garbage Collector?&rdquo;<!--more--></p>

<p>What!? No way, papá. Por un cuatrimestre, las palabras &ldquo;objeto&rdquo; y &ldquo;Garbage Collector&rdquo; dejalas en la oficina, y VM = VirtualBox :)</p>

<p>En C no hay objetos.</p>

<p>Perdón si fui duro, pero es necesario: en C no hay objetos. Y no hay GC.</p>

<p>&ldquo;Entonces, ¿qué es el 0?&rdquo;</p>

<p>El 0 es una constante. Si recordás, en Arquitectura (bazinga) vimos que los números se representan en binario en la PC. Las variables de C son meras referencias a algún bloque de memroia, siendo el tipo de la variable el que anuncia qué tamaño tiene esa referencia.</p>

<p>Digamos, esto es una memoria de 30 bytes<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (éramos tan pobres):</p>

<p><img src="http://mgarciaisaia.github.io/tutorial-c/assets/memoria-libre.png" alt="Una RAM de 30 bytes" /></p>

<p>Esa es toda la memoria de esta computadora hipotética. Si en mi programa declaro una variable <code>int exit_status;</code>, podríamos pensarlo como que C hará algo así:</p>

<p><img src="http://mgarciaisaia.github.io/tutorial-c/assets/memoria-reservada.png" alt="La RAM con una variable" /></p>

<p>En algún lugar de la memoria (en este caso, a partir del byte 13), C reservó<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> unos bytes para nuestra variable ¿Cuántos bytes reservó? Eso depende del tipo de dato que le declaramos a la variable. Por definición, el tipo <code>int</code> equivale al <a href="http://es.wikipedia.org/wiki/Palabra_(inform%C3%A1tica)">tamaño de palabra del procesador</a>. Esto significa que en máquinas de 32 bits (como esta computadora hipotética, o las VMs de la cátedra, o la enorme mayoría de los Windows XP y Vista), un <code>int</code> va a ocupar 4 bytes (32 bits).</p>

<p>Entonces, al hacer algo como <code>exit_status = 0;</code> (y sabiendo que <code>exit_status</code> es una variable entera de 4 bytes), el compilador sabe que tiene que hacer que los 4 bytes que están a partir del byte en que empieza <code>exit_status</code> valgan un 0. En Arquitectura aprendimos que los enteros con signo se representan usando el <a href="http://es.wikipedia.org/wiki/Complemento_a_dos">complemento a 2</a>, por lo que el 0 en 32 bits es simplemente <a href="http://es.wikipedia.org/wiki/Sistema_hexadecimal"><code>0x0000 0000</code></a> (4 bytes en 0).</p>

<p>Entonces, ¿dónde está ese 0? <a href="http://es.wikipedia.org/wiki/Hard_code">Hardcodeado</a> en el binario. Compilar un programa es pedirle al compilador (<code>gcc</code> en nuestro caso) que traduzca todo ese C hermoso que escribimos en las instrucciones de Assembler que nuestro procesador tiene que ejecutar para que el código funcione con nuestro sistema operativo. De todas esas, alguna va a ser algo como <code>mov eax, 0x00000000</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>: <strong>ese</strong> es tu 0.</p>

<p>&ldquo;¿Y a mí cuál?&rdquo;</p>

<p>Meh, no mucho. Sólo quería dejar en claro cómo funciona esto: C es una mini abstracción de la programación en Assembler, por lo que no está tan lejos. No tenés que ser un capo de Assembler para programar C<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> (no necesitás saber Assembler, siquiera), pero tenés que tener un claro entendimiento de cómo funciona la computadora a bajo nivel para entender qué es lo que está haciendo tu código.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>La memoria de una PC tiene muchísimo más tamaño, pero dejame hacerla dibujable.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>C es un lenguaje. Decir &ldquo;C hizo tal cosa&rdquo; es medio vago: probablemente sea algo que hizo el compilador, o el sistema operativo, o alguna biblioteca más o menos estándar. Cuando decimos &ldquo;C hizo tal cosa&rdquo; es porque: a) no nos interesa mucho quién lo hizo (importa que lo hizo <em>otra persona</em>, y que es más o menos lo mismo para cualquier programa en C), o b) no sabemos quién lo hizo (y nos da fiaca averiguarlo, de momento).<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>No se Assembler, creo que el parámetro no va en la misma línea que el <code>mov</code>, pero anda por ahí cerca.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Lo aclaré en la anterior: no se Assembler.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variables]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/20/variables/"/>
    <updated>2013-08-20T01:21:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/20/variables</id>
    <content type="html"><![CDATA[<p>Bien. Escribimos, compilamos y corrimos nuestro primer programa. Pero es como bastante aburrido, ¿no? Vamos a ponerle onda: declaremos una variable (¡iupi! (¿?))</p>

<figure class='code'><figcaption><span>ok.c (v2) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Guau. Me la jugué :) Anoche no dormí porque me quedé debuggeando un error en este programa.<!--more--></p>

<p>¿Qué cambió? Bueno, entre las llaves hay dos instrucciones ahora. En principio, donde antes decía <code>return 0;</code>, ahora dice <code>return exit_status;</code>.</p>

<p>&ldquo;Así que seguramente <code>exit_status</code> sea una variable mágica de C, como <code>$?</code> en bash&rdquo; Pendorcho. <code>exit_status</code> es una variable, sí. Osea, es un identificador de un <em>cacho&#8217;e memoria</em>. Puedo guardar <em>cosas</em> ahí, y luego leerlas. Pero antes necesito declararla, para decir: a) que existe; y b) qué tipo de cosas va a manejar esa variable. Y eso es lo que hicimos antes: <code>int exit_status = 0;</code>.</p>

<p>Para declarar una variable, especificamos su tipo de dato, seguido por su nombre. En nuestro caso, <code>int exit_status</code> crea una variable de tipo <code>int</code> llamada <code>exit_status</code>. Declaraciones válidas son <code>int hola;</code> o <code>int hola, chau;</code>, por ejemplo: la primera declara una variable <code>hola</code> de tipo <code>int</code>, mientras que la segunda crea <code>hola</code> y <code>chau</code>, dos variables de tipo <code>int</code>, ambas totalmente independientes entre sí.</p>

<p>Pero con declarar la variable no alcanza: si queremos devolverla o leerla, primero tenemos que darle un valor (&ldquo;inicializarla&rdquo;, para los amigos). En C, las asignaciones son del estilo <code>variable = expresion;</code>, donde, en nuestro caso original, <code>expresion</code> es un triste <code>0</code> constante. Y ahí tenemos nuestra primera línea: <code>int exit_status = 0;</code>.</p>

<p>&ldquo;Che, y, entonces, si no es una variable mágica de C, ¿por qué se llama <code>exit_status</code> y no, por ejemplo, <code>a</code>, <code>bleh</code> o <code>code</code>?&rdquo; Bueno, porque nosotros <strong>sí</strong> fuimos a la clase de nombres bonitos y representativos :) Y si esa variable representa nuestro estado de salida, así la llamaremos<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Podríamos haberla llamado <code>a</code>, <code>bleh</code>, <code>code</code> o <code>__a256723b</code>, pero preferimos reservarnos los nombres horribles para las PPT :)</p>

<p>Buen, a ver qué hace este programa:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>Compilamos y ejecutamos, y vemos que sigue sin mostrar nada. Hacemos el <code>echo</code> y vemos nuestro hermoso 0.</p>

<p>&ldquo;Che, para mí que éste nos está chamuyando y el 0 está hardcodeado por ahí&rdquo;</p>

<p>OK, cambiémoslo:</p>

<figure class='code'><figcaption><span>ok.c (v2.1) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y probemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>&ldquo;¡Ajá! ¡Te dije que nos mentía!&rdquo;</p>

<p>¡Momento, cerebrito! No recompilaste, chámpion ;&ndash;)</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p><em>¡Touché!</em></p>

<p>&ldquo;OK, ganaste. Ahora, si necesito recompilarpara cambiar el valor de una variable, muy variable no me parece. Y podría cambiar el 0 por un 1 en la primer versión de <code>ok.c</code>, y no tengo que andar haciendo tanta parafernalia. ¿Por qué se llaman <em>variables</em>?&rdquo;</p>

<p>Buen, sí, justamente, porque podés cambiarles el valor durante una misma ejecución del programa. Así como inicializamos <code>exit_status</code> en 0 o en 1, podríamos después de esa incialización <em>asignarle</em> un nuevo valor. Desde que se ejecute esa instrucción en adelante, cada vez que se lea el contenido de la variable obtendremos el nuevo valor, como si nunca hubiera tenido un valor distinto:</p>

<figure class='code'><figcaption><span>ok.c (v2.2) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p><code>=</code> es el operador de asignación. El resultado de evaluar lo que esté a su derecha (ya veremos alternativas, pero por ahora quedémonos con que los números evalúan a sí mismos) se almacena en el espacio de memoria referido a la izquierda.
Y, ¿qué pasó con el 0? Se perdió. El 0 sigue existiendo y valiendo 0, como siempre. Sólo que el contenido de la variable <code>exit_status</code> se sobreescribe con <code>1</code>: la asignación es <em>destructiva</em>.</p>

<p>Sigamos jugando con esto:</p>

<figure class='code'><figcaption><span>ok.c (v2.3) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">exit_status</span> <span class="o">=</span> <span class="n">a_number</span><span class="p">;</span>
</span><span class='line'>  <span class="n">a_number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p>&ldquo;¡Eh! ¡¿Qué onda?! Si <code>exit_status</code> es igual a <code>a_number</code>, y a <code>a_number</code> le asigno <code>3</code>, ¿por qué el estado de salida es <code>1</code>?&rdquo;</p>

<p>Bueno, porque te olvidaste lo que dije de la asignación: en lo que está a la izquierda del <code>=</code> guardo el resultado de evaluar lo que está a <em>la otra izquierda</em> del mismo (comunmente conocida como &ldquo;derecha&rdquo;). Y nada más que eso: las variables no se ligan, ni quedan relacionadas, ni nada. Las variables se evalúan a su contenido del momento en que se ejecuta la instrucción, por lo que al hacer <code>exit_status = a_number;</code> estamos diciendo &ldquo;en <code>exit_status</code> guardame lo que <code>a_number</code> valga en ese momento&rdquo;. Como <code>a_number</code> venía valiendo 1, <code>exit_status</code> pasa a valer 1 también. Que después modifiquemos <code>a_number</code> es otra canción, y no tiene ninguna relación con esa asignación que ya se hizo: lo hecho, hecho está, y si al evaluar la variable ésta valía 1, los posibles valores que tenga después no importan, porque ya se realizó la asignación.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Hay miles de debates sobre escribir código en inglés vs español. No prometo ser constante durante la guía, pero tiendo a codificar en inglés. Comercialmente hablando, ~todos deseamos que nos compre Google, tercerizar el desarrollo a India, o pedir ayuda con los problemas en <a href="http://stackoverflow.com/">StackOverflow</a>. Pero, si escribir en inglés hará que no entiendas lo que representa cada cosa (cargándote la clase de nombres descriptivos), dale con el español. El piso mínimo que deberías tener es que todo el equipo (sea del TP, o de un trabajo <em>de posta</em>) use la misma convención. Y atenti con el tema de caracteres acentuados y eso, que a ¡¡50!! años de inventarse <a href="http://es.wikipedia.org/wiki/ASCII">el código ASCII</a> seguimos encontrándonos caracteres mochos por ahí, y, en el peor de los casos, puede hacernos fallar la compilción por problemas de encoding. Nadie quiere eso.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arrancando]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/19/arrancando/"/>
    <updated>2013-08-19T21:59:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/19/arrancando</id>
    <content type="html"><![CDATA[<p>Vamos a hacer un programa en C, por lo que empezamos con una función:</p>

<figure class='code'><figcaption><span>ok.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este es (aproximadamente) el programa más chico que podamos hacer en C. <code>main()</code> es la función que se ejecuta al ejecutar un programa C. En este caso, el prototipo de la función es <code>int main(void)</code>: nuestro programa no recibirá parámetros (<code>void</code>), y devolverá a quién lo ejecute un entero signado (<code>int</code>).<!--more--></p>

<p>Nuestro programa tiene una única instrucción: devolver (<code>return</code>) 0, un código de salida que, por convención, indica que el programa ejecutó correctamente.
Compilemos nuestro programa:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>ok.c ok
</span></code></pre></td></tr></table></div></figure>


<p><code>gcc</code> es el compilador más usado de C. Parte de la GNU Compiler Collection, <code>gcc</code> es el compilador específico de C (el proyecto se llamaba GNU C Compiler, pero cambiaron el nombre por soportar también C++, Java y tantos otros lenguajes). Como casi todo comando en Linux, Unix y derivados, podemos leer su manual haciendo <code>man gcc</code>.</p>

<p><code>gcc</code> recibe como parámetro (entre tantos otros) el archivo fuente a compilar (<code>ok.c</code>), y el parámetro <code>-o NOMBRE</code> indica qué nombre queremos darle al binario resultante (<code>ok</code>). De no indicarlo, <code>gcc</code> elije uno <em>hermoso</em>: <code>a.out</code>.</p>

<p>Ejecutemos:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure>


<p>Hay un 0, así que debemos estar <em>no-tan-mal</em>, como mínimo. ¿Qué pasó acá?</p>

<p>En UNIX, la forma de ejecutar un programa es escribiendo como orden la ruta completa al mismo y, luego, separados por espacios, todos sus parámetros. Por ejemplo:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/bin/ps --version
</span><span class='line'>procps-ng version 3.3.3
</span></code></pre></td></tr></table></div></figure>


<p>Ejecutamos el programa <code>/bin/ps</code> con el parámetro <code>--version</code>. <code>ps</code> nos contesta la versión que tenemos instalada. En nuestro caso anterior, ejecutamos <code>./ok</code>. <code>.</code> y <code>..</code> son dos enlaces especiales que hay en todo directorio: <code>.</code> enlaza al directorio actual (el propio directorio que contiene a <code>.</code>), y <code>..</code> enlaza al directorio padre del actual (osea, al directorio que contiene al directorio que contiene a <code>..</code>). Entonces, al escribir <code>.</code> ya estamos referenciando toda la ruta al directorio actual. Si estamos ubicados en <code>/home/utnso</code>, <code>.</code> y <code>/home/utnso</code> se refieren al mismo directorio. Agregándole <code>/ok</code> queda <code>./ok</code>, que equivale a <code>/home/utnso/ok</code>, la ruta completa a nuestro programa. Hell yeah, ruta completa => ¡ejecutamos el programa!</p>

<p>&ldquo;Che, pero&hellip; ¡No me mostró nada! ¿Dónde está mi 0?&rdquo;</p>

<p>Bueno, sí, es cierto. No muestra nada porque no le pedimos que muestre nada: nuestro programa sólo devuelve un 0, y nuestra consola sólo ejecuta las instrucciones que le damos. Entonces, pidámosle que muestre el resultado: <code>echo $?</code>.</p>

<p>&ldquo;¡Que te recontra!&rdquo; Bueno, sí. <a href="http://en.wikipedia.org/wiki/Stephen_R._Bourne">El amigo Bourne</a> había faltado a la clase de nombres descriptivos. <code>echo</code> es un comando de las consolas que imprime en pantalla<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> lo que sea que le pasemos por parámetro. Por ejemplo, <code>echo Hola mundo</code> imprime <code>Hola mundo</code>. <code>bash</code> (el lenguaje que interpreta nuestra consola) posee variables, y para dereferenciarlas (leerlas) hay que anteponerle un <code>$</code> al nombre de la variable. Por ejemplo (<code>#</code> es el caracter de comentario):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ nombre</span> <span class="o">=</span> <span class="s2">&quot;Mundo&quot;</span> <span class="c"># asigno &quot;Mundo&quot; a la variable nombre, creandola si no existe</span>
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$nombre</span> <span class="c"># imprimo el contenido de la variable llamada nombre</span>
</span><span class='line'>Mundo
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;Hola $nombre&quot;</span>
</span><span class='line'>Hola Mundo
</span></code></pre></td></tr></table></div></figure>


<p>En particular, nosotros le habíamos pedido mostrar una variable: <code>$?</code>. <code>?</code> es una variable manejada automáticamente por Bash. Cada vez que ejecuta una instrucción, Bash almacena en <code>?</code> el código de salida del programa ejecutado. Por eso, al pedirle que imprima la variable <code>?</code> (<code>echo $?</code>), Bash nos mostró el 0 que nuestro programa había devuelto.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>En realidad, imprime en la salida estándar, ya lo veremos más adelante. Por ahora, creeme que es la pantalla.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
