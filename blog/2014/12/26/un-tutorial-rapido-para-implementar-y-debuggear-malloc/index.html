
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Un tutorial rápido para implementar y debuggear malloc, free, calloc y realloc - C para Operativos</title>
  <meta name="author" content="mgarciaisaia">

  
  <meta name="description" content="Este post es mi traducción del post A Quick Tutorial on Implementing and Debugging Malloc, Free, Calloc, and Realloc de Dan Luu. Cualquier error o &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc">
  <link href="/tutorial-c/favicon.png" rel="icon">
  <link href="/tutorial-c/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/tutorial-c/atom.xml" rel="alternate" title="C para Operativos" type="application/atom+xml">
  <script src="/tutorial-c/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/tutorial-c/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<link rel="stylesheet" href="/tutorial-c/stylesheets/gh-fork-ribbon.css" />
<!--[if IE]>
<link rel="stylesheet" href="/tutorial-c/stylesheets/gh-fork-ribbon.ie.css" />
<![endif]-->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-59960325-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/tutorial-c/">C para Operativos</a></h1>
  
    <h2>Aprendiendo C para una cursada feliz de Sistemas Operativos</h2>
  
  </hgroup>

<div class="github-fork-ribbon-wrapper right">
	<div class="github-fork-ribbon">
		<a href="https://github.com/mgarciaisaia/octopress">¡Forkeame!</a>
	</div>
</div>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/tutorial-c/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mgarciaisaia.github.io/tutorial-c" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/tutorial-c/">Blog</a></li>
  <li><a href="/tutorial-c/blog/archives">Archives</a></li>
  <li><a href="/tutorial-c/lo-c-tutto/">Lo C Tutto</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Un Tutorial Rápido Para Implementar Y Debuggear Malloc, Free, Calloc Y Realloc</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-26T00:29:00-03:00" pubdate data-updated="true">Dec 26<span>th</span>, 2014</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p><em>Este post es mi traducción del post <a href="http://danluu.com/malloc-tutorial/">A Quick Tutorial on Implementing and Debugging Malloc, Free, Calloc, and Realloc</a> de <a href="https://twitter.com/danluu">Dan Luu</a>. Cualquier error o sugerencia sobre la traducción es bienvenida, y si querés que haga de intermediario para sugerirle cambios de contenido a él, también vale.</em></p>

<p>¡Implementemos nuestro propio <a href="http://man7.org/linux/man-pages/man3/malloc.3.html"><code>malloc</code></a> y veamos cómo funciona con programas pre-existentes!</p>

<p>Este tutorial asume que sabés qué es un puntero, y que <code>*ptr</code> dereferencia un puntero, y que <code>ptr-&gt;foo</code> significa <code>(*ptr).foo</code>, que <code>malloc</code> se usa para <a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/">reservar (<em>allocar</em>) espacio dinámicamente</a>, y que te es familiar el concepto de lista enlazada. Si decidís seguir este tutorial sin tener un claro conocimiento de C, contame qué partes convendría explicar un poco más. Si querés mirar todo el código de una, está disponible <a href="https://github.com/danluu/malloc-tutorial/blob/master/malloc.c">acá</a>.<!--more--></p>

<p>Presentaciones aparte, la firma de <code>malloc</code> es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Recibe un número de bytes y devuelve un puntero a un bloque de memoria de ese tamaño.</p>

<p>Hay varias formas de implementar esto. Nosotros vamos a elegir arbitrariamente utilizar la llamada al sistema <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html"><code>sbrk</code></a>. El sistema operativo reserva espacios de stack (<em>pila</em>) y heap (<em>montículo</em>) para los procesos, y <code>sbrk</code> nos permite manipular el heap. <code>sbrk(0)</code> devuelve un puntero al tope del heap. <code>sbrk(foo)</code> incrementa el tamaño del heap en <code>foo</code> bytes y devuelve un puntero al tope previo.</p>

<p><img src="http://danluu.com/images/malloc-tutorial/heap.png" alt="Diagrama del esquema de memoria de Linux, cortesía de Gustavo Duarte" /></p>

<p>Si queremos implementar un <code>malloc</code> realmente simple, podemos hacer algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;assert.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// sbrk failed.</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">request</span><span class="p">);</span> <span class="c1">// Not thread safe.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cuando un programa le pide espacio a <code>malloc</code>, éste se lo pide a <code>sbrk</code> para incrementar el tamaño del heap, y devuelve un puntero al inicio de la nueva región en el heap. Esta implementación falla en un tecnisismo, dado que <code>malloc(0)</code> debería devolver <code>NULL</code> u otro puntero que se le pueda pasar a <code>free</code> sin romper todo, pero básicamente funciona.</p>

<p>Pero, hablando de <code>free</code>&hellip; ¿Cómo funciona? Su prototipo es</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cuando le pasan a <code>free</code> un puntero que había sido devuelto por <code>malloc</code> debe liberar ese espacio. Pero si nos dan un puntero a algo reservado por nuestro <code>malloc</code>, no tenemos idea de cuál es el tamaño de ese bloque. ¿Dónde almacenamos eso? Si tuviéramos un <code>malloc</code> funcionando, podríamos <code>malloc</code>ear algo de espacio y guardarlo ahí, pero vamos a meternos en muchos problemas si necesitamos llamar a <code>malloc</code> para reservar espacio cada vez que llamamos a <code>malloc</code> para reservar espacio :)</p>

<p>Un truco común para evitar este problema es guardar meta-información sobre la región de memoria en el espacio previo al puntero que devolvemos. Supongamos que el tope del heap actual está en <code>0x1000</code> y pedimos <code>0x400</code> bytes. Nuestro <code>malloc</code> actual va a pedir <code>0x400</code> bytes a <code>sbrk</code> y devolver un puntero a <code>0x1000</code>. Si, en cambio, guardáramos, digamos, <code>0x10</code> bytes para almacenar información sobre el propio bloque, nuestro <code>malloc</code> pediría <code>0x410</code> bytes a <code>sbrk</code> y devolvería un puntero a <code>0x1010</code>, escondiendo nuestro bloque de <code>0x10</code> bytes de meta-información del código que está llamando a <code>malloc</code>.</p>

<p>Eso nos permite liberar un bloque, pero&hellip; ¿y ahora? Esa región de heap que nos da el SO tiene que ser contigua, entonces no podemos devolverle al SO un pedacito de memoria que esté en el medio. Incluso si quisiéramos copiar todos los datos que están después de la región liberada hacia adelante para rellenar el hueco, cosa de poder liberar el pedazo final del heap, no tenemos forma de actualizar todos los punteros que haya hacia esa zona de memoria a lo largo de todo nuestro programa.</p>

<p>En cambio, podemos marcar que esos bloques fueron liberados sin devolvérselos al SO, y en invocaciones futuras de <code>malloc</code> podríamos reusar esos bloques. Pero para hacer eso necesitamos poder acceder a la meta-información de cada bloque. Hay varias formas de hacerlo, nosotros vamos a elegir arbitrariamente hacerlo con una lista simplemente enlazada por cuestión de simplicidad.</p>

<p>Entonces, para cada bloque, queremos tener algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span> <span class="c1">// For debugging only. TODO: remove this in non-debug mode.</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define META_SIZE sizeof(struct block_meta)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Necesitamos saber el tamaño del bloque, si está o no libre, y cuál es el bloque siguiente. Hay también un número mágico ahí (el campo <code>magic</code>) para ayudarnos a debuggear, pero no es realmente necesario. Le vamos a asignar valores arbitrarios que nos van a permitir saber qué parte del código fue la última en modificar esa estructura.</p>

<p>También necesitamos un inicio para nuestra lista enlazada:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">global_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para nuestro <code>malloc</code>, queremos reusar el espacio libre si fuera posible, _alloc_ando espacio sólo cuando no podemos reusar el que ya tenemos. Dado que tenemos esta estructura de lista enlazada, buscar un bloque libre y devolverlo es casi trivial. Cuando tenemos un pedido de algún tamaño, iteramos nuestra lista buscando algún bloque libre con tamaño suficiente.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">find_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">**</span><span class="n">last</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">global_base</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
</span><span class='line'>    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si no encontramos un bloque que nos sirva, le tenemos que pedir ese espacio al SO usando <code>sbrk</code> y lo agregamos al final de nuestra lista.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">request_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">last</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">META_SIZE</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">block</span> <span class="o">==</span> <span class="n">request</span><span class="p">);</span> <span class="c1">// Not thread safe.</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// sbrk failed.</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// NULL on first request.</span>
</span><span class='line'>    <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como en nuestra implementación original, pedimos espacio usando <code>sbrk</code>, pero ahora le pedimos un poquito más de espacio para poder almacenar nuestra estructura, y además inicializamos los campos correctamente.</p>

<p>Ahora que tenemos las funciones auxiliares para ver si tenemos espacio libre y para pedirlo, nuestro <code>malloc</code> es simple. Si nuestro puntero base global es <code>NULL</code>, tenemos que pedir espacio y apuntar nuestro puntero base a ese nuevo bloque. Si no es <code>NULL</code>, buscamos si podemos reusar el espacio existente. Si podemos, lo hacemos, y si no pedimos espacio nuevo y lo usamos.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// TODO: align size?</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_base</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// First call.</span>
</span><span class='line'>    <span class="n">block</span> <span class="o">=</span> <span class="n">request_space</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">global_base</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">global_base</span><span class="p">;</span>
</span><span class='line'>    <span class="n">block</span> <span class="o">=</span> <span class="n">find_free_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Failed to find free block.</span>
</span><span class='line'>      <span class="n">block</span> <span class="o">=</span> <span class="n">request_space</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>      <span class="c1">// Found free block</span>
</span><span class='line'>      <span class="c1">// TODO: consider splitting block here.</span>
</span><span class='line'>      <span class="n">block</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>      <span class="n">block</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x77777777</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span><span class="p">(</span><span class="n">block</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para quienes no se lleven mucho con C, devolvemos <code>block+1</code> porque queremos devolver un puntero a la región siguiente a <code>block_meta</code>. Dado que <code>block</code> es un puntero del tipo <code>struct block_meta</code>, hacerle <code>+1</code> incrementa la dirección en <code>sizeof(struct block_meta)</code> bytes.</p>

<p>Si sólo quisiéramos un <code>malloc</code> sin un <code>free</code>, podríamos haber usado nuestro <code>malloc</code> original, mucho más simple. Entonces, ¡escribamos nuestro <code>free</code>! Lo principal que <code>free</code> tiene que hacer es setear el campo <code>-&gt;free</code>.</p>

<p>Como vamos a necesitar obtener la dirección de nuestro struct en varios lugares de nuestro código, definamos una función para ello:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="nf">get_block_ptr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ahora que lo tenemos, este es <code>free</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// TODO: consider merging blocks once splitting blocks is implemented.</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">block_ptr</span> <span class="o">=</span> <span class="n">get_block_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="mh">0x77777777</span> <span class="o">||</span> <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="mh">0x12345678</span><span class="p">);</span>
</span><span class='line'>  <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x55555555</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Además de asignar <code>-&gt;free</code>, es válido llamar a <code>free</code> con un puntero <code>NULL</code>, y por eso chequeamos por <code>NULL</code>. Como <code>free</code> no debería llamarse con cualquier dirección arbitraria o bloques que ya hayan sido liberados, <code>assert</code>eamos que esas cosas no pasen.</p>

<p>En realidad no es necesario <code>assert</code>ear nada, pero suele ayudar a debuggear. De hecho, cuando escribí este código tuve un bug que hubiera resultado en corromper silenciosamente los datos si los asserts no hubieran estado ahí. En cambio, el código falló por los <code>assert</code>s, y debuggear el problema se volvió trivial.</p>

<p>Ahora que tenemos <code>malloc</code> y <code>free</code>, ¡podemos escribir programas usando nuestro propio gestor de memoria! Pero antes de meter nuestro gestor en programas ya existentes, necesitamos implementar un par de funciones comunes más: <code>realloc</code> y <code>calloc</code>. <code>calloc</code> es simplemente un <code>malloc</code> que inicializa la memoria en 0, así que arranquemos por <code>realloc</code>. <code>realloc</code> debería ajustar el tamaño de un bloque de memoria que obtuvimos a través de <code>malloc</code>, <code>calloc</code> o <code>realloc</code>.</p>

<p>El prototipo de <code>realloc</code> es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si le pasamos un puntero a <code>NULL</code>, debería funcionar exactamente igual que <code>malloc</code>. Si le pasamos un puntero previamente <code>malloc</code>eado, debería liberar espacio si el tamaño es menor al previo, y asignar más espacio y copiar los datos existentes si el tamaño es mayor que el anterior.</p>

<p>Los programas pueden seguir funcionando si no hiciéramos lo de achicar el bloque o liberarlo, pero sí necesitamos reservar más espacio cuando el tamaño se incrementa, así que empecemos con eso:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// NULL ptr. realloc should act like malloc.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span><span class="o">*</span> <span class="n">block_ptr</span> <span class="o">=</span> <span class="n">get_block_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// We have enough space. Could free some once we implement split.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Need to really realloc. Malloc new space and free old space.</span>
</span><span class='line'>  <span class="c1">// Then copy old data to new space.</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">new_ptr</span><span class="p">;</span>
</span><span class='line'>  <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// TODO: set errno on failure.</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">memcpy</span><span class="p">(</span><span class="n">new_ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">block_ptr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">new_ptr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y ahora <code>calloc</code>, que simplemente inicializa la memoria antes de devolver el puntero:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nelem</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">elsize</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nelem</span> <span class="o">*</span> <span class="n">elsize</span><span class="p">;</span> <span class="c1">// TODO: check for overflow.</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notemos que no chequea overflows en <code>nelem * elsize</code>, requerido por la especificación. Todo este código es simplemente lo mínimo necesario para que las cosas más o menos funcionen.</p>

<p>Y ahora que tenemos algo que más o menos funciona, usémoslo con los programas ya existentes (¡sin siquiera recompilarlos!).</p>

<p>Primero que nada, necesitamos compilar nuestro código. En Linux, algo como:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>clang -O0 -g -W -Wall -Wextra -shared -fPIC malloc.c -o malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>debería funcionar.</p>

<p><code>-g</code> agrega los símbolos de debug, para poder mirar nuestro código con <code>gdb</code> o <code>lldb</code>. <code>-O0</code> va a ayudar a debuggear, evitando que en las optimizaciones se eliminen variables. <code>-W -Wall -Wextra</code> agrega warnings adicionales. <code>-shared -fPIC</code> nos permite linkear nuestro código dinámicamente, que es lo que nos permite <a href="http://jvns.ca/blog/2014/11/27/ld-preload-is-super-fun-and-easy/">usar nuestro código con binarios ya existentes</a>.</p>

<p>En Mac usaríamos algo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>clang -O0 -g -W -Wall -Wextra -dynamiclib malloc.c -o malloc.dylib
</span></code></pre></td></tr></table></div></figure>


<p>Notar que <code>sbrk</code> fue deprecado en las versiones recientes de OS X. Apple usa una definición poco ortodoxa de <em>deprecado</em> &ndash; algunas llamadas al sistema deprecadas directamente fallan. No probé esto en una Mac, así que puede que la implementación tenga fallas, o directamente no funcione en Mac.</p>

<p>Ahora, para que un binario use nuestro <code>malloc</code> en Linux, tenemos que setear la variable de entorno <code>LD_PRELOAD</code>. Si estás usando <code>bash</code>, podés hacerlo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">LD_PRELOAD</span><span class="o">=</span>/path/absoluto/a/malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>Si estás en Mac, el comando es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">DYLD_INSERT_LIBRARIES</span><span class="o">=</span>/path/absoluto/a/malloc.so
</span></code></pre></td></tr></table></div></figure>


<p>Si todo funciona, podés correr cualquier binario arbitrario y debería funcionar normalmente (excepto que será un poquito más lento).</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>Makefile  malloc.c  malloc.so  README.md  <span class="nb">test  test</span>-0  <span class="nb">test</span>-1  <span class="nb">test</span>-2  <span class="nb">test</span>-3  <span class="nb">test</span>-4
</span></code></pre></td></tr></table></div></figure>


<p>Si hubiera un bug, vas a ver algo así:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Debuggeando</h3>

<p>¡Hablemos de debugear! Si te es familiar el uso del debugger para poner breakpoints, inspeccionar la memoria y ejecutar paso a paso el código, podés saltear esta sección e ir directamente a <a href="#ejercicios">los ejercicios</a>.</p>

<p>Esta sección asume que podés instalar <code>gdb</code> en tu sistema. Si estás en Mac, probablemente quieras usar <code>lldb</code> y traducir los comandos apropiadamente. Como no tengo idea de qué bugs podés encontrarte, voy a introducir algunos bugs en el código para mostrarte cómo encontrarlos y resolverlos.</p>

<p>Primero, necesito poder correr <code>gdb</code> sin que genere un segmentation fault. Si <code>ls</code> <em>segfaultea</em> y tratamos de correr <code>gdb ls</code>, muy probablemente <code>gdb</code> vaya a segfaultear también. Podríamos escribir un wrapper para hacer esto, pero <code>gdb</code> también lo soporta. Si iniciamos <code>gdb</code> y después corremos <code>set environment LD_PRELOAD=./malloc.so</code> antes de correr el programa, <code>LD_PRELOAD</code> va a funcionar normalmente.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>0x00007ffff7bd7dbd in free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x0<span class="o">)</span> at malloc.c:113
</span><span class='line'>113       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span></code></pre></td></tr></table></div></figure>


<p>Como esperábamos, tenemos un segfault. Podemos usar <code>list</code> para ver el código alrededor del error:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> list
</span><span class='line'>108     <span class="o">}</span>
</span><span class='line'>109
</span><span class='line'>110     void free<span class="o">(</span>void *ptr<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>111       // TODO: consider merging blocks once splitting blocks is implemented.
</span><span class='line'>112       struct block_meta* <span class="nv">block_ptr</span> <span class="o">=</span> get_block_ptr<span class="o">(</span>ptr<span class="o">)</span>;
</span><span class='line'>113       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span><span class='line'>114       assert<span class="o">(</span>block_ptr-&gt;magic <span class="o">==</span> 0x77777777 <span class="o">||</span> block_ptr-&gt;magic <span class="o">==</span> 0x12345678<span class="o">)</span>;
</span><span class='line'>115       block_ptr-&gt;free <span class="o">=</span> 1;
</span><span class='line'>116       block_ptr-&gt;magic <span class="o">=</span> 0x55555555;
</span><span class='line'>117     <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y podemos usar <code>p</code> (<em>print</em>) para ver qué está pasando con las variables:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p ptr
</span><span class='line'><span class="nv">$6</span> <span class="o">=</span> <span class="o">(</span>void *<span class="o">)</span> 0x0
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p block_ptr
</span><span class='line'><span class="nv">$7</span> <span class="o">=</span> <span class="o">(</span>struct block_meta *<span class="o">)</span> 0xffffffffffffffe8
</span></code></pre></td></tr></table></div></figure>


<p><code>ptr</code> vale <code>0</code>, o sea, <code>NULL</code>, y esa es la causa del problema: nos olvidamos de chequear por <code>NULL</code>.</p>

<p>Ahora que encontramos eso, probemos con un bug un poco más complicado. Digamos que decidimos reemplazar nuestra estructura por:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">block_meta</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">block_meta</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>    <span class="c1">// For debugging only. TODO: remove this in non-debug mode.</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y devolver <code>block-&gt;data</code> en lugar de <code>block+1</code> en <code>malloc</code>, sin más cambios. Se parece bastante a lo que veníamos haciendo, sólo que ahora definimos un campo más que apunta al final de la estructura, y retornamos un puntero ahí.</p>

<p>Pero esto es lo que pasa si usamos nuestro nuevo <code>malloc</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/bin/ls
</span><span class='line'>Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>
</span><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run
</span><span class='line'>
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>_IO_vfprintf_internal <span class="o">(</span><span class="nv">s</span><span class="o">=</span>s@entry<span class="o">=</span>0x7fffff7ff5f0, <span class="nv">format</span><span class="o">=</span>format@entry<span class="o">=</span>0x7ffff7567370 <span class="s2">&quot;%s%s%s:%u: %s%sAssertion     `%s&#39; failed.\n%n&quot;</span>, <span class="nv">ap</span><span class="o">=</span>ap@entry<span class="o">=</span>0x7fffff7ff718<span class="o">)</span> at vfprintf.c:1332
</span><span class='line'>1332    vfprintf.c: No such file or directory.
</span><span class='line'>1327    in vfprintf.c
</span></code></pre></td></tr></table></div></figure>


<p>Este no es tan lindo como el error anterior &ndash; podemos ver que uno de nuestros <code>assert</code>s falló, pero <code>gdb</code> nos deja tirados dentro de una función de <code>printf</code>, llamada cuando un <code>assert</code> falla. Pero esa función usa nuestro <code>malloc</code> buggeado ¡y revienta!</p>

<p>Lo que podemos hacer es inspeccionar <code>ap</code> para ver qué era lo que <code>assert</code> trataba de imprimir:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p *ap
</span><span class='line'><span class="nv">$4</span> <span class="o">=</span> <span class="o">{</span><span class="nv">gp_offset</span> <span class="o">=</span> 16, <span class="nv">fp_offset</span> <span class="o">=</span> 48, <span class="nv">overflow_arg_area</span> <span class="o">=</span> 0x7fffff7ff7f0, <span class="nv">reg_save_area</span> <span class="o">=</span> 0x7fffff7ff730<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Eso funcionaría bien. Podemos jugar un poquito hasta encontrar qué es lo que pretendía imprimir, y encontrar el error de ese modo. Otras formas hubieran sido implementar nuestro propio <code>assert</code> o usar los <em>hooks</em> correctos para prevenir que <code>assert</code> use nuestro <code>malloc</code>.</p>

<p>Pero, en este caso, nosotros sabemos que hay sólo unos pocos <code>assert</code>s en nuestro código: el de <code>malloc</code>, garantizando que no estemos usandolo en un programa multihilo, y los dos de <code>free</code> chequeando que no estemos liberando algo que no debiéramos. Miremos primero <code>free</code>, poniendo un <em>breakpoint</em>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gdb /bin/ls
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>environment <span class="nv">LD_PRELOAD</span><span class="o">=</span>./malloc.so
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>free
</span><span class='line'>Breakpoint 1 at 0x400530
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> run /bin/ls
</span><span class='line'>
</span><span class='line'>Breakpoint 1, free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x61c270<span class="o">)</span> at malloc.c:112
</span><span class='line'>112       <span class="k">if</span> <span class="o">(</span>!ptr<span class="o">)</span> <span class="o">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>Aún no asignamos <code>block_ptr</code>, pero si hacemos <code>s</code> un par de veces para avanzar hasta después de que fuera asignado, podemos ver que su valor es:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> s
</span><span class='line'>free <span class="o">(</span><span class="nv">ptr</span><span class="o">=</span>0x61c270<span class="o">)</span> at malloc.c:118
</span><span class='line'>118       assert<span class="o">(</span>block_ptr-&gt;free <span class="o">==</span> 0<span class="o">)</span>;
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *block_ptr
</span><span class='line'><span class="nv">$11</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0, <span class="nv">next</span> <span class="o">=</span> 0x78, <span class="nv">free</span> <span class="o">=</span> 0, <span class="nv">magic</span> <span class="o">=</span> 0, <span class="nv">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Estoy usando <code>p/x</code> en vez de <code>p</code> para poder verlo en hexadecimal. El campo <code>magic</code> está en 0, que debería ser imposible para una estructura válida para liberar. ¿Puede que <code>get_block_ptr</code> esté devolviendo un offset incorrecto? Tenemos <code>ptr</code> disponible, así que podemos inspeccionar distintos offsets. Dado que es un <code>void *</code>, vamos a tener que castearlo para que <code>gdb</code> sepa cómo interpretar los resultados:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p sizeof<span class="o">(</span>struct block_meta<span class="o">)</span>
</span><span class='line'><span class="nv">$12</span> <span class="o">=</span> 32
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-32<span class="o">)</span>
</span><span class='line'><span class="nv">$13</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x0, <span class="nv">next</span> <span class="o">=</span> 0x78, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x0, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x0<span class="o">}}</span>
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-28<span class="o">)</span>
</span><span class='line'><span class="nv">$14</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x7800000000, <span class="nv">next</span> <span class="o">=</span> 0x0, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x0, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x78<span class="o">}}</span>
</span><span class='line'><span class="o">(</span>gdb<span class="o">)</span> p/x *<span class="o">(</span>struct block_meta*<span class="o">)(</span>ptr-24<span class="o">)</span>
</span><span class='line'><span class="nv">$15</span> <span class="o">=</span> <span class="o">{</span><span class="nv">size</span> <span class="o">=</span> 0x78, <span class="nv">next</span> <span class="o">=</span> 0x0, <span class="nv">free</span> <span class="o">=</span> 0x0, <span class="nv">magic</span> <span class="o">=</span> 0x12345678, <span class="nv">data</span> <span class="o">=</span> <span class="o">{</span>0x6e<span class="o">}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si miramos un poco la dirección que estamos usando, podemos ver que el offset correcto es 24 y no 32. Lo que está pasando es que la estructura tiene <em>padding</em>, es decir, está siendo alineada al tamaño de palabra del procesador. Entonces, <code>sizeof(struct block_meta)</code> es 32, incluso aunque el último campo válido esté en 24. Si queremos remover ese espacio extra, tenemos que arreglar <code>get_block_ptr</code>.</p>

<p>¡Y eso fue todo el debugging!</p>

<h3><a name="ejercicios">Ejercicios</a></h3>

<p>Personalmente, estas cosas no me quedan hasta que no hago un par de ejercicios, así que voy a dejar algunos acá para quienes les interese.</p>

<ol>
<li>Se espera que <code>malloc</code> devuelva un puntero <em>convenientemente alineado a cualquier tipo nativo</em>. ¿Hace eso el nuestro? Si lo hace, ¿por qué? Si no, corregilo. Notá que &ldquo;cualquier tipo nativo&rdquo; es, básicamente, 8 bytes en C, dado que los tipos de SSE/AVX no son nativos.</li>
<li>Nuestro <code>malloc</code> desperdicia un montón de espacio si reusamos un bloque sin necesitar <em>tanto</em> tamaño. Implementá una función que lo divida en bloques que ocupen el espacio mínimo necesario.</li>
<li>Después de hacer <code>2</code>, si llamamos a <code>malloc</code> y <code>free</code> muchas veces con tamaños aleatorios, terminaremos con un montón de bloques pequeños que sólo se pueden reusar si pedimos cantidades pequeñas de memoria. Implementá un mecanismo que una bloques libres adyacentes para que varios bloques consecutivos se unan en uno solo.</li>
<li>¡Encontrá bugs en el código existente! No lo testeé demasiado, así que <em>tienen que</em> haber bugs, por más que esto más o menos funcione.</li>
</ol>


<h2>Parte 2 en adelante</h2>

<p>A continuación vamos a ver cómo hacer que esto sea más rápido y que sea <em>thread safe</em>.</p>

<h3>Recursos</h3>

<p>Leí <a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf">este tutorial</a> de Marwan Burelle antes de sentarme a escribir mi propia implementación, así que se parece bastante. Las principales diferencias son que mi versión es más simple, pero más vulnerable a la fragmentación de memoria. En términos de exposición, mi estilo es bastante más informal. Si querés algo más formal, el Dr. Burelle es tu camino a seguir.</p>

<p>Para saber más sobre cómo Linux maneja la memoria, mirá <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">este post</a> de Gustavo Duarte.</p>

<p>Para saber más sobre cómo funcionan las implementaciones reales de <code>malloc</code>, <a href="http://g.oswego.edu/dl/html/malloc.html">dlmalloc</a> y <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">tcmalloc</a> son dos grandes lecturas. No leí el código de <a href="http://www.canonware.com/jemalloc/">jemalloc</a>, y escuché que es un poco más difícil de entender, pero es una de las implementaciónes de [malloc] de alta performance más usadas que hay.</p>

<p>Para ayuda debuggeando, <a href="https://code.google.com/p/address-sanitizer/wiki/AddressSanitizer">Address Sanitizer</a> la rompe. Y si querés escribir una versión thread-safe, <a href="https://code.google.com/p/data-race-test/wiki/ThreadSanitizer">Thread Sanitizer</a> también es una gran herramienta.</p>

<h3>Agradecimientos</h3>

<p>Gracias a Gustavo Duarte por permitirme usar una de sus imágenes para ilustrar <code>sbrk</code>, a Ian Whitlock y Danielle Sucher por encontrar algunos <em>typos</em>, a Nathan Kurz por sus sugerencias sobre los recursos adicionales, y a &ldquo;tedu&rdquo; por encontrar un bug. Por favor, <a href="https://twitter.com/danluu">avisame</a> si encontrás otros bugs en este post (tanto en el texto como en el código).</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">mgarciaisaia</span></span>

      








  


<time datetime="2014-12-26T00:29:00-03:00" pubdate data-updated="true">Dec 26<span>th</span>, 2014</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="/tutorial-c//twitter.com/share" class="twitter-share-button" data-url="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/" data-via="" data-counturl="http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="small"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/tutorial-c/blog/2014/09/04/p-sherman-calle-wallaby-42-sydney/" title="Previous Post: P. Sherman, Calle Wallaby 42, Sydney">&laquo; P. Sherman, Calle Wallaby 42, Sydney</a>
      
      
        <a class="basic-alignment right" href="/tutorial-c/blog/2014/12/26/compiladores-y-errores/" title="Next Post: Compiladores Y Errores">Compiladores Y Errores &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Acerca de...</h1>
  <p>Pequeña introducción a C y otras herramientas necesarias para desarrollar el TP de Sistemas Operativos de la UTN FRBA</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/04/23/rutas-argentinas/">Rutas Argentinas</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/27/dream-of-serialization/">Dream of Serialization</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/24/aprendiendo-c-con-gdb/">Aprendiendo C Con GDB</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/19/aprendiendo-assembler-para-entender-c/">Aprendiendo Assembler Para Entender C</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/07/between-a-rock-and-a-hard-link/">Between a Rock and a Hard Link</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/int-vs-int32-t/">Int vs Int32_t</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/compiladores-y-errores/">Compiladores Y Errores</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/">Un Tutorial Rápido Para Implementar Y Debuggear Malloc, Free, Calloc Y Realloc</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/09/04/p-sherman-calle-wallaby-42-sydney/">P. Sherman, Calle Wallaby 42, Sydney</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/03/20/she-bangs-she-bangs/">She Bangs, She Bangs...</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/">Me Dí Cuenta Que Me Tiraste La Señal</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/12/30/inotify/">Inotify</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/10/21/bajando-el-nivel/">Bajando El Nivel</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/08/20/variables/">Variables</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/08/19/arrancando/">Arrancando</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/sisoputnfrba">@sisoputnfrba</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'sisoputnfrba',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/tutorial-c/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - mgarciaisaia -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'tutorialc';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/';
        var disqus_url = 'http://mgarciaisaia.github.io/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
