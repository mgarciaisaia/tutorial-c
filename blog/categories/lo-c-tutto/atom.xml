<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lo-c-tutto | C para Operativos]]></title>
  <link href="http://mgarciaisaia.github.io/tutorial-c/blog/categories/lo-c-tutto/atom.xml" rel="self"/>
  <link href="http://mgarciaisaia.github.io/tutorial-c/"/>
  <updated>2014-12-26T20:11:29-03:00</updated>
  <id>http://mgarciaisaia.github.io/tutorial-c/</id>
  <author>
    <name><![CDATA[mgarciaisaia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bajando el nivel]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/10/21/bajando-el-nivel/"/>
    <updated>2013-10-21T01:19:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/10/21/bajando-el-nivel</id>
    <content type="html"><![CDATA[<p>&ldquo;Che, me acabás de decir que el 0 sigue existiendo por más que <em>lo pise</em> con otro valor. ¿El 0 es un objeto al que la VM le mantiene referencias y por eso no se lo lleva el Garbage Collector?&rdquo;<!--more--></p>

<p>What!? No way, papá. Por un cuatrimestre, las palabras &ldquo;objeto&rdquo; y &ldquo;Garbage Collector&rdquo; dejalas en la oficina, y VM = VirtualBox :)</p>

<p>En C no hay objetos.</p>

<p>Perdón si fui duro, pero es necesario: en C no hay objetos. Y no hay GC.</p>

<p>&ldquo;Entonces, ¿qué es el 0?&rdquo;</p>

<p>El 0 es una constante. Si recordás, en Arquitectura (bazinga) vimos que los números se representan en binario en la PC. Las variables de C son meras referencias a algún bloque de memroia, siendo el tipo de la variable el que anuncia qué tamaño tiene esa referencia.</p>

<p>Digamos, esto es una memoria de 30 bytes<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (éramos tan pobres):</p>

<p><img src="/assets/memoria-libre.png" alt="Una RAM de 30 bytes" /></p>

<p>Esa es toda la memoria de esta computadora hipotética. Si en mi programa declaro una variable <code>int exit_status;</code>, podríamos pensarlo como que C hará algo así:</p>

<p><img src="/assets/memoria-reservada.png" alt="La RAM con una variable" /></p>

<p>En algún lugar de la memoria (en este caso, a partir del byte 13), C reservó<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> unos bytes para nuestra variable ¿Cuántos bytes reservó? Eso depende del tipo de dato que le declaramos a la variable. Por definición, el tipo <code>int</code> equivale al <a href="http://es.wikipedia.org/wiki/Palabra_(inform%C3%A1tica)">tamaño de palabra del procesador</a>. Esto significa que en máquinas de 32 bits (como esta computadora hipotética, o las VMs de la cátedra, o la enorme mayoría de los Windows XP y Vista), un <code>int</code> va a ocupar 4 bytes (32 bits).</p>

<p>Entonces, al hacer algo como <code>exit_status = 0;</code> (y sabiendo que <code>exit_status</code> es una variable entera de 4 bytes), el compilador sabe que tiene que hacer que los 4 bytes que están a partir del byte en que empieza <code>exit_status</code> valgan un 0. En Arquitectura aprendimos que los enteros con signo se representan usando el <a href="http://es.wikipedia.org/wiki/Complemento_a_dos">complemento a 2</a>, por lo que el 0 en 32 bits es simplemente <a href="http://es.wikipedia.org/wiki/Sistema_hexadecimal"><code>0x0000 0000</code></a> (4 bytes en 0).</p>

<p>Entonces, ¿dónde está ese 0? <a href="http://es.wikipedia.org/wiki/Hard_code">Hardcodeado</a> en el binario. Compilar un programa es pedirle al compilador (<code>gcc</code> en nuestro caso) que traduzca todo ese C hermoso que escribimos en las instrucciones de Assembler que nuestro procesador tiene que ejecutar para que el código funcione con nuestro sistema operativo. De todas esas, alguna va a ser algo como <code>mov eax, 0x00000000</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>: <strong>ese</strong> es tu 0.</p>

<p>&ldquo;¿Y a mí cuál?&rdquo;</p>

<p>Meh, no mucho. Sólo quería dejar en claro cómo funciona esto: C es una mini abstracción de la programación en Assembler, por lo que no está tan lejos. No tenés que ser un capo de Assembler para programar C<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> (no necesitás saber Assembler, siquiera), pero tenés que tener un claro entendimiento de cómo funciona la computadora a bajo nivel para entender qué es lo que está haciendo tu código.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>La memoria de una PC tiene muchísimo más tamaño, pero dejame hacerla dibujable.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>C es un lenguaje. Decir &ldquo;C hizo tal cosa&rdquo; es medio vago: probablemente sea algo que hizo el compilador, o el sistema operativo, o alguna biblioteca más o menos estándar. Cuando decimos &ldquo;C hizo tal cosa&rdquo; es porque: a) no nos interesa mucho quién lo hizo (importa que lo hizo <em>otra persona</em>, y que es más o menos lo mismo para cualquier programa en C), o b) no sabemos quién lo hizo (y nos da fiaca averiguarlo, de momento).<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>No se Assembler, creo que el parámetro no va en la misma línea que el <code>mov</code>, pero anda por ahí cerca.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Lo aclaré en la anterior: no se Assembler.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variables]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/20/variables/"/>
    <updated>2013-08-20T01:21:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/20/variables</id>
    <content type="html"><![CDATA[<p>Bien. Escribimos, compilamos y corrimos nuestro primer programa. Pero es como bastante aburrido, ¿no? Vamos a ponerle onda: declaremos una variable (¡iupi! (¿?))</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>ok.c (v2) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Guau. Me la jugué :) Anoche no dormí porque me quedé debuggeando un error en este programa.<!--more--></p>

<p>¿Qué cambió? Bueno, entre las llaves hay dos instrucciones ahora. En principio, donde antes decía <code>return 0;</code>, ahora dice <code>return exit_status;</code>.</p>

<p>&ldquo;Así que seguramente <code>exit_status</code> sea una variable mágica de C, como <code>$?</code> en bash&rdquo; Pendorcho. <code>exit_status</code> es una variable, sí. Osea, es un identificador de un <em>cacho'e memoria</em>. Puedo guardar <em>cosas</em> ahí, y luego leerlas. Pero antes necesito declararla, para decir: a) que existe; y b) qué tipo de cosas va a manejar esa variable. Y eso es lo que hicimos antes: <code>int exit_status = 0;</code>.</p>

<p>Para declarar una variable, especificamos su tipo de dato, seguido por su nombre. En nuestro caso, <code>int exit_status</code> crea una variable de tipo <code>int</code> llamada <code>exit_status</code>. Declaraciones válidas son <code>int hola;</code> o <code>int hola, chau;</code>, por ejemplo: la primera declara una variable <code>hola</code> de tipo <code>int</code>, mientras que la segunda crea <code>hola</code> y <code>chau</code>, dos variables de tipo <code>int</code>, ambas totalmente independientes entre sí.</p>

<p>Pero con declarar la variable no alcanza: si queremos devolverla o leerla, primero tenemos que darle un valor (&ldquo;inicializarla&rdquo;, para los amigos). En C, las asignaciones son del estilo <code>variable = expresion;</code>, donde, en nuestro caso original, <code>expresion</code> es un triste <code>0</code> constante. Y ahí tenemos nuestra primera línea: <code>int exit_status = 0;</code>.</p>

<p>&ldquo;Che, y, entonces, si no es una variable mágica de C, ¿por qué se llama <code>exit_status</code> y no, por ejemplo, <code>a</code>, <code>bleh</code> o <code>code</code>?&rdquo; Bueno, porque nosotros <strong>sí</strong> fuimos a la clase de nombres bonitos y representativos :) Y si esa variable representa nuestro estado de salida, así la llamaremos<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Podríamos haberla llamado <code>a</code>, <code>bleh</code>, <code>code</code> o <code>__a256723b</code>, pero preferimos reservarnos los nombres horribles para las PPT :)</p>

<p>Buen, a ver qué hace este programa:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Compilamos y ejecutamos, y vemos que sigue sin mostrar nada. Hacemos el <code>echo</code> y vemos nuestro hermoso 0.</p>

<p>&ldquo;Che, para mí que éste nos está chamuyando y el 0 está hardcodeado por ahí&rdquo;</p>

<p>OK, cambiémoslo:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>ok.c (v2.1) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Y probemos:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>&ldquo;¡Ajá! ¡Te dije que nos mentía!&rdquo;</p>

<p>¡Momento, cerebrito! No recompilaste, chámpion ;&ndash;)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><em>¡Touché!</em></p>

<p>&ldquo;OK, ganaste. Ahora, si necesito recompilarpara cambiar el valor de una variable, muy variable no me parece. Y podría cambiar el 0 por un 1 en la primer versión de <code>ok.c</code>, y no tengo que andar haciendo tanta parafernalia. ¿Por qué se llaman <em>variables</em>?&rdquo;</p>

<p>Buen, sí, justamente, porque podés cambiarles el valor durante una misma ejecución del programa. Así como inicializamos <code>exit_status</code> en 0 o en 1, podríamos después de esa incialización <em>asignarle</em> un nuevo valor. Desde que se ejecute esa instrucción en adelante, cada vez que se lea el contenido de la variable obtendremos el nuevo valor, como si nunca hubiera tenido un valor distinto:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>ok.c (v2.2) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">exit_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>=</code> es el operador de asignación. El resultado de evaluar lo que esté a su derecha (ya veremos alternativas, pero por ahora quedémonos con que los números evalúan a sí mismos) se almacena en el espacio de memoria referido a la izquierda.
Y, ¿qué pasó con el 0? Se perdió. El 0 sigue existiendo y valiendo 0, como siempre. Sólo que el contenido de la variable <code>exit_status</code> se sobreescribe con <code>1</code>: la asignación es <em>destructiva</em>.</p>

<p>Sigamos jugando con esto:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>ok.c (v2.3) </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">a_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">exit_status</span> <span class="o">=</span> <span class="n">a_number</span><span class="p">;</span>
</span><span class='line'><span class="n">a_number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">exit_status</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>&ldquo;¡Eh! ¡¿Qué onda?! Si <code>exit_status</code> es igual a <code>a_number</code>, y a <code>a_number</code> le asigno <code>3</code>, ¿por qué el estado de salida es <code>1</code>?&rdquo;</p>

<p>Bueno, porque te olvidaste lo que dije de la asignación: en lo que está a la izquierda del <code>=</code> guardo el resultado de evaluar lo que está a <em>la otra izquierda</em> del mismo (comunmente conocida como &ldquo;derecha&rdquo;). Y nada más que eso: las variables no se ligan, ni quedan relacionadas, ni nada. Las variables se evalúan a su contenido del momento en que se ejecuta la instrucción, por lo que al hacer <code>exit_status = a_number;</code> estamos diciendo &ldquo;en <code>exit_status</code> guardame lo que <code>a_number</code> valga en ese momento&rdquo;. Como <code>a_number</code> venía valiendo 1, <code>exit_status</code> pasa a valer 1 también. Que después modifiquemos <code>a_number</code> es otra canción, y no tiene ninguna relación con esa asignación que ya se hizo: lo hecho, hecho está, y si al evaluar la variable ésta valía 1, los posibles valores que tenga después no importan, porque ya se realizó la asignación.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Hay miles de debates sobre escribir código en inglés vs español. No prometo ser constante durante la guía, pero tiendo a codificar en inglés. Comercialmente hablando, ~todos deseamos que nos compre Google, tercerizar el desarrollo a India, o pedir ayuda con los problemas en <a href="http://stackoverflow.com/">StackOverflow</a>. Pero, si escribir en inglés hará que no entiendas lo que representa cada cosa (cargándote la clase de nombres descriptivos), dale con el español. El piso mínimo que deberías tener es que todo el equipo (sea del TP, o de un trabajo <em>de posta</em>) use la misma convención. Y atenti con el tema de caracteres acentuados y eso, que a ¡¡50!! años de inventarse <a href="http://es.wikipedia.org/wiki/ASCII">el código ASCII</a> seguimos encontrándonos caracteres mochos por ahí, y, en el peor de los casos, puede hacernos fallar la compilción por problemas de encoding. Nadie quiere eso.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arrancando]]></title>
    <link href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/19/arrancando/"/>
    <updated>2013-08-19T21:59:00-03:00</updated>
    <id>http://mgarciaisaia.github.io/tutorial-c/blog/2013/08/19/arrancando</id>
    <content type="html"><![CDATA[<p>Vamos a hacer un programa en C, por lo que empezamos con una función:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>ok.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Este es (aproximadamente) el programa más chico que podamos hacer en C. <code>main()</code> es la función que se ejecuta al ejecutar un programa C. En este caso, el prototipo de la función es <code>int main(void)</code>: nuestro programa no recibirá parámetros (<code>void</code>), y devolverá a quién lo ejecute un entero signado (<code>int</code>).<!--more--></p>

<p>Nuestro programa tiene una única instrucción: devolver (<code>return</code>) 0, un código de salida que, por convención, indica que el programa ejecutó correctamente.
Compilemos nuestro programa:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gcc ok.c -o ok
</span><span class='line'><span class="nv">$ </span>ls
</span><span class='line'>ok.c ok
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>gcc</code> es el compilador más usado de C. Parte de la GNU Compiler Collection, <code>gcc</code> es el compilador específico de C (el proyecto se llamaba GNU C Compiler, pero cambiaron el nombre por soportar también C++, Java y tantos otros lenguajes). Como casi todo comando en Linux, Unix y derivados, podemos leer su manual haciendo <code>man gcc</code>.</p>

<p><code>gcc</code> recibe como parámetro (entre tantos otros) el archivo fuente a compilar (<code>ok.c</code>), y el parámetro <code>-o NOMBRE</code> indica qué nombre queremos darle al binario resultante (<code>ok</code>). De no indicarlo, <code>gcc</code> elije uno <em>hermoso</em>: <code>a.out</code>.</p>

<p>Ejecutemos:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./ok
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
</span><span class='line'>0
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Hay un 0, así que debemos estar <em>no-tan-mal</em>, como mínimo. ¿Qué pasó acá?</p>

<p>En UNIX, la forma de ejecutar un programa es escribiendo como orden la ruta completa al mismo y, luego, separados por espacios, todos sus parámetros. Por ejemplo:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/bin/ps &amp;mdash;version
</span><span class='line'>procps-ng version 3.3.3
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Ejecutamos el programa <code>/bin/ps</code> con el parámetro <code>--version</code>. <code>ps</code> nos contesta la versión que tenemos instalada. En nuestro caso anterior, ejecutamos <code>./ok</code>. <code>.</code> y <code>..</code> son dos enlaces especiales que hay en todo directorio: <code>.</code> enlaza al directorio actual (el propio directorio que contiene a <code>.</code>), y <code>..</code> enlaza al directorio padre del actual (osea, al directorio que contiene al directorio que contiene a <code>..</code>). Entonces, al escribir <code>.</code> ya estamos referenciando toda la ruta al directorio actual. Si estamos ubicados en <code>/home/utnso</code>, <code>.</code> y <code>/home/utnso</code> se refieren al mismo directorio. Agregándole <code>/ok</code> queda <code>./ok</code>, que equivale a <code>/home/utnso/ok</code>, la ruta completa a nuestro programa. Hell yeah, ruta completa => ¡ejecutamos el programa!</p>

<p>&ldquo;Che, pero&hellip; ¡No me mostró nada! ¿Dónde está mi 0?&rdquo;</p>

<p>Bueno, sí, es cierto. No muestra nada porque no le pedimos que muestre nada: nuestro programa sólo devuelve un 0, y nuestra consola sólo ejecuta las instrucciones que le damos. Entonces, pidámosle que muestre el resultado: <code>echo $?</code>.</p>

<p>&ldquo;¡Que te recontra!&rdquo; Bueno, sí. <a href="http://en.wikipedia.org/wiki/Stephen_R._Bourne">El amigo Bourne</a> había faltado a la clase de nombres descriptivos. <code>echo</code> es un comando de las consolas que imprime en pantalla<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> lo que sea que le pasemos por parámetro. Por ejemplo, <code>echo Hola mundo</code> imprime <code>Hola mundo</code>. <code>bash</code> (el lenguaje que interpreta nuestra consola) posee variables, y para dereferenciarlas (leerlas) hay que anteponerle un <code>$</code> al nombre de la variable. Por ejemplo (<code>#</code> es el caracter de comentario):</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ nombre</span> <span class="o">=</span> &amp;ldquo;Mundo&amp;rdquo; <span class="c"># asigno &amp;ldquo;Mundo&amp;rdquo; a la variable nombre, creandola si no existe</span>
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$nombre</span> <span class="c"># imprimo el contenido de la variable llamada nombre</span>
</span><span class='line'>Mundo
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> &amp;ldquo;Hola <span class="nv">$nombre</span>&amp;rdquo;
</span><span class='line'>Hola Mundo
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>En particular, nosotros le habíamos pedido mostrar una variable: <code>$?</code>. <code>?</code> es una variable manejada automáticamente por Bash. Cada vez que ejecuta una instrucción, Bash almacena en <code>?</code> el código de salida del programa ejecutado. Por eso, al pedirle que imprima la variable <code>?</code> (<code>echo $?</code>), Bash nos mostró el 0 que nuestro programa había devuelto.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>En realidad, imprime en la salida estándar, ya lo veremos más adelante. Por ahora, creeme que es la pantalla.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
