
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dream of Serialization - C para Operativos</title>
  <meta name="author" content="mgarciaisaia">

  
  <meta name="description" content="Disclaimer: escribí este post hace unos días, a mano, y, ahora que lo estoy releyendo para tipearlo en la compu, no me parece tan genial como cuando &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization">
  <link href="/tutorial-c/favicon.png" rel="icon">
  <link href="/tutorial-c/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/tutorial-c/atom.xml" rel="alternate" title="C para Operativos" type="application/atom+xml">
  <script src="/tutorial-c/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/tutorial-c/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<link rel="stylesheet" href="/tutorial-c/stylesheets/gh-fork-ribbon.css" />
<!--[if IE]>
<link rel="stylesheet" href="/tutorial-c/stylesheets/gh-fork-ribbon.ie.css" />
<![endif]-->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-59960325-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/tutorial-c/">C para Operativos</a></h1>
  
    <h2>Aprendiendo C para una cursada feliz de Sistemas Operativos</h2>
  
  </hgroup>

<div class="github-fork-ribbon-wrapper right">
	<div class="github-fork-ribbon">
		<a href="https://github.com/mgarciaisaia/octopress">¡Forkeame!</a>
	</div>
</div>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/tutorial-c/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mgarciaisaia.github.io/tutorial-c" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/tutorial-c/">Blog</a></li>
  <li><a href="/tutorial-c/blog/archives">Archives</a></li>
  <li><a href="/tutorial-c/lo-c-tutto/">Lo C Tutto</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Dream of Serialization</h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-27T00:30:00-03:00" pubdate data-updated="true">Feb 27<span>th</span>, 2015</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p><em>Disclaimer: escribí este post hace unos días, a mano, y, ahora que lo estoy releyendo para tipearlo en la compu, no me parece tan genial como cuando lo escribí la primera vez. Recomiendo tomarlo bastante más con pinzas que de costumbre, y donde encuentren algo que les haga ruido &ndash; o directamente sientan que lo que digo es incorrecto, o que el enfoque no es bueno &ndash; avisen, así lo rewordeo. Por favor, perdón y gracias.</em></p>

<p>Las variables de C son nombres que refieren a una posición de memoria de la computadora. El compilador traduce cada nombre a una dirección de memoria, y el tamaño de la variable está determinado por su tipo.</p>

<p>Pero si bien el estándar de C pone algunas restricciones a los tamaños de los tipos de datos básicos, no todos tienen igual tamaño en las distintas plataformas, o incluso entre distintos compiladores de C para la misma plataforma.<!-- more --></p>

<p>Además, para optimizar los accesos a memoria (operación lenta desde el punto de vista de la CPU), los compiladores suelen ubicar las variables <em>alineadas a la palabra de la CPU</em>. En general, la CPU no lee bytes individuales desde la memoria, si no que pide bloques del tamaño del ancho del bus de datos (4 bytes en máquinas de 32 bits, 8 en máquinas de 64 bits). Si una variable de 4 bytes estuviera ubicada en una posición no-múltiplo de 4 en un procesador de 32 bits, la CPU tendría que hacer 2 lecturas para accederla: una para leer el bloque de 4 bytes con los primeros bytes de la variable, y otra para el segundo bloque.</p>

<p>Esto aplica, también, a los <code>struct</code>s. Los campos de un <code>struct</code> se almacenan contiguamente en memoria, alineándose a la palabra. De hecho, <code>sizeof</code> nos va a devolver el tamaño del <code>struct</code> incluyendo los bytes de alineación (es decir, es muy probable que un <code>struct</code> compuesto por un <code>char</code> y un <code>int</code> &ndash; en ese orden &ndash; pese 8 bytes y no 5).</p>

<p>Todo esto fundamenta una única frase: no tenemos garantías sobre cómo van a organizarse los datos en un proceso que no sea el de nuestro propio programa. Encapsulamiento, que le dicen los hippies de Paradigmas :)</p>

<p>Entonces, ¿qué es la serialización? Bueno, es el arte de especificar un protocolo mediante el cual dos procesos van a comunicarse. Me encantaría poder hacer <code>send(socket, myStruct, sizeof(myStruct), ...)</code> y que eso funcione, pero si del otro lado me hacen <code>recv(socket, &amp;myStruct, sizeof(myStruct), ...)</code> no tengo ninguna garantía de que los bytes estén en el orden correcto<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (ni de que el otro proceso también haya estado hecho en C, o que exista un <code>struct</code> como el que tengo yo, etc).</p>

<p>En fin, no puedo confiar en que mi estructura pueda viajar <em>como está</em>, entonces especifico mi propio protocolo: si tengo que mandar una estructura que tiene un <code>char</code> y un <code>int</code>, especifico &ndash; por ejemplo &ndash; que siempre voy a mandar un primer byte con el <code>char</code> y luego otros 4 bytes con el <code>int</code>.</p>

<p>De este modo, en lugar de hacer el <code>send()</code> de hace un rato, seguramente prefiera primero armar un buffer para meter todo el mensaje contiguo (<em>serializado</em>), y hacer <code>send</code> de eso<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>:</p>

<figure class='code'><figcaption><span>Enviando una estructura medio primitivamente </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="p">.</span><span class="n">aChar</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="p">.</span><span class="n">anInt</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
</span><span class='line'><span class="n">send</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Del otro lado, al recibir la estructura, hago algo parecido: recibo 5 bytes (todo un mensaje), y copio el primer byte al <code>char</code>, y los 4 siguientes al <code>int</code>:</p>

<figure class='code'><figcaption><span>Recibiendo una estructura medio primitivamente </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="n">recv</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="k">struct</span> <span class="n">my_struct_t</span> <span class="o">*</span><span class="n">myStruct</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_struct_t</span><span class="p">));</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="o">-&gt;</span><span class="n">aChar</span><span class="p">),</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="o">-&gt;</span><span class="n">anInt</span><span class="p">),</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>De este modo, las estructuras de uno y otro lado están súper desacopladas: los campos podrían tener distintos nombres, podrían existir campos extras, tener distintas precisiones&hellip; Incluso podrían ser programas hechos en distintos lenguajes. Lo único que importa es que ambos extremos de la comunicación entiendan cómo deben interpretar esos bytes: si hago un programa en Prolog que relacione el primer byte recibido (andá a saber cómo) con un caracter, y los cuatro siguientes con un número, todos felices.</p>

<p>Es importante notar que tomamos decisiones re grosas: en nuestro protocolo, los caracteres son de 1 byte, y los enteros de 4, al menos para este mensaje. Si queremos hacer un cliente para plataformas cuyos <code>int</code> son de 2 bytes, vamos a tener que decidir cómo manejar los overflows (por ejemplo, usar variables de algún tipo más grande en nuestro <code>struct</code>, o truncar el valor recibido, o lo que sea), y mismo si estamos en 64 bits: nuestro <code>int</code> de 64 bits podría no ser representable en 4 bytes. No hay una receta universal para esto: son decisiones de diseño intrínsecas a nuestro problema.</p>

<h2>Manejando distintos mensajes</h2>

<p>Pero probablemente nuestro programa pueda/tenga que mandar y recibir distintos tipos de mensajes. Para saber de qué tipo de mensaje se trata, nuestro protocolo podría especificar que antes de enviar cada mensaje se envíe una cantidad fija de bytes que identifique qué tipo de mensaje estamos enviando, de modo que el receptor sepa cómo decodificarlo.</p>

<p>Otro problema frecuente es el de los mensajes de longitud variable: los <code>int</code>s pesan siempre lo mismo en una arquitectura determinada, pero el string <code>"hola"</code> no pesa lo mismo que <code>"Hola, che, ¿cómo te va?"</code>. ¿Cómo serializamos eso? ¿Cómo sabe el proceso remoto cuántos bytes tendría que <code>recv</code>ir para leer el mensaje completo?</p>

<p>Lo mejor es tratar de trabajar siempre con tamaños fijos, cosa de que de ambos extremos de la comunicación sepan cuántos bytes enviar y cuántos esperar recibir. Pero <em>tamaño fijo</em> podría interpretarse como <em>todos los strings que mando van a ser de 80 bytes</em> y, si bien en algunos casos (en los que la comunicación está bastante acotada y predefinida) eso puede ser suficiente, en muchos otros casos puede ser un problema: un tamaño fijo muy grande desperdicia muchos bytes para mensajes chicos (imaginen mandar 1MB por internet sólo para decir &ldquo;Hola&rdquo;), y tamaños muy chicos podrían obligarnos a truncar los mensajes o tener que pensar algún mecanismo para mandar el mensaje en varias partes<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>Entonces, hagamos algo mejor: elijamos una cantidad fija de bytes en la que especificar <em>cuánto mide nuestro string</em>, y enviemos ese número primero, y luego todos los bytes que conforman el mensaje. De este modo, el cliente siempre recibe una cantidad fija de bytes (por ejemplo, 4), interpreta esos bytes como un número, y luego recibe esa cantidad de bytes como mensaje:</p>

<figure class='code'><figcaption><span>Enviando mensajes de longitud variable </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">size_t</span> <span class="n">messageLength</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">messageLength</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">messageLength</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">messageLength</span><span class="p">);</span>
</span><span class='line'><span class="n">send</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">messageLength</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y el cliente:</p>

<figure class='code'><figcaption><span>Recibiendo mensajes de longitud variable </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">size_t</span> <span class="n">messageLength</span><span class="p">;</span>
</span><span class='line'><span class="n">recv</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">messageLength</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">messageLength</span><span class="p">);</span>
</span><span class='line'><span class="n">recv</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">messageLength</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>De este modo, el cliente no se bloquea, porque siempre sabe cuánto debe recibir.</p>

<p>Ojo que nosotros enviamos <code>strlen(message)</code> bytes, por lo que el <code>\0</code> que termina los strings en C no viajó: si queremos que lo que recibimos sea un string, tenemos que agregarlo a mano al final del mensaje (y reservar un byte más en el <code>malloc</code> del receptor)<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>

<p>También es importante notar que lo que enviamos es el contenido del string, y no el puntero. Para mandar un <code>int</code>, a send le pasamos <code>&amp;myInt</code>, porque lo que necesita es un puntero a los bytes a enviar. Pero para mandar un string, en los ejemplos que vimos acá le pasamos directamente <code>myString</code>, porque ese es el puntero: si pasáramos <code>&amp;myString</code> a <code>send</code>, le estaríamos pidiendo que mande <em>la dirección del string en nuestro proceso</em>, dato que al proceso remoto <strong>no le sirve</strong> para leer el contenido del mensaje.</p>

<p>Por último, y para hacer un único <code>recv</code> bloqueante en lugar de hacer varios <code>recv</code> que bloqueen por pocos datos, podría ser útil mandar siempre como primer dato del mensaje el tamaño total del mismo, obviamente eligiendo una cantidad fija de bytes en la que representar este dato. De este modo, el receptor siempre lee esa cantidad fija de bytes, luego hace un único <code>recv</code> del mensaje completo, y una vez que lo tiene, lo procesa por completo.</p>

<h2>Serialización vs sockets</h2>

<p><em>Che, y&hellip; Para serializar, ¿necesito saber sockets?</em></p>

<p>Bueno, no<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>. La serialización es una herramienta que permite representar en un modo &ldquo;primitivo&rdquo;, simple de almacenar y/o transmitir, alguna estructura más o menos compleja de un sistema.</p>

<p>En el TP es muy común serializar estructuras para enviarlas a otro proceso mediante sockets, pero también podríamos serializar el estado del proceso (o una parte del mismo) si necesitáramos <em>guardar</em> el estado de una tarea para resumirla más adelante. Por ejemplo, cuando usamos VirtualBox, al cerrar la VM con la opción &ldquo;Save the machine state&rdquo;, VirtualBox serializa la memoria y todo el estado de la VM actual y lo persiste en un[os] archivo<a href="" title="Lo mismo ocurre cuando cerramos un ambiente de Smalltalk guardando los cambios">s</a>.</p>

<p>Estos ejemplos claramente son independientes de los sockets (una vez serializado <em>el dato</em>, podemos simplemente hacer un <code>fwrite</code> a un archivo en disco), y aún así son perfectos casos de serialización.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>No olvidar, tampoco, little-endian vs big-endian, etc.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>El código que se muestra en el post tiene como prioridad ilustrar las ideas relacionadas con serialización con la menor cantidad de código extra posible. <strong>No sigue</strong> muchísimas de las buenas prácticas de programación, ni es digno de ser usado en código productivo, ni código de Trabajo Práctico. En particular, además de modularizar, elegir buenos nombres, etc, cualquiera que pretenda usar esto debería agregar chequeo de errores, reintentos, validaciones, etc&hellip; Y completar los parámetros faltantes de los <code>send</code> y <code>recv</code> :)<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Si sienten un olorcito a <em>fragmentación</em>, vienen bien<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Esto colabora un poco con el encapsulamiento: en otro lenguaje, los strings podrían no necesitar el <code>\0</code> al final &ndash; es una cuestión de implementación que ese <code>\0</code> exista.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Lo que no significa que no debas saber sockets para aprobar la materia :)<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">mgarciaisaia</span></span>

      








  


<time datetime="2015-02-27T00:30:00-03:00" pubdate data-updated="true">Feb 27<span>th</span>, 2015</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="/tutorial-c//twitter.com/share" class="twitter-share-button" data-url="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/" data-via="" data-counturl="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="small"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/tutorial-c/blog/2015/02/24/aprendiendo-c-con-gdb/" title="Previous Post: Aprendiendo C con GDB">&laquo; Aprendiendo C con GDB</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Acerca de...</h1>
  <p>Pequeña introducción a C y otras herramientas necesarias para desarrollar el TP de Sistemas Operativos de la UTN FRBA</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/27/dream-of-serialization/">Dream of Serialization</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/24/aprendiendo-c-con-gdb/">Aprendiendo C Con GDB</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/19/aprendiendo-assembler-para-entender-c/">Aprendiendo Assembler Para Entender C</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/07/between-a-rock-and-a-hard-link/">Between a Rock and a Hard Link</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/int-vs-int32-t/">Int vs Int32_t</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/compiladores-y-errores/">Compiladores Y Errores</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/">Un Tutorial Rápido Para Implementar Y Debuggear Malloc, Free, Calloc Y Realloc</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/09/04/p-sherman-calle-wallaby-42-sydney/">P. Sherman, Calle Wallaby 42, Sydney</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/03/20/she-bangs-she-bangs/">She Bangs, She Bangs...</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/">Me Dí Cuenta Que Me Tiraste La Señal</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/12/30/inotify/">Inotify</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/10/21/bajando-el-nivel/">Bajando El Nivel</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/08/20/variables/">Variables</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/08/19/arrancando/">Arrancando</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/sisoputnfrba">@sisoputnfrba</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'sisoputnfrba',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/tutorial-c/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - mgarciaisaia -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'tutorialc';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/';
        var disqus_url = 'http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
