
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dream of Serialization - C para Operativos</title>
  <meta name="author" content="mgarciaisaia">

  
  <meta name="description" content="Las variables de C son nombres que refieren a una posición de memoria de la computadora. El compilador traduce cada nombre a una dirección de memoria &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization">
  <link href="/tutorial-c/favicon.png" rel="icon">
  <link href="/tutorial-c/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/tutorial-c/atom.xml" rel="alternate" title="C para Operativos" type="application/atom+xml">
  <script src="/tutorial-c/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/tutorial-c/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<link rel="stylesheet" href="/tutorial-c/stylesheets/gh-fork-ribbon.css" />
<!--[if IE]>
<link rel="stylesheet" href="/tutorial-c/stylesheets/gh-fork-ribbon.ie.css" />
<![endif]-->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-59960325-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/tutorial-c/">C para Operativos</a></h1>
  
    <h2>Aprendiendo C para una cursada feliz de Sistemas Operativos</h2>
  
  </hgroup>

<div class="github-fork-ribbon-wrapper right">
	<div class="github-fork-ribbon">
		<a href="https://github.com/mgarciaisaia/octopress">¡Forkeame!</a>
	</div>
</div>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/tutorial-c/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mgarciaisaia.github.io/tutorial-c" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/tutorial-c/">Blog</a></li>
  <li><a href="/tutorial-c/blog/archives">Archives</a></li>
  <li><a href="/tutorial-c/lo-c-tutto/">Lo C Tutto</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Dream of Serialization</h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-27T00:30:00-03:00" pubdate data-updated="true">Feb 27<span>th</span>, 2015</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>Las variables de C son nombres que refieren a una posición de memoria de la computadora. El compilador traduce cada nombre a una dirección de memoria, y el tamaño de la variable está determinado por su tipo.</p>

<p>Pero si bien el estándar de C pone algunas restricciones a los tamaños de los tipos de datos básicos, no todos tienen igual tamaño en las distintas plataformas, o incluso entre distintos compiladores de C para la misma plataforma.<!-- more --></p>

<p>Además, para optimizar los accesos a memoria (operación lenta desde el punto de vista de la CPU), los compiladores suelen ubicar las variables <em>alineadas a la palabra de la CPU</em>. En general, la CPU no lee bytes individuales desde la memoria, si no que pide bloques del tamaño del ancho del bus de datos (4 bytes en máquinas de 32 bits, 8 en máquinas de 64 bits). Si una variable de 4 bytes estuviera ubicada en una posición no-múltiplo de 4 en un procesador de 32 bits, la CPU tendría que hacer 2 lecturas para accederla: una para leer el bloque de 4 bytes con los primeros bytes de la variable, y otra para el segundo bloque.</p>

<p>Esto aplica, también, a los <code>struct</code>s. Los campos de un <code>struct</code> se almacenan contiguamente en memoria, alineándose a la palabra. De hecho, <code>sizeof</code> nos va a devolver el tamaño del <code>struct</code> incluyendo los bytes de alineación (es decir, es muy probable que un <code>struct</code> compuesto por un <code>char</code> y un <code>int</code> &ndash; en ese orden &ndash; pese 8 bytes y no 5).</p>

<p>Todo esto fundamenta una única frase: no tenemos garantías sobre cómo van a organizarse los datos en un proceso que no sea el de nuestro propio programa. Encapsulamiento, que le dicen los hippies de Paradigmas :)</p>

<p>Entonces, ¿qué es la serialización? Bueno, es el arte de especificar un protocolo mediante el cual dos procesos van a comunicarse. Me encantaría poder hacer <code>send(socket, myStruct, sizeof(myStruct), ...)</code> y que eso funcione, pero si del otro lado me hacen <code>recv(socket, &amp;myStruct, sizeof(myStruct), ...)</code> no tengo ninguna garantía de que los bytes estén en el orden correcto<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (ni de que el otro proceso también haya estado hecho en C, o que exista un <code>struct</code> como el que tengo yo, etc).</p>

<p>En fin, no puedo confiar en que mi estructura pueda viajar <em>como está</em>, entonces especifico mi propio protocolo: si tengo que mandar una estructura que tiene un <code>char</code> y un <code>int</code>, especifico &ndash; por ejemplo &ndash; que siempre voy a mandar un primer byte con el <code>char</code> y luego otros 4 bytes con el <code>int</code>.</p>

<p>De este modo, en lugar de hacer el <code>send()</code> de hace un rato, seguramente prefiera primero armar un buffer para meter todo el mensaje contiguo (<em>serializado</em>), y hacer <code>send</code> de eso<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>:</p>

<figure class='code'><figcaption><span>Enviando una estructura medio primitivamente </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="p">.</span><span class="n">aChar</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="p">.</span><span class="n">anInt</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
</span><span class='line'><span class="n">send</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Del otro lado, al recibir la estructura, hago algo parecido: recibo 5 bytes (todo un mensaje), y copio el primer byte al <code>char</code>, y los 4 siguientes al <code>int</code>:</p>

<figure class='code'><figcaption><span>Recibiendo una estructura medio primitivamente </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="n">recv</span><span class="p">(</span><span class="n">mySocket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="k">struct</span> <span class="n">my_struct_t</span> <span class="o">*</span><span class="n">myStruct</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_struct_t</span><span class="p">));</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="o">-&gt;</span><span class="n">aChar</span><span class="p">),</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">myStruct</span><span class="o">-&gt;</span><span class="n">anInt</span><span class="p">),</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>De este modo, las estructuras de uno y otro lado están súper desacopladas: los campos podrían tener distintos nombres, podrían existir campos extras, tener distintas precisiones&hellip; Incluso podrían ser programas hechos en distintos lenguajes. Lo único que importa es que ambos extremos de la comunicación entiendan cómo deben interpretar esos bytes: si hago un programa en Prolog que relacione el primer byte recibido (andá a saber cómo) con un caracter, y los cuatro siguientes con un número, todos felices.</p>

<p>Es importante notar que tomamos decisiones re grosas: en nuestro protocolo, los caracteres son de 1 byte, y los enteros de 4, al menos para este mensaje. Si queremos hacer un cliente para plataformas cuyos <code>int</code> son de 2 bytes, vamos a tener que decidir cómo manejar los overflows (por ejemplo, usar variables de algún tipo más grande en nuestro <code>struct</code>, o truncar el valor recibido, o lo que sea), y mismo si estamos en 64 bits: nuestro <code>int</code> de 64 bits podría no ser representable en 4 bytes. No hay una receta universal para esto: son decisiones de diseño intrínsecas a nuestro problema.</p>

<p><em>(Continuará&hellip;)</em></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>No olvidar, tampoco, little-endian vs big-endian, etc.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>El código que se muestra en el post tiene como prioridad ilustrar las ideas relacionadas con serialización con la menor cantidad de código extra posible. <strong>No sigue</strong> muchísimas buenas prácticas de programación, ni es digno de ser usado en código productivo, ni código de Trabajo Práctico. En particular, además de modularizar, elegir buenos nombres, etc, cualquiera que pretenda usar esto debería agregar chequeo de errores, reintentos, validaciones, etc&hellip; Y completar los parámetros faltantes de los <code>send</code> y <code>recv</code> :)<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">mgarciaisaia</span></span>

      








  


<time datetime="2015-02-27T00:30:00-03:00" pubdate data-updated="true">Feb 27<span>th</span>, 2015</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="/tutorial-c//twitter.com/share" class="twitter-share-button" data-url="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/" data-via="" data-counturl="http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="small"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/tutorial-c/blog/2015/02/24/aprendiendo-c-con-gdb/" title="Previous Post: Aprendiendo C con GDB">&laquo; Aprendiendo C con GDB</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Acerca de...</h1>
  <p>Pequeña introducción a C y otras herramientas necesarias para desarrollar el TP de Sistemas Operativos de la UTN FRBA</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/27/dream-of-serialization/">Dream of Serialization</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/24/aprendiendo-c-con-gdb/">Aprendiendo C Con GDB</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/19/aprendiendo-assembler-para-entender-c/">Aprendiendo Assembler Para Entender C</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2015/02/07/between-a-rock-and-a-hard-link/">Between a Rock and a Hard Link</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/int-vs-int32-t/">Int vs Int32_t</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/compiladores-y-errores/">Compiladores Y Errores</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/12/26/un-tutorial-rapido-para-implementar-y-debuggear-malloc/">Un Tutorial Rápido Para Implementar Y Debuggear Malloc, Free, Calloc Y Realloc</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/09/04/p-sherman-calle-wallaby-42-sydney/">P. Sherman, Calle Wallaby 42, Sydney</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/03/20/she-bangs-she-bangs/">She Bangs, She Bangs...</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/">Me Dí Cuenta Que Me Tiraste La Señal</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/12/30/inotify/">Inotify</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/10/21/bajando-el-nivel/">Bajando El Nivel</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/08/20/variables/">Variables</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/08/19/arrancando/">Arrancando</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/sisoputnfrba">@sisoputnfrba</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'sisoputnfrba',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/tutorial-c/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - mgarciaisaia -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'tutorialc';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/';
        var disqus_url = 'http://mgarciaisaia.github.io/tutorial-c/blog/2015/02/27/dream-of-serialization/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
