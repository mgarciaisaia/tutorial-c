
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Me dí cuenta que me tiraste la señal - C para Operativos</title>
  <meta name="author" content="mgarciaisaia">

  
  <meta name="description" content="Uno de los mecanismos de IPC que nos provee Linux es el envío de señales. Es un modo de comunicación MUY minimalista: un proceso le envía una &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal">
  <link href="/tutorial-c/favicon.png" rel="icon">
  <link href="/tutorial-c/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/tutorial-c/atom.xml" rel="alternate" title="C para Operativos" type="application/atom+xml">
  <script src="/tutorial-c/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/tutorial-c/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<link rel="stylesheet" href="/tutorial-c/stylesheets/gh-fork-ribbon.css" />
<!--[if IE]>
<link rel="stylesheet" href="/tutorial-c/stylesheets/gh-fork-ribbon.ie.css" />
<![endif]-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/tutorial-c/">C para Operativos</a></h1>
  
    <h2>Aprendiendo C para una cursada feliz de Sistemas Operativos</h2>
  
  </hgroup>

<div class="github-fork-ribbon-wrapper right">
	<div class="github-fork-ribbon">
		<a href="https://github.com/mgarciaisaia/octopress">¡Forkeame!</a>
	</div>
</div>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/tutorial-c/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mgarciaisaia.github.io/tutorial-c" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/tutorial-c/">Blog</a></li>
  <li><a href="/tutorial-c/blog/archives">Archives</a></li>
  <li><a href="/tutorial-c/lo-c-tutto/">Lo C Tutto</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Me Dí Cuenta Que Me Tiraste La Señal</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-31T00:27:00-03:00" pubdate data-updated="true">Dec 31<span>st</span>, 2013</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>Uno de los mecanismos de <abbr title="Inter-Process Communication - Comunicación entre procesos">IPC</abbr> que nos provee Linux es el envío de señales. Es un modo de comunicación MUY minimalista: un proceso le envía una determinada señal a otro, y este último simplemente recibe el código asociado a la señal recibida.</p>

<p>Y nada más. No hay parámetros, no hay información del emisor, nada. Sólo un código.<!--more--></p>

<p>Y, aún así, es un método más que útil: para terminar un proceso en la terminal (cuando apretamos <kbd>CTRL+C</kbd>), para cerrar un programa que se colgó (desde algún administrador de tareas), para pausar la ejecución de un proceso o para cerrar un programa clickeando la <code>x</code> de cierre en su ventana &ndash; en todos estos casos estamos mandando una señal a un proceso.</p>

<p>Las señales tienen asociadas distintas acciones por defecto, que se ejecutarán cuando el proceso reciba cada señal. Por ejemplo, al recibir <code>SIGTERM</code> o <code>SIGKILL</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, el proceso finalizará con un código de salida no-exitoso, mientras que la señal <code>SIGUSR1</code> será ignorada (el proceso no hará nada al recibirla).</p>

<p>Lo interesante de las señales es que los procesos pueden especificar sus propias acciones a ejecutar cuando la señal es recibida, en lugar de ejecutar la acción por defecto. Dado que las señales se envían a los procesos<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, alguno de sus hilos se interrumpirá para pasar a ejecutar una función que nosotros determinemos cuando la señal llegue, tal como si en la línea de código que está ejecutándose al momento de recibir la señal invocara a la función determinada. Al concluir la ejecución de la función, el programa retornará al punto en que estaba antes del arribo de la señal, y todo seguirá su curso normalmente.</p>

<p>Por ser un mecanismo de IPC (es decir, involucra a más de un proceso), no hay otra opción: para que esto funcione, de algún modo <strong>debe</strong> intervenir el sistema operativo. Linux utiliza tres máscaras (bitmaps) para cada proceso, indicando qué señales deberán ignorarse, cuáles están bloqueadas (se encolan hasta ser desbloqueadas) y cuáles serán capturadas para ser atendidas por el proceso en lugar de aplicarles la acción por defecto.</p>

<p>Entonces, si el proceso tiene un manejador de señal definido, al recibir la señal el proceso bloqueará la recepción de esa señal, ejecutará la función correspondiente y, al finalizar, desbloqueará la señal. De este modo, se evita interrumpir la ejecución del manejador de la señal, para evitar conflictos con por sincronización (si el manejador lockea un mutex y se interrumpe con una nueva ejecución de si mismo antes de liberarlo, estaríamos en presencia de un auto-deadlock <code>:)</code>).</p>

<p>El problema que inspiró este post viene con el uso de <code>exec*</code>. <code>execve</code> es una llamada al sistema que reemplaza la imagen de un proceso por una nueva, pasando a ejecutar un nuevo programa. La familia de funciones <code>exec*</code> son wrappers de esa syscall.</p>

<p>Lo importante de todo esto son dos cosas: una <code>execve</code> exitosa no retorna, y reemplazar la imagen de un proceso no implica cambiar los atributos del mismo. De <code>man 2 execve</code>:</p>

<pre><code>All process attributes are preserved during an execve(), except the following:
</code></pre>

<p>Y, adiviná qué: las máscaras de las señales no son parte de las excepciones. Entonces, repasemos: llega la señal, se bloquean la señal recibida, y se ejecuta el handler de la señal. Si ese handler hiciera un <code>execve</code> exitoso, la función no retorna: empieza a ejecutar el nuevo proceso. Pero, si el handler no retorna, nunca se desbloquea la señal, por lo que el nuevo proceso no recibirá más la señal especificada, porque serán encoladas eternamente. Bang.</p>

<p>La solución a esto es desbloquear la señal a mano antes de llamar a <code>execve</code>. En C, desde dentro del handler, podríamos lograrlo usando este fragmento de código:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>
</span><span class='line'><span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
</span><span class='line'><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
</span><span class='line'><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>sigemptyset</code> inicializa un set de señales vacío, y luego marcamos la señal que nos interese (en este caso, <code>SIGINT</code>) en ese set. Por último, la función <code>sigprocmask</code> es la que se encargará, con estos parámetros, de desbloquear el set de señales marcados (sólo <code>SIGINT</code>). Luego de esto, sí, podremos ejecutar <code>execve</code> sin problemas.</p>

<p><strong>Créditos</strong>: mucha información de este post surgió a partir de <a href="http://stackoverflow.com/a/1024778">esta respuesta en StackOverflow</a>.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Se pueden listar todas las señales ejecutando <code>kill -l</code><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>En Linux, que tiene <abbr title="Kernel Level Thread - Hilos de Kernel">KLTs</abbr>, uno puede enviar la señal especificando un <abbr title="Thread ID - Identificador de Hilo">TID</abbr> en lugar de un <abbr title="Process ID - Identificador de Proceso">PID</abbr>, por lo que puede mandarle la señal a un hilo en particular. Poniéndonos más técnicos, el PID coincide con el TID del hilo principal (<code>main()</code>), por lo que al enviarle la señal al proceso en realidad se la estamos enviando al hilo principal. Pero la idea genérica de &ldquo;las señales se envían a procesos&rdquo; es más feliz.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">mgarciaisaia</span></span>

      








  


<time datetime="2013-12-31T00:27:00-03:00" pubdate data-updated="true">Dec 31<span>st</span>, 2013</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="/tutorial-c//twitter.com/share" class="twitter-share-button" data-url="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/" data-via="sisoputnfrba" data-counturl="http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="small"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/tutorial-c/blog/2013/12/30/inotify/" title="Previous Post: inotify">&laquo; inotify</a>
      
      
        <a class="basic-alignment right" href="/tutorial-c/blog/2014/03/20/she-bangs-she-bangs/" title="Next Post: She bangs, she bangs...">She bangs, she bangs... &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Acerca de...</h1>
  <p>Pequeña introducción a C y otras herramientas necesarias para desarrollar el TP de Sistemas Operativos de la UTN FRBA</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/tutorial-c/blog/2014/03/20/she-bangs-she-bangs/">She Bangs, She Bangs...</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/">Me Dí Cuenta Que Me Tiraste La Señal</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/12/30/inotify/">Inotify</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/10/21/bajando-el-nivel/">Bajando El Nivel</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/08/20/variables/">Variables</a>
      </li>
    
      <li class="post">
        <a href="/tutorial-c/blog/2013/08/19/arrancando/">Arrancando</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/sisoputnfrba">@sisoputnfrba</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'sisoputnfrba',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/tutorial-c/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - mgarciaisaia -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'tutorialc';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/';
        var disqus_url = 'http://mgarciaisaia.github.io/tutorial-c/blog/2013/12/31/me-di-cuenta-que-me-tiraste-la-senal/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
